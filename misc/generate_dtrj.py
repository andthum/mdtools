#!/usr/bin/env python3

# This file is part of MDTools.
# Copyright (C) 2021-2023  The MDTools Development Team and all
# contributors listed in the file AUTHORS.rst
#
# MDTools is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or (at your
# option) any later version.
#
# MDTools is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License
# along with MDTools.  If not, see <http://www.gnu.org/licenses/>.


r"""
Generate an artificial discrete trajectory with a given number of states
with a given lifetime distribution.

The lifetime distribution follows the gamma distribution

.. math::

    p(x) = x^{k-1} \frac{e^{-x / \theta}}{\theta^k \Gamma(k)}

with :math:`\Gamma(z)` being the gamma function.  If :math:`k` is unity,
the gamma distribution becomes the exponential distribution

.. math::

    f(x) = \frac{1}{\theta} \exp{\left( -\frac{x}{\theta} \right)}

Options
-------
-o
    Output filename for the generated discrete trajectory.   The
    discrete trajectory is written as binary :file:`dtrj.npy` file in a
    compressed |npz_archive| of the given filename.  The discrete
    trajectory is stored as :class:`numpy.ndarray` of dtype
    :attr:`numpy.uint8` and shape ``(n, f)``, where ``n`` is the number
    of compounds and ``f`` is the number of frames.  The elements of the
    discrete trajectory are the states in which a given compound resides
    at a given frame.
--hist
    Output filename for a histogram plot of the drawn state lifetimes.
    The histogram shows the lifetimes that were drawn from the
    exponential distribution for each state.
-k
    :math:`k` values to use for the lifetime distribution of each state.
    The number of :math:`k` determines the number of different states in
    the generated discrete trajectory.  States are sequentially numbered
    starting from zero.  At least two values must be given.  Default:
    ``[1, 1]``
--theta
    :math:`\theta` values to use for the lifetime distribution of each
    state.  The number of given :math:`\theta` values must match the
    number of given :math:`k` values.  Default: ``[10, 100]``.
--shape
    The shape ``(n, f)`` of the generated discrete trajectory.  Default:
    ``(1, 1000)``.
--seed
    Seed to use for the random number generator.  If not ``None``, a
    random seed will be generated by calling ``secrets.randbits(128)``.
    Default: ``None``.

See Also
--------
:mod:`misc.compare_dtrj_lifetime_methods.py` :
    Compare state lifetimes calculated from a discrete trajectory using
    different methods

Notes
-----
The discrete trajectory is generated in the following way:

    1. Select a random state.  Thereby, ensure that the selected state
       is different from the previously selected state.
    2. Draw a random number from the gamma distribution of lifetimes
       assigned to the selected state.  The drawn number is rounded to
       the next integer.  If the drawn number is zero, the selected
       state is discarded and another state is selected.
    3. Extend the discrete trajectory with the selected state by as many
       frames as determined by the drawn lifetime.
    4. Clip the generated trajectory at the desired length.

"""


__author__ = "Andreas Thum"


# Standard libraries
import argparse
import os
import secrets
import sys
from datetime import datetime, timedelta

# Third-party libraries
import matplotlib.pyplot as plt
import numpy as np
import psutil
from matplotlib.backends.backend_pdf import PdfPages
from matplotlib.ticker import MaxNLocator
from scipy import stats

# First-party libraries
import mdtools as mdt
import mdtools.plot as mdtplt  # Load MDTools plot style  # noqa: F401


if __name__ == "__main__":  # noqa: C901
    timer_tot = datetime.now()
    proc = psutil.Process()
    proc.cpu_percent()  # Initiate monitoring of CPU usage.
    parser = argparse.ArgumentParser(
        description=(
            "Generate artificial discrete trajectories for testing purposes."
        )
    )
    parser.add_argument(
        "-o",
        dest="DTRJ_OUT",
        type=str,
        required=True,
        help="Output filename for the generated discrete trajectory.",
    )
    parser.add_argument(
        "--hist",
        dest="HIST_OUT",
        type=str,
        required=False,
        default=None,
        help=(
            "Output filename for a histogram plot of the drawn state lifetimes"
            " (optional)."
        ),
    )
    parser.add_argument(
        "-k",
        dest="K",
        type=float,
        nargs="+",
        required=False,
        default=[1, 1],
        help=(
            "k values to use for the lifetime distribution of each state."
            "  Default: %(default)s."
        ),
    )
    parser.add_argument(
        "--theta",
        dest="THETA",
        type=float,
        nargs="+",
        required=False,
        default=[10, 100],
        help=(
            "Theta values to use for the lifetime distribution of each state."
            "  Default: %(default)s."
        ),
    )
    parser.add_argument(
        "--shape",
        dest="SHAPE",
        type=int,
        nargs=2,
        required=False,
        default=[1, 1000],
        help=(
            "The shape of the generated discrete trajectory.  Default:"
            " %(default)s."
        ),
    )
    parser.add_argument(
        "--seed",
        dest="SEED",
        type=int,
        required=False,
        default=None,
        help=(
            "Seed to use for the random number generator.  Default:"
            " %(default)s"
        ),
    )
    args = parser.parse_args()
    print(mdt.rti.run_time_info_str())
    k = np.asarray(args.K)
    if np.any(k < 0):
        raise ValueError("-k ({}) must be positive".format(args.K))
    if len(k) < 2:
        raise ValueError("-k ({}) must get at least two values".format(args.K))
    theta = np.asarray(args.THETA)
    if np.any(theta < 0):
        raise ValueError("--theta ({}) must be positive".format(args.THETA))
    if theta.shape != k.shape:
        raise ValueError(
            "--theta ({}) must get as many values as -k"
            " ({})".format(args.THETA, args.K)
        )
    shape = tuple(args.SHAPE)
    if np.any(np.asarray(shape) < 1):
        raise ValueError(
            "--shape ({}) must be greater than one".format(args.SHAPE)
        )
    if args.SEED is not None and args.SEED < 0:
        raise ValueError("--seed ({}) must not be negative".format(args.SEED))

    n_cmps, n_frames = shape
    n_states = len(theta)
    state_ix = np.arange(n_states, dtype=np.uint8)
    if args.SEED is None:
        args.SEED = secrets.randbits(128)
    rng = np.random.default_rng(args.SEED)
    if args.HIST_OUT is not None:
        lifetimes = [[] for six in state_ix]

    print("\n")
    print("Generating discrete trajectory...")
    timer = datetime.now()
    dtrj = [[] for cmp_ix in range(n_cmps)]
    for cmp_ix in range(n_cmps):
        n_frames_cmp = np.uint32(0)
        six_prev = rng.choice(state_ix)
        while n_frames_cmp < n_frames:
            # Select a random state.  Thereby, ensure that the selected
            # state is different from the previously selected state.
            mask = state_ix != six_prev
            six = rng.choice(state_ix[mask])
            # Draw a random number assuming a gamma distribution of
            # lifetimes for the selected state.
            lifetime = rng.gamma(shape=k[six], scale=theta[six])
            lifetime = np.uint32(round(lifetime))
            if args.HIST_OUT is not None:
                # Histogram of the *drawn* lifetimes (`lifetime`), not
                # the actually appended lifetimes (`n_frames_append`).
                lifetimes[six].append(lifetime)
            if lifetime == 0:
                # Discard the selected state and select another state.
                continue
            # Extend the trajectory by the drawn lifetime with the
            # selected state.  If the trajectory would exceed the
            # pre-defined length, clip it.
            n_frames_append = min(lifetime, n_frames - n_frames_cmp)
            if n_frames_append <= 0:
                raise ValueError(
                    "`n_frames_append` ({}) <= 0.  This should not have"
                    " happened".format(n_frames_append)
                )
            dtrj[cmp_ix].append(np.full(n_frames_append, six, dtype=np.uint8))
            # Increase frame counter.
            n_frames_cmp += n_frames_append
            # Store the selected state as previous state.
            six_prev = six
        dtrj[cmp_ix] = np.concatenate(dtrj[cmp_ix])
        if len(dtrj[cmp_ix]) != n_frames:
            raise ValueError(
                "len(dtrj[{}]) ({}) != n_frames ({}).  This should not have"
                " happened".format(cmp_ix, len(dtrj[cmp_ix]), n_frames)
            )
    dtrj = np.asarray(dtrj)
    if dtrj.shape != shape:
        raise ValueError(
            "dtrj.shape ({}) != shape ({}).  This should not have"
            " happened".format(dtrj.shape, shape)
        )
    print("Elapsed time:         {}".format(datetime.now() - timer))
    print("Current memory usage: {:.2f} MiB".format(mdt.rti.mem_usage(proc)))

    print("\n")
    print("Creating output...")
    timer = datetime.now()
    mdt.fh.save_dtrj(args.DTRJ_OUT, dtrj)
    del dtrj
    print("Created {}".format(args.DTRJ_OUT))
    print("Elapsed time:         {}".format(datetime.now() - timer))
    print("Current memory usage: {:.2f} MiB".format(mdt.rti.mem_usage(proc)))

    if args.HIST_OUT is not None:
        print("\n")
        print("Creating output...")
        timer = datetime.now()

        # Estimate common bin edges for the lifetime distributions of
        # all states.
        mean = k * theta  # Mean of the gamma distribution.
        bin_width = max(1, np.min(mean) // 2)
        lifetime_max = [np.max(lt) if len(lt) > 0 else 0 for lt in lifetimes]
        lifetime_max = max(1, np.max(lifetime_max))
        bins = np.arange(
            0, lifetime_max + bin_width, bin_width, dtype=np.uint32
        )
        bin_mids = bins[1:] - np.diff(bins) / 2

        alpha = 0.75
        cmap = plt.get_cmap()
        c_vals = np.arange(n_states)
        c_norm = n_states - 1
        c_vals_normed = c_vals / c_norm
        colors = cmap(c_vals_normed)

        mdt.fh.backup(args.HIST_OUT)
        with PdfPages(args.HIST_OUT) as pdf:
            for density in (False, True):
                fig, ax = plt.subplots(clear=True)
                for six, lt in enumerate(lifetimes):
                    hist, bin_edges, patches = ax.hist(
                        lt,
                        bins=bins,
                        density=density,
                        label="$%d$" % six,
                        color=colors[six],
                        alpha=0.5,
                        rasterized=True,
                    )
                    if density:
                        lines = ax.plot(
                            bin_mids,
                            stats.gamma.pdf(
                                bin_mids, a=k[six], scale=theta[six]
                            ),
                            linestyle="dashed",
                            color=colors[six],
                            alpha=alpha,
                        )
                for six in state_ix:
                    # New loop to put the labels of `ax.axvline` at last
                    # in the legend.
                    ax.axvline(
                        mean[six],
                        linestyle="dotted",
                        color=colors[six],
                        alpha=alpha,
                    )
                ax.set(
                    xlabel="State Lifetime / Frames",
                    ylabel="Probability" if density else "Count",
                    xlim=(0, None),
                    ylim=(0, None),
                )
                ax.xaxis.set_major_locator(MaxNLocator(integer=True))
                ax.legend(
                    title="State",
                    loc="upper right",
                    ncol=1 + n_states // 6,
                    **mdtplt.LEGEND_KWARGS_XSMALL,
                )
                pdf.savefig()
                plt.close()
        print("Created {}".format(args.HIST_OUT))
        print("Elapsed time:         {}".format(datetime.now() - timer))
        print(
            "Current memory usage: {:.2f} MiB".format(mdt.rti.mem_usage(proc))
        )

    print("\n")
    print("{} done".format(os.path.basename(sys.argv[0])))
    print("Totally elapsed time: {}".format(datetime.now() - timer_tot))
    _cpu_time = timedelta(seconds=sum(proc.cpu_times()[:4]))
    print("CPU time:             {}".format(_cpu_time))
    print("CPU usage:            {:.2f} %".format(proc.cpu_percent()))
    print("Current memory usage: {:.2f} MiB".format(mdt.rti.mem_usage(proc)))
