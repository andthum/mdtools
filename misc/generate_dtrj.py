#!/usr/bin/env python3

# This file is part of MDTools.
# Copyright (C) 2021-2023  The MDTools Development Team and all
# contributors listed in the file AUTHORS.rst
#
# MDTools is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or (at your
# option) any later version.
#
# MDTools is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License
# along with MDTools.  If not, see <http://www.gnu.org/licenses/>.


r"""
Generate an artificial discrete trajectory with a given number of states
with a given lifetime distribution.

Options
-------
-o
    Output filename for the generated discrete trajectory.   The
    discrete trajectory is written as binary :file:`dtrj.npy` file in a
    compressed |npz_archive| of the given filename.  The discrete
    trajectory is stored as :class:`numpy.ndarray` of dtype
    :attr:`numpy.uint8` and shape ``(n, f)``, where ``n`` is the number
    of compounds and ``f`` is the number of frames.  The elements of the
    discrete trajectory are the states in which a given compound resides
    at a given frame.
--hist
    Output filename for a histogram plot of the drawn state lifetimes.
    The histogram shows the lifetimes that were drawn from the
    exponential distribution for each state.
--tau
    Average lifetime of each state in the discrete trajectory.
    Lifetimes are drawn randomly from an exponential distribution with
    the given average lifetime.  The number of given average lifetimes
    determines the number of different states in the generated discrete
    trajectory.  States are sequentially numbered starting from zero.
    \--tau takes at least two values.  Default: ``[10, 100]``.
--shape
    The shape ``(n, f)`` of the generated discrete trajectory.  Default:
    ``(32, 1024)``.
--seed
    Seed to use for the random number generator.  If not ``None``, a
    random seed will be generated by calling ``secrets.randbits(128)``.
    Default: ``None``.

Notes
-----
The discrete trajectory is generated in the following way:

    1. Select a random state.  Thereby, ensure that the selected state
       is different from the previously selected state.
    2. Draw a random number from an exponential distribution.  The scale
       of the exponential distribution is given by the average lifetime
       of the selected state.  The drawn number is rounded to the next
       integer.  If the drawn number is zero, the selected state is
       discarded and another state is selected.
    3. Extend the discrete trajectory with a sequence of the selected
       state.  The length of the sequence is given by the drawn random
       number.
    4. Clip the generated trajectory at the desired length.

"""


__author__ = "Andreas Thum"


# Standard libraries
import argparse
import os
import secrets
import sys
from datetime import datetime, timedelta

# Third-party libraries
import matplotlib.pyplot as plt
import numpy as np
import psutil
from matplotlib.backends.backend_pdf import PdfPages
from matplotlib.ticker import MaxNLocator

# First-party libraries
import mdtools as mdt
import mdtools.plot as mdtplt  # Load MDTools plot style  # noqa: F401


if __name__ == "__main__":
    timer_tot = datetime.now()
    proc = psutil.Process()
    proc.cpu_percent()  # Initiate monitoring of CPU usage.
    parser = argparse.ArgumentParser(
        description=(
            "Generate artificial discrete trajectories for testing purposes."
        )
    )
    parser.add_argument(
        "-o",
        dest="DTRJ_OUT",
        type=str,
        required=True,
        help="Output filename for the generated discrete trajectory.",
    )
    parser.add_argument(
        "--hist",
        dest="HIST_OUT",
        type=str,
        required=False,
        default=None,
        help=(
            "Output filename for a histogram plot of the drawn state lifetimes"
            " (optional)."
        ),
    )
    parser.add_argument(
        "--tau",
        dest="TAU",
        type=int,
        nargs="+",
        required=False,
        default=[10, 100],
        help=(
            "Lifetime of each state in trajectory steps.  Default:"
            " %(default)s."
        ),
    )
    parser.add_argument(
        "--shape",
        dest="SHAPE",
        type=int,
        nargs=2,
        required=False,
        default=[1, 10000],
        help=(
            "The shape of the generated discrete trajectory.  Default:"
            " %(default)s."
        ),
    )
    parser.add_argument(
        "--seed",
        dest="SEED",
        type=int,
        required=False,
        default=None,
        help=(
            "Seed to use for the random number generator.  Default:"
            " %(default)s"
        ),
    )
    args = parser.parse_args()
    print(mdt.rti.run_time_info_str())
    tau = np.asarray(args.TAU)
    if np.any(tau < 1):
        raise ValueError(
            "--tau ({}) must be greater than one".format(args.TAU)
        )
    if len(tau) < 2:
        raise ValueError(
            "--tau ({}) must get at least two values".format(args.TAU)
        )
    shape = tuple(args.SHAPE)
    if np.any(np.asarray(shape) < 1):
        raise ValueError(
            "--shape ({}) must be greater than one".format(args.SHAPE)
        )
    if args.SEED is not None and args.SEED < 0:
        raise ValueError("--seed ({}) must not be negative".format(args.SEED))

    n_cmps, n_frames = shape
    n_states = len(tau)
    state_ix = np.arange(n_states, dtype=np.uint8)
    if args.SEED is None:
        args.SEED = secrets.randbits(128)
    rng = np.random.default_rng(args.SEED)
    if args.HIST_OUT is not None:
        lifetimes = [[] for six in state_ix]

    print("\n")
    print("Generating discrete trajectory...")
    timer = datetime.now()
    dtrj = [[] for cmp_ix in range(n_cmps)]
    for cmp_ix in range(n_cmps):
        n_frames_cmp = np.uint32(0)
        six_prev = rng.choice(state_ix)
        while n_frames_cmp < n_frames:
            # Select a random state.  Thereby, ensure that the selected
            # state is different from the previously selected state.
            mask = state_ix != six_prev
            six = rng.choice(state_ix[mask])
            # Draw a random number assuming an exponential distribution
            # of lifetimes for the selected state.
            lifetime = np.uint32(round(rng.exponential(scale=tau[six])))
            if args.HIST_OUT is not None:
                # Histogram of the *drawn* lifetimes (`lifetime`), not
                # the actually appended lifetimes (`n_frames_append`).
                lifetimes[six].append(lifetime)
            if lifetime == 0:
                # Discard the selected state and select another state.
                continue
            # Extend the trajectory by the drawn lifetime with the
            # selected state.  If the trajectory would exceed the
            # pre-defined length, clip it.
            n_frames_append = min(lifetime, n_frames - n_frames_cmp)
            if n_frames_append <= 0:
                raise ValueError(
                    "`n_frames_append` ({}) <= 0.  This should not have"
                    " happened".format(n_frames_append)
                )
            dtrj[cmp_ix].append(np.full(n_frames_append, six, dtype=np.uint8))
            # Increase frame counter.
            n_frames_cmp += n_frames_append
            # Store the selected state as previous state.
            six_prev = six
        dtrj[cmp_ix] = np.concatenate(dtrj[cmp_ix])
        if len(dtrj[cmp_ix]) != n_frames:
            raise ValueError(
                "len(dtrj[{}]) ({}) != n_frames ({}).  This should not have"
                " happened".format(cmp_ix, len(dtrj[cmp_ix]), n_frames)
            )
    dtrj = np.asarray(dtrj)
    if dtrj.shape != shape:
        raise ValueError(
            "dtrj.shape ({}) != shape ({}).  This should not have"
            " happened".format(dtrj.shape, shape)
        )
    print("Elapsed time:         {}".format(datetime.now() - timer))
    print("Current memory usage: {:.2f} MiB".format(mdt.rti.mem_usage(proc)))

    print("\n")
    print("Creating output...")
    timer = datetime.now()
    mdt.fh.save_dtrj(args.DTRJ_OUT, dtrj)
    del dtrj
    print("Created {}".format(args.DTRJ_OUT))
    print("Elapsed time:         {}".format(datetime.now() - timer))
    print("Current memory usage: {:.2f} MiB".format(mdt.rti.mem_usage(proc)))

    if args.HIST_OUT is not None:
        print("\n")
        print("Creating output...")
        timer = datetime.now()

        lifetime_max = [np.max(lt) if len(lt) > 0 else 0 for lt in lifetimes]
        lifetime_max = max(1, np.max(lifetime_max))
        bin_width = max(1, np.min(tau) // 2)
        bins = np.arange(
            0, lifetime_max + bin_width, bin_width, dtype=np.uint32
        )
        bin_mids = bins[1:] - np.diff(bins) / 2

        alpha = 0.75
        cmap = plt.get_cmap()
        c_vals = np.arange(n_states)
        c_norm = n_states - 1
        c_vals_normed = c_vals / c_norm
        colors = cmap(c_vals_normed)
        mdt.fh.backup(args.HIST_OUT)
        with PdfPages(args.HIST_OUT) as pdf:
            for density in (False, True):
                fig, ax = plt.subplots(clear=True)
                for six, lt in enumerate(lifetimes):
                    hist, bin_edges, patches = ax.hist(
                        lt,
                        bins=bins,
                        density=density,
                        label="$%d$" % six,
                        color=colors[six],
                        alpha=0.5,
                        rasterized=True,
                    )
                    if density:
                        lines = ax.plot(
                            bin_mids,
                            mdt.stats.exp_dist(bin_mids, 1 / tau[six]),
                            linestyle="dashed",
                            color=colors[six],
                            alpha=alpha,
                        )
                for six in state_ix:
                    # New loop to put the labels of `ax.axvline` at last
                    # in the legend.
                    ax.axvline(
                        tau[six],
                        linestyle="dotted",
                        color=colors[six],
                        label=r"$\tau_{%d}$" % six,
                        alpha=alpha,
                    )
                ax.set(
                    xlabel="State Lifetime / Frames",
                    ylabel="Probability" if density else "Count",
                    xlim=(0, None),
                    ylim=(0, None),
                )
                ax.xaxis.set_major_locator(MaxNLocator(integer=True))
                ax.legend(title="State", loc="upper right", ncol=2)
                pdf.savefig()
                plt.close()
        print("Created {}".format(args.HIST_OUT))
        print("Elapsed time:         {}".format(datetime.now() - timer))
        print(
            "Current memory usage: {:.2f} MiB".format(mdt.rti.mem_usage(proc))
        )

    print("\n")
    print("{} done".format(os.path.basename(sys.argv[0])))
    print("Totally elapsed time: {}".format(datetime.now() - timer_tot))
    _cpu_time = timedelta(seconds=sum(proc.cpu_times()[:4]))
    print("CPU time:             {}".format(_cpu_time))
    print("CPU usage:            {:.2f} %".format(proc.cpu_percent()))
    print("Current memory usage: {:.2f} MiB".format(mdt.rti.mem_usage(proc)))
