#!/usr/bin/env python3

# This file is part of MDTools.
# Copyright (C) 2021-2023  The MDTools Development Team and all
# contributors listed in the file AUTHORS.rst
#
# MDTools is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or (at your
# option) any later version.
#
# MDTools is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License
# along with MDTools.  If not, see <http://www.gnu.org/licenses/>.


r"""
Generate an artificial discrete trajectory with a given number of states
with a given lifetime distribution.

Options
-------
-o
    Output filename for the generated discrete trajectory.   The
    discrete trajectory is written as binary :file:`dtrj.npy` file in a
    compressed |npz_archive| of the given filename.  The discrete
    trajectory is stored as :class:`numpy.ndarray` of dtype
    :attr:`numpy.uint32` and shape ``(n, f)``, where ``n`` is the number
    of compounds and ``f`` is the number of frames.  The elements of the
    discrete trajectory are the states in which a given compound resides
    at a given frame.
--tau
    Average lifetime of each state in the discrete trajectory.
    Lifetimes are drawn randomly from an exponential distribution with
    the given average lifetime.  The number of given average lifetimes
    determines the number of different states in the generated discrete
    trajectory.  States are sequentially numbered starting from zero.
    \--tau takes at least two values.  Default: ``[10, 100]``.
--shape
    The shape ``(n, f)`` of the generated discrete trajectory.  Default:
    ``(32, 1024)``.
--seed
    Seed to use for the random number generator.  If not ``None``, a
    random seed will be generated by calling ``secrets.randbits(128)``.
    Default: ``None``.

Notes
-----
The discrete trajectory is generated in the following way:

    1. Select a random state.  Thereby ensured that the selected state
       is different from the previously selected state.
    2. Draw a random number from an exponential distribution whose
       average is the average lifetime of the selected state.  Extend
       the discrete trajectory with a sequence of the selected state
       whose length is equal to the drawn random number.
    3. Clip the generated trajectory at the desired length.

"""


__author__ = "Andreas Thum"


# Standard libraries
import argparse
import os
import secrets
import sys
from datetime import datetime, timedelta

# Third-party libraries
import numpy as np
import psutil

# First-party libraries
import mdtools as mdt


if __name__ == "__main__":
    timer_tot = datetime.now()
    proc = psutil.Process()
    proc.cpu_percent()  # Initiate monitoring of CPU usage.
    parser = argparse.ArgumentParser(
        description=(
            "Generate artificial discrete trajectories for testing purposes."
        )
    )
    parser.add_argument(
        "-o",
        dest="OUTFILE",
        type=str,
        required=True,
        help="Output filename.",
    )
    parser.add_argument(
        "--tau",
        dest="TAU",
        type=int,
        nargs="+",
        required=False,
        default=[10, 100],
        help=(
            "Lifetime of each state in trajectory steps.  Default:"
            " %(default)s."
        ),
    )
    parser.add_argument(
        "--shape",
        dest="SHAPE",
        type=int,
        nargs=2,
        required=False,
        default=[32, 1024],
        help=(
            "The shape of the generated discrete trajectory.  Default:"
            " %(default)s."
        ),
    )
    parser.add_argument(
        "--seed",
        dest="SEED",
        type=int,
        required=False,
        default=None,
        help=(
            "Seed to use for the random number generator.  Default:"
            " %(default)s"
        ),
    )
    args = parser.parse_args()
    print(mdt.rti.run_time_info_str())
    tau = np.asarray(args.TAU)
    if np.any(tau < 1):
        raise ValueError(
            "--tau ({}) must be greater than one".format(args.TAU)
        )
    if len(tau) < 2:
        raise ValueError(
            "--tau ({}) must get at least two values".format(args.TAU)
        )
    shape = tuple(args.SHAPE)
    if np.any(np.asarray(shape) < 1):
        raise ValueError(
            "--shape ({}) must be greater than one".format(args.SHAPE)
        )
    if args.SEED is not None and args.SEED < 0:
        raise ValueError("--seed ({}) must not be negative".format(args.SEED))

    n_cmps, n_frames = shape
    n_states = len(tau)
    state_ix = np.arange(n_states)
    if args.SEED is None:
        args.SEED = secrets.randbits(128)
    rng = np.random.default_rng(args.SEED)

    print("\n")
    print("Generating discrete trajectory...")
    timer = datetime.now()
    dtrj = [[] for cmp_ix in range(n_cmps)]
    for cmp_ix in range(n_cmps):
        six_prev = rng.choice(state_ix)
        while len(dtrj[cmp_ix]) < n_frames:
            # Select a random state.  Thereby, ensure that the selected
            # state is different from the previously selected state.
            mask = state_ix != six_prev
            six = rng.choice(state_ix[mask])
            # Draw a random number assuming an exponential distribution
            # of lifetimes for the selected state.
            lifetime = round(rng.exponential(scale=tau[six]))
            # Extend the trajectory by the drawn lifetime with the
            # selected state.
            dtrj[cmp_ix].append(np.full(lifetime, six, dtype=np.uint32))
            six_prev = six
        dtrj[cmp_ix] = np.concatenate(dtrj[cmp_ix])
        dtrj[cmp_ix] = dtrj[cmp_ix][:n_frames]
    dtrj = np.asarray(dtrj)
    print("Elapsed time:         {}".format(datetime.now() - timer))
    print("Current memory usage: {:.2f} MiB".format(mdt.rti.mem_usage(proc)))

    print("\n")
    print("Creating output...")
    timer = datetime.now()
    mdt.fh.save_dtrj(args.OUTFILE, dtrj)
    print("Created {}".format(args.OUTFILE))
    print("Elapsed time:         {}".format(datetime.now() - timer))
    print("Current memory usage: {:.2f} MiB".format(mdt.rti.mem_usage(proc)))

    print("\n")
    print("{} done".format(os.path.basename(sys.argv[0])))
    print("Totally elapsed time: {}".format(datetime.now() - timer_tot))
    _cpu_time = timedelta(seconds=sum(proc.cpu_times()[:4]))
    print("CPU time:             {}".format(_cpu_time))
    print("CPU usage:            {:.2f} %".format(proc.cpu_percent()))
    print("Current memory usage: {:.2f} MiB".format(mdt.rti.mem_usage(proc)))
