#!/usr/bin/env python3

# This file is part of MDTools.
# Copyright (C) 2021-2023  The MDTools Development Team and all
# contributors listed in the file AUTHORS.rst
#
# MDTools is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or (at your
# option) any later version.
#
# MDTools is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License
# along with MDTools.  If not, see <http://www.gnu.org/licenses/>.


"""
Plot the lifetimes generated by
:mod:`misc.dtrj_lifetimes.compare_dtrj_lifetime_methods` for a given set
of lifetime distributions.
"""


__author__ = "Andreas Thum"


# Standard libraries
import glob
import os
import sys

# Third-party libraries
import matplotlib.pyplot as plt
import numpy as np
from matplotlib.backends.backend_pdf import PdfPages

# First-party libraries
import mdtools as mdt
import mdtools.plot as mdtplt  # Load MDTools plot style  # noqa: F401


if __name__ == "__main__":  # noqa: C901
    ####################################################################
    # Input parameters.
    dist_name = "Exp. Dist."
    sort_by = "n_cmps"

    dist = "_gengamma"  # _gengamma, _burr12
    beta = "_beta_1_1"
    delta = "_delta_1_1"
    tau0 = "_tau0_10_100"
    shape = "_shape_*_10"  # n_cmps, n_frames
    discard = "_discard_1000"
    seed = "_seed_5462_4894_3496_8436"
    every = ""
    infile_pattern = (
        "dtrj"
        + dist
        + beta
        + delta
        + tau0
        + shape
        + discard
        + seed
        + every
        + "_compare_dtrj_lifetime_methods.txt.gz"
    )
    outfile = infile_pattern.replace(".txt.gz", ".pdf")
    outfile = outfile.replace("*", "N")
    ####################################################################

    ####################################################################
    # Column indices for the input file(s).
    col_states = 0
    col_dist_params = 132  # to 134
    # Lifetimes from the counting methods.
    col_cnt_cen = 1  # to 14
    col_cnt_unc = 15  # to 28
    col_k = 29
    # Lifetimes from remain probabilities.
    col_rp_int = 30  # to 39
    col_rp_wbl = 40  # to 55
    col_rp_brr = 56  # to 73
    col_rp_fit_end = 75
    # Lifetimes from Kaplan-Meier estimates.
    col_km_int = 76  # to 85
    col_km_wbl = 86  # to 101
    col_km_brr = 102  # to 119
    col_km_fit_end = 121
    # True lifetimes
    col_dst = 122  # to 131
    ####################################################################

    ####################################################################
    # Read data.
    infiles = glob.glob(infile_pattern)
    if len(infiles) < 1:
        raise ValueError(
            "The glob pattern does not match anything:"
            " {}".format(infile_pattern)
        )
    shapes = []
    data = []
    for infile in infiles:
        data_file = np.loadtxt(infile, ndmin=2)
        # Only keep the row that contains the data for state 1.
        valid = data_file[:, col_states] == 1
        if not np.any(valid):
            data.append(np.full(data_file.shape[1], np.nan))
        elif np.count_nonzero(valid) != 1:
            raise ValueError(
                "The input file contains multiple rows with state 1:"
                " '{}'".format(infile)
            )
        else:
            data.append(np.squeeze(data_file[valid]))
        shape = infile.split("_shape_")[1].split("_")[:2]
        shapes.append([int(s) for s in shape])
    if len(data) < 1:
        raise ValueError("None of the input files contained data for state 1")
    shapes = np.transpose(np.asarray(shapes))
    data = np.transpose(np.asarray(data))
    ####################################################################

    ####################################################################
    # Sort data.
    if sort_by == "n_cmps":
        sort_ix = np.argsort(shapes[0])
        xdata = shapes[0][sort_ix]
        xlim = (5e-1, 2e5)
        xlabel = "Number of Particles"
        legend_title = (
            dist_name + r", $\tau_0 = %d$" % data[col_dist_params][0]
        )
    elif sort_by == "n_frames":
        sort_ix = np.argsort(shapes[1])
        xdata = shapes[1][sort_ix]
        xlim = (5e0, 2e5)
        xlabel = "Number of Frames"
        legend_title = (
            dist_name + r", $\tau_0 = %d$" % data[col_dist_params][0]
        )
    elif sort_by == "every":
        every_n = np.array(
            [
                int(infile.split("_every_")[1].split("_")[0])
                for infile in infiles
            ]
        )
        sort_ix = np.argsort(every_n)
        xdata = every_n[sort_ix]
        xlim = (8e-1, 5e2)
        xlabel = "Sample Interval / Frames"
        legend_title = (
            dist_name + r", $\tau_0 = %d$" % data[col_dist_params][0]
        )
    elif sort_by == "tau0_true":
        sort_ix = np.argsort(data[col_dist_params])
        xdata = data[col_dist_params][sort_ix]
        xlim = (2e1, 5e2)
        xlabel = r"Scale Parameter $\tau_0$ / Frames"
        legend_title = dist_name
    elif sort_by == "beta_true":
        sort_ix = np.argsort(data[col_dist_params + 1])
        xdata = data[col_dist_params + 1][sort_ix]
        xlabel = r"Shape Parameter $\beta$"
        legend_title = (
            dist_name + r", $\tau_0 = %d$" % data[col_dist_params][0]
        )
        if dist_name == "Log-Logistic Dist.":
            xlim = (1e0, 2e1)
        else:
            xlim = (2e-1, 5e0)
    elif sort_by == "delta_true":
        sort_ix = np.argsort(data[col_dist_params + 2])
        xdata = data[col_dist_params + 2][sort_ix]
        xlabel = r"Shape Parameter $\delta$"
        if dist_name in ("Chi Dist.", "Lomax Dist."):
            xlim = (1e0, 2e1)
        else:
            xlim = (2e-1, 5e0)
        if dist_name == "Chi Dist.":
            legend_title = dist_name
        else:
            legend_title = (
                dist_name + r", $\tau_0 = %d$" % data[col_dist_params][0]
            )
    else:
        raise ValueError("Unknown value for `sort_by`: {}".format(sort_by))
    shapes = shapes[:, sort_ix]
    data = data[:, sort_ix]
    ####################################################################

    ####################################################################
    # Set axis limits.
    ylims_characs = [(None, None) for i in range(7)]
    ylims_cnt = [(None, None) for i in range(3)]
    ylims_res = (None, None)
    ylims_fit_params = [(None, None) for i in range(3)]
    ylims_fit_goodness = [(None, None) for i in range(2)]
    ylims_fit_region = (None, None)
    if dist_name == "Exp. Dist." and sort_by == "n_cmps":
        ylims_characs = [
            (2e0, 3e2),  # Mean.
            (1e0, 4e2),  # Standard deviation.
            (2e-1, 2e0),  # Coefficient of Variation.
            (2e-1, 4e0),  # Skewness.
            (6e-1, 2e1),  # Excess kurtosis.
            (2e0, 3e2),  # Median.
            (1e-1, 4e-1),  # Non-parametric kurtosis.
        ]
    if dist_name == "Exp. Dist." and sort_by == "n_frames":
        ylims_characs = [
            (8e0, 5e2),  # Mean.
            (9e1, 3e2),  # Standard deviation.
            (5e-1, 2e0),  # Coefficient of Variation.
            (5e-2, 3e0),  # Skewness.
            (4e-1, 2e1),  # Excess kurtosis.
            (8e0, 5e2),  # Median.
            (1e-1, 5e-1),  # Non-parametric kurtosis.
        ]
    if dist_name == "Exp. Dist." and sort_by == "every":
        ylims_characs = [
            (6e1, 9e2),  # Mean.
            (9e1, 7e2),  # Standard deviation.
            (None, None),  # Coefficient of Variation.
            (1e0, 4e0),  # Skewness.
            (5e0, 1e1),  # Excess kurtosis.
            (6e1, 9e2),  # Median.
            (2e-4, 6e-1),  # Non-parametric kurtosis.
        ]
    if dist_name == "Exp. Dist." and sort_by == "tau0_true":
        ylims_characs = [
            (2e1, 5e2),  # Mean.
            (2e1, 5e2),  # Standard deviation.
            (9e-1, 2e0),  # Coefficient of Variation.
            (1e0, 3e0),  # Skewness.
            (5e0, 1e1),  # Excess kurtosis.
            (1e1, 5e2),  # Median.
            (1e-1, 4e-1),  # Non-parametric kurtosis.
        ]
        ylims_res = ylims_characs[0]
    if dist_name == "Gamma Dist." and sort_by == "delta_true":
        ylims_characs = [
            (2e1, 5e2),  # Mean.
            (4e1, 3e2),  # Standard deviation.
            (4e-1, 3e0),  # Coefficient of Variation.
            (9e-1, 5e0),  # Skewness.
            (1e0, 5e1),  # Excess kurtosis.
            (3e0, 5e2),  # Median.
            (1e-1, 5e-1),  # Non-parametric kurtosis.
        ]
        ylims_cnt = [(9e-1, 2e1), (9e2, 3e3), (1e4, 9e4)]
    if dist_name == "Weibull Dist." and sort_by == "beta_true":
        ylims_characs = [
            (2e1, 2e5),  # Mean.
            (2e0, 3e5),  # Standard deviation.
            (2e-1, 4e1),  # Coefficient of Variation.
            (3e-1, 7e1),  # Skewness.
            (1e-1, 2e4),  # Excess kurtosis.
            (2e1, 4e2),  # Median.
            (3e-2, 5e-1),  # Non-parametric kurtosis.
        ]
    if dist_name == "Str. Exp. Dist." and sort_by == "beta_true":
        ylims_characs = [
            (2e1, 6e5),  # Mean.
            (2e1, 4e5),  # Standard deviation.
            (6e-1, 3e0),  # Coefficient of Variation.
            (3e-1, 2e1),  # Skewness.
            (1e-1, 9e2),  # Excess kurtosis.
            (2e1, 7e4),  # Median.
            (9e-2, 6e-1),  # Non-parametric kurtosis.
        ]
    if dist_name == "Chi Dist." and sort_by == "delta_true":
        ylims_characs = [
            (7e-1, 5e0),  # Mean.
            (2e-1, 2e0),  # Standard deviation.
            (1e-1, 8e-1),  # Coefficient of Variation.
            (1e-1, 7e1),  # Skewness.
            (2e-3, 8e0),  # Excess kurtosis.
            (6e-1, 5e0),  # Median.
            (1e-2, 9e-1),  # Non-parametric kurtosis.
        ]
        ylims_cnt = [(8e-2, 1.2e1), (4e0, 1e1), (1e6, 4e6)]
        ylims_fit_region = (1e0, 6e0)
    if dist_name == "Lomax Dist." and sort_by == "delta_true":
        ylims_characs = [
            (5e0, 9e2),  # Mean.
            (5e0, 3e3),  # Standard deviation.
            (9e-1, 2e1),  # Coefficient of Variation.
            (1e0, 6e1),  # Skewness.
            (5e0, 6e3),  # Excess kurtosis.
            (4e0, 2e2),  # Median.
            (5e-2, 4e-1),  # Non-parametric kurtosis.
        ]
    if dist_name == "Log-Logistic Dist." and sort_by == "beta_true":
        ylims_characs = [
            (4e1, 6e2),  # Mean.
            (1e1, 9e2),  # Standard deviation.
            (1e-1, 3e0),  # Coefficient of Variation.
            (1e-1, 2e1),  # Skewness.
            (2e-1, 6e2),  # Excess kurtosis.
            (4e1, 2e2),  # Median.
            (2e-2, 4e-1),  # Non-parametric kurtosis.
        ]
        ylims_cnt = [(8e-1, 6e1), (1e2, 2e4), (1e4, 5e4)]
    ####################################################################

    ####################################################################
    label_true = "True"
    # label_true_cen = "True Cens."
    # label_true_unc = "True Uncen."
    label_cnt_cen = "Cens."  # Count
    label_cnt_unc = "Uncens."  # Count
    label_k = "Rate"
    label_rp_int = "ACF Num"
    label_rp_wbl = "ACF Wbl"
    label_rp_brr = "ACF Burr"
    label_km_int = "KM Num"
    label_km_wbl = "KM Wbl"
    label_km_brr = "KM Burr"

    color_true = "tab:green"
    # color_true_cen = "tab:olive"
    # color_true_unc = "darkolivegreen"
    color_cnt_cen = "tab:orange"
    color_cnt_unc = "tab:red"
    color_k = "tab:brown"
    color_rp_int = "tab:purple"
    color_rp_wbl = "tab:blue"
    color_rp_brr = "tab:cyan"
    color_km_int = "goldenrod"
    color_km_wbl = "gold"
    color_km_brr = "yellow"

    marker_true = "x"
    # marker_true_cen = "P"
    # marker_true_unc = "X"
    marker_cnt_cen = "H"
    marker_cnt_unc = "h"
    marker_k = "p"
    marker_rp_int = "^"
    marker_rp_wbl = ">"
    marker_rp_brr = "<"
    marker_km_int = "s"
    marker_km_wbl = "D"
    marker_km_brr = "d"
    ####################################################################

    alpha = 0.75

    mdt.fh.backup(outfile)
    with PdfPages(outfile) as pdf:
        ################################################################
        # Plot distribution characteristics.
        ylabels = (
            "Average Lifetime / Frames",
            "Std. Dev. / Frames",
            "Coeff. of Variation",
            "Skewness",
            "Excess Kurtosis",
            "Median / Frames",
            "Non-Parametric Skewness",
        )
        for i, ylabel in enumerate(ylabels):
            if i == 0:
                offset_i_cnt = 0
            else:
                offset_i_cnt = 1
            fig, ax = plt.subplots(clear=True)
            # Method 1: Censored counting.
            valid = np.isfinite(data[col_cnt_cen + i + offset_i_cnt])
            if np.any(valid):
                ax.errorbar(
                    xdata[valid],
                    data[col_cnt_cen + i + offset_i_cnt][valid],
                    yerr=data[col_cnt_cen + i + 1][valid] if i == 0 else None,
                    label=label_cnt_cen,
                    color=color_cnt_cen,
                    marker=marker_cnt_cen,
                    alpha=alpha,
                )
            # Method 2: Uncensored counting.
            valid = np.isfinite(data[col_cnt_unc + i + offset_i_cnt])
            if np.any(valid):
                ax.errorbar(
                    xdata[valid],
                    data[col_cnt_unc + i + offset_i_cnt][valid],
                    yerr=data[col_cnt_unc + i + 1][valid] if i == 0 else None,
                    label=label_cnt_unc,
                    color=color_cnt_unc,
                    marker=marker_cnt_unc,
                    alpha=alpha,
                )
            # Method 3: Inverse transition rate.
            if i == 0:
                valid = np.isfinite(data[col_k])
                if np.any(valid):
                    ax.errorbar(
                        xdata[valid],
                        data[col_k][valid],
                        yerr=None,
                        label=label_k,
                        color=color_k,
                        marker=marker_k,
                        alpha=alpha,
                    )
            # Method 7: Numerical integration of the KM estimator.
            valid = np.isfinite(data[col_km_int + i])
            if np.any(valid):
                ax.errorbar(
                    xdata[valid],
                    data[col_km_int + i][valid],
                    yerr=None,
                    label=label_km_int,
                    color=color_km_int,
                    marker=marker_km_int,
                    alpha=alpha,
                )
            # Method 8: Weibull fit of the Kaplan-Meier estimator.
            valid = np.isfinite(data[col_km_wbl + i])
            if np.any(valid):
                ax.errorbar(
                    xdata[valid],
                    data[col_km_wbl + i][valid],
                    yerr=None,
                    label=label_km_wbl,
                    color=color_km_wbl,
                    marker=marker_km_wbl,
                    alpha=alpha,
                )
            # Method 9: Burr Type XII fit of the Kaplan-Meier estimator.
            valid = np.isfinite(data[col_km_brr + i])
            if np.any(valid):
                ax.errorbar(
                    xdata[valid],
                    data[col_km_brr + i][valid],
                    yerr=None,
                    label=label_km_brr,
                    color=color_km_brr,
                    marker=marker_km_brr,
                    alpha=alpha,
                )
            # Method 4: Numerical integration of the remain probability.
            valid = np.isfinite(data[col_rp_int + i])
            if np.any(valid):
                ax.errorbar(
                    xdata[valid],
                    data[col_rp_int + i][valid],
                    yerr=None,
                    label=label_rp_int,
                    color=color_rp_int,
                    marker=marker_rp_int,
                    alpha=alpha,
                )
            # Method 5: Weibull fit of the remain probability.
            valid = np.isfinite(data[col_rp_wbl + i])
            if np.any(valid):
                ax.errorbar(
                    xdata[valid],
                    data[col_rp_wbl + i][valid],
                    yerr=None,
                    label=label_rp_wbl,
                    color=color_rp_wbl,
                    marker=marker_rp_wbl,
                    alpha=alpha,
                )
            # Method 6: Burr Type XII fit of the remain probability.
            valid = np.isfinite(data[col_rp_brr + i])
            if np.any(valid):
                ax.errorbar(
                    xdata[valid],
                    data[col_rp_brr + i][valid],
                    yerr=None,
                    label=label_rp_brr,
                    color=color_rp_brr,
                    marker=marker_rp_brr,
                    alpha=alpha,
                )
            # True lifetime distribution.
            valid = np.isfinite(data[col_dst + i])
            if np.any(valid):
                ax.errorbar(
                    xdata[valid],
                    data[col_dst + i][valid],
                    yerr=None,
                    label=(
                        label_true + r" $\mathrm{E}[T]$"
                        if i == 0
                        else label_true
                    ),
                    color=color_true,
                    marker=marker_true,
                    alpha=alpha,
                )
            # True average residual/remaining lifetime.
            if i == 0:
                ydata = data[col_dst + 7] / (2 * data[col_dst])
                valid = np.isfinite(ydata)
                if np.any(valid):
                    ax.errorbar(
                        xdata[valid],
                        ydata[valid],
                        yerr=None,
                        label=label_true + r" $\mathrm{E}[R]$",
                        color="darkolivegreen",
                        marker="+",
                        alpha=alpha,
                    )
            ax.set_xscale("log", base=10, subs=np.arange(2, 10))
            ax.set(xlabel=xlabel, ylabel=ylabel, xlim=xlim)
            ylim = ax.get_ylim()
            if ylim[0] < 0 and ylabel not in (
                "Skewness",
                "Excess Kurtosis",
                "Non-Parametric Skewness",
            ):
                ax.set_ylim(0, ylim[1])
            legend = ax.legend(
                title=legend_title, ncol=2, **mdtplt.LEGEND_KWARGS_XSMALL
            )
            legend.get_title().set_multialignment("center")
            pdf.savefig()
            # Log scale y.
            ax.relim()
            ax.autoscale()
            ax.set_yscale("log", base=10, subs=np.arange(2, 10))
            ax.set(xlim=xlim, ylim=ylims_characs[i])
            pdf.savefig()
            plt.close()
        ################################################################

        ################################################################
        # Plot average residual/remaining lifetime.
        ylabel = "Avg. Rem. Lifetime / Frames"
        fig, ax = plt.subplots(clear=True)
        # Method 4: Numerical integration of the remain probability.
        valid = np.isfinite(data[col_rp_int])
        if np.any(valid):
            ax.plot(
                xdata[valid],
                data[col_rp_int][valid],
                label=label_rp_int,
                color=color_rp_int,
                marker=marker_rp_int,
                alpha=alpha,
            )
        # Method 5: Weibull fit of the remain probability.
        valid = np.isfinite(data[col_rp_wbl])
        if np.any(valid):
            ax.plot(
                xdata[valid],
                data[col_rp_wbl][valid],
                label=label_rp_wbl,
                color=color_rp_wbl,
                marker=marker_rp_wbl,
                alpha=alpha,
            )
        # Method 6: Burr Type XII fit of the remain probability.
        valid = np.isfinite(data[col_rp_brr])
        if np.any(valid):
            ax.plot(
                xdata[valid],
                data[col_rp_brr][valid],
                label=label_rp_brr,
                color=color_rp_brr,
                marker=marker_rp_brr,
                alpha=alpha,
            )
        # True average residual/remaining lifetime.
        ydata = data[col_dst + 7] / (2 * data[col_dst])
        valid = np.isfinite(ydata)
        if np.any(valid):
            ax.plot(
                xdata[valid],
                ydata[valid],
                label=r"True $\mathrm{E}[T^2] / 2 \mathrm{E}[T]$",
                color=color_true,
                marker=marker_true,
                alpha=alpha,
            )
        # ydata = data[col_dst + 8] / (2 * data[col_dst + 7])
        # valid = np.isfinite(ydata)
        # if np.any(valid):
        #     ax.plot(
        #         xdata[valid],
        #         ydata[valid],
        #         label=r"$\mathrm{E}[T^3] / 2 \mathrm{E}[T^2]$",
        #         color=color_true_unc,
        #         marker=marker_true_unc,
        #         alpha=alpha,
        #     )
        ax.set_xscale("log", base=10, subs=np.arange(2, 10))
        ax.set(xlabel=xlabel, ylabel=ylabel, xlim=xlim)
        ylim = ax.get_ylim()
        if ylim[0] < 0:
            ax.set_ylim(0, ylim[1])
        legend = ax.legend(title=legend_title, **mdtplt.LEGEND_KWARGS_XSMALL)
        legend.get_title().set_multialignment("center")
        pdf.savefig()
        # Log scale y.
        ax.relim()
        ax.autoscale()
        ax.set_yscale("log", base=10, subs=np.arange(2, 10))
        ax.set(xlim=xlim, ylim=ylims_res)
        pdf.savefig()
        plt.close()
        ################################################################

        ################################################################
        # Plot min, max and number of samples for count methods.
        ylabels = (
            "Min. Lifetime / Frames",
            "Max. Lifetime / Frames",
            "No. of Samples",
        )
        for i, ylabel in enumerate(ylabels):
            fig, ax = plt.subplots(clear=True)
            col_cnt_i = len(ylims_characs)
            col_cnt_i += 1  # Uncertainty of the mean.
            col_cnt_i += 3  # 2nd to 3rd raw moment.
            col_cnt_i += i
            # Method 1: Censored counting.
            valid = data[col_cnt_cen + col_cnt_i] > 0
            if np.any(valid):
                ax.plot(
                    xdata[valid],
                    data[col_cnt_cen + col_cnt_i][valid],
                    label=label_cnt_cen,
                    color=color_cnt_cen,
                    marker=marker_cnt_cen,
                    alpha=alpha,
                )
            # Method 2: Uncensored counting.
            valid = data[col_cnt_unc + col_cnt_i] > 0
            if np.any(valid):
                ax.plot(
                    xdata[valid],
                    data[col_cnt_unc + col_cnt_i][valid],
                    label=label_cnt_unc,
                    color=color_cnt_unc,
                    marker=marker_cnt_unc,
                    alpha=alpha,
                )
            ax.set_xscale("log", base=10, subs=np.arange(2, 10))
            ax.set(xlabel=xlabel, ylabel=ylabel, xlim=xlim)
            ylim = ax.get_ylim()
            if ylim[0] < 0:
                ax.set_ylim(0, ylim[1])
            legend = ax.legend(
                title=legend_title, ncol=2, **mdtplt.LEGEND_KWARGS_XSMALL
            )
            legend.get_title().set_multialignment("center")
            pdf.savefig()
            # Log scale y.
            ax.relim()
            ax.autoscale()
            ax.set_yscale("log", base=10, subs=np.arange(2, 10))
            ax.set(xlim=xlim, ylim=ylims_cnt[i])
            pdf.savefig()
            plt.close()
        ################################################################

        ################################################################
        # Plot fit parameters tau0 and beta.
        ylabels = (
            r"Fit Parameter $\tau_0$ / Frames",
            r"Fit Parameter $\beta$",
            r"Fit Parameter $\delta$",
        )
        for i, ylabel in enumerate(ylabels):
            fig, ax = plt.subplots(clear=True)
            if i < 2:
                # Method 5: Weibull fit of the remain probability.
                col_rp_wbl_i = len(ylims_characs)
                col_rp_wbl_i += 3  # 2nd to 3rd raw moment.
                col_rp_wbl_i += 2 * i
                valid = data[col_rp_wbl + col_rp_wbl_i] > 0
                if np.any(valid):
                    ax.errorbar(
                        xdata[valid],
                        data[col_rp_wbl + col_rp_wbl_i][valid],
                        yerr=data[col_rp_wbl + col_rp_wbl_i + 1][valid],
                        label=label_rp_wbl,
                        color=color_rp_wbl,
                        marker=marker_rp_wbl,
                        alpha=alpha,
                    )
            # Method 6: Burr Type XII fit of the remain probability.
            col_rp_brr_i = len(ylims_characs)
            col_rp_brr_i += 3  # 2nd to 3rd raw moment.
            col_rp_brr_i += 2 * i
            valid = data[col_rp_brr + col_rp_brr_i] > 0
            if np.any(valid):
                ax.errorbar(
                    xdata[valid],
                    data[col_rp_brr + col_rp_brr_i][valid],
                    yerr=data[col_rp_brr + col_rp_brr_i + 1][valid],
                    label=label_rp_brr,
                    color=color_rp_brr,
                    marker=marker_rp_brr,
                    alpha=alpha,
                )
            if i < 2:
                # Method 8: Weibull fit of the Kaplan-Meier estimator.
                col_km_wbl_i = len(ylims_characs)
                col_km_wbl_i += 3  # 2nd to 3rd raw moment.
                col_km_wbl_i += 2 * i
                valid = data[col_km_wbl + col_km_wbl_i] > 0
                if np.any(valid):
                    ax.errorbar(
                        xdata[valid],
                        data[col_km_wbl + col_km_wbl_i][valid],
                        yerr=data[col_km_wbl + col_km_wbl_i + 1][valid],
                        label=label_km_wbl,
                        color=color_km_wbl,
                        marker=marker_km_wbl,
                        alpha=alpha,
                    )
            # Method 9: Burr Type XII fit of the Kaplan-Meier estimator.
            col_km_brr_i = len(ylims_characs)
            col_km_brr_i += 3  # 2nd to 3rd raw moment.
            col_km_brr_i += 2 * i
            valid = data[col_km_brr + col_km_brr_i] > 0
            if np.any(valid):
                ax.errorbar(
                    xdata[valid],
                    data[col_km_brr + col_km_brr_i][valid],
                    yerr=data[col_km_brr + col_km_brr_i + 1][valid],
                    label=label_km_brr,
                    color=color_km_brr,
                    marker=marker_km_brr,
                    alpha=alpha,
                )
            # True distribution.
            valid = data[col_dist_params + i] > 0
            if np.any(valid):
                ax.errorbar(
                    xdata[valid],
                    data[col_dist_params + i][valid],
                    yerr=None,
                    label=label_true,
                    color=color_true,
                    marker=marker_true,
                    alpha=alpha,
                )
            ax.set_xscale("log", base=10, subs=np.arange(2, 10))
            ax.set(xlabel=xlabel, ylabel=ylabel, xlim=xlim)
            ylim = ax.get_ylim()
            if ylim[0] < 0:
                ax.set_ylim(0, ylim[1])
            legend = ax.legend(
                title=legend_title, ncol=2, **mdtplt.LEGEND_KWARGS_XSMALL
            )
            legend.get_title().set_multialignment("center")
            pdf.savefig()
            # Log scale y.
            ax.relim()
            ax.autoscale()
            ax.set_yscale("log", base=10, subs=np.arange(2, 10))
            ax.set(xlim=xlim, ylim=ylims_fit_params[i])
            pdf.savefig()
            plt.close()
        ################################################################

        ################################################################
        # Plot goodness of fit quantities.
        ylabels = (r"Coeff. of Determ. $R^2$", "RMSE")
        for i, ylabel in enumerate(ylabels):
            fig, ax = plt.subplots(clear=True)
            # Remain probability to the true survival function.
            col_true_i = len(ylims_characs)
            col_true_i += 3  # 2nd to 3rd raw moment.
            col_true_i += len(ylims_fit_params)
            col_true_i += i
            valid = data[col_dst + col_true_i] > 0
            if np.any(valid):
                ax.plot(
                    xdata[valid],
                    data[col_dst + col_true_i][valid],
                    label="ACF to True",
                    color=color_rp_int,
                    marker=marker_rp_int,
                    alpha=alpha,
                )
            # Method 5: Weibull fit of the remain probability.
            col_rp_wbl_i = len(ylims_characs)
            col_rp_wbl_i += 3  # 2nd to 3rd raw moment.
            col_rp_wbl_i += 2 * (len(ylims_fit_params) - 1)
            col_rp_wbl_i += i
            valid = data[col_rp_wbl + col_rp_wbl_i] > 0
            if np.any(valid):
                ax.plot(
                    xdata[valid],
                    data[col_rp_wbl + col_rp_wbl_i][valid],
                    label=label_rp_wbl,
                    color=color_rp_wbl,
                    marker=marker_rp_wbl,
                    alpha=alpha,
                )
            # Method 6: Burr Type XII fit of the remain probability.
            col_rp_brr_i = len(ylims_characs)
            col_rp_brr_i += 3  # 2nd to 3rd raw moment.
            col_rp_brr_i += 2 * len(ylims_fit_params)
            col_rp_brr_i += i
            valid = data[col_rp_brr + col_rp_brr_i] > 0
            if np.any(valid):
                ax.plot(
                    xdata[valid],
                    data[col_rp_brr + col_rp_brr_i][valid],
                    label=label_rp_brr,
                    color=color_rp_brr,
                    marker=marker_rp_brr,
                    alpha=alpha,
                )
            # Kaplan-Meier estimator to the true survival function.
            col_true_i = len(ylims_characs)
            col_true_i += 3  # 2nd to 3rd raw moment.
            col_true_i += len(ylims_fit_params)
            col_true_i += len(ylims_fit_goodness)  # RP to true SF.
            col_true_i += i
            valid = data[col_dst + col_true_i] > 0
            if np.any(valid):
                ax.plot(
                    xdata[valid],
                    data[col_dst + col_true_i][valid],
                    label="KM to True",
                    color=color_km_int,
                    marker=marker_km_int,
                    alpha=alpha,
                )
            # Method 8: Weibull fit of the Kaplan-Meier estimator.
            col_km_wbl_i = len(ylims_characs)
            col_km_wbl_i += 3  # 2nd to 3rd raw moment.
            col_km_wbl_i += 2 * (len(ylims_fit_params) - 1)
            col_km_wbl_i += i
            valid = data[col_km_wbl + col_km_wbl_i] > 0
            if np.any(valid):
                ax.plot(
                    xdata[valid],
                    data[col_km_wbl + col_km_wbl_i][valid],
                    label=label_km_wbl,
                    color=color_km_wbl,
                    marker=marker_km_wbl,
                    alpha=alpha,
                )
            # Method 9: Burr Type XII fit of the Kaplan-Meier estimator.
            col_km_brr_i = len(ylims_characs)
            col_km_brr_i += 3  # 2nd to 3rd raw moment.
            col_km_brr_i += 2 * len(ylims_fit_params)
            col_km_brr_i += i
            valid = data[col_km_brr + col_km_brr_i] > 0
            if np.any(valid):
                ax.plot(
                    xdata[valid],
                    data[col_km_brr + col_km_brr_i][valid],
                    label=label_km_brr,
                    color=color_km_brr,
                    marker=marker_km_brr,
                    alpha=alpha,
                )
            ax.set_xscale("log", base=10, subs=np.arange(2, 10))
            ax.set(xlabel=xlabel, ylabel=ylabel, xlim=xlim)
            ylim = ax.get_ylim()
            if ylim[0] < 0:
                ax.set_ylim(0, ylim[1])
            legend = ax.legend(
                title=legend_title, ncol=2, **mdtplt.LEGEND_KWARGS_XSMALL
            )
            legend.get_title().set_multialignment("center")
            pdf.savefig()
            # Log scale y.
            ax.relim()
            ax.autoscale()
            ax.set_yscale("log", base=10, subs=np.arange(2, 10))
            ax.set(xlim=xlim, ylim=ylims_fit_goodness[i])
            pdf.savefig()
            plt.close()
        ################################################################

        ################################################################
        # Plot end of fit region.
        ylabel = "End of Fit Region / Frames"
        fig, ax = plt.subplots(clear=True)
        # Fit of remain probability.
        valid = data[col_rp_fit_end] > 0
        if np.any(valid):
            ax.plot(
                xdata[valid],
                data[col_rp_fit_end][valid],
                label="ACF",
                color=color_rp_wbl,
                marker=marker_rp_wbl,
            )
        # Fit of Kaplan-Meier estimator.
        valid = data[col_km_fit_end] > 0
        if np.any(valid):
            ax.plot(
                xdata[valid],
                data[col_km_fit_end][valid],
                label="KM",
                color=color_km_wbl,
                marker=marker_km_wbl,
            )
        ax.set_xscale("log", base=10, subs=np.arange(2, 10))
        ax.set(xlabel=xlabel, ylabel=ylabel, xlim=xlim)
        ylim = ax.get_ylim()
        if ylim[0] < 0:
            ax.set_ylim(0, ylim[1])
        legend = ax.legend(title=legend_title, **mdtplt.LEGEND_KWARGS_XSMALL)
        legend.get_title().set_multialignment("center")
        pdf.savefig()
        # Log scale y.
        ax.relim()
        ax.autoscale()
        ax.set_yscale("log", base=10, subs=np.arange(2, 10))
        ax.set(xlim=xlim, ylim=ylims_fit_region)
        pdf.savefig()
        plt.close()
        ################################################################
    print("Created {}".format(outfile))

    print("\n")
    print("{} done".format(os.path.basename(sys.argv[0])))
