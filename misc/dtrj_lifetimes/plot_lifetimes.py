#!/usr/bin/env python3

# This file is part of MDTools.
# Copyright (C) 2021-2023  The MDTools Development Team and all
# contributors listed in the file AUTHORS.rst
#
# MDTools is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or (at your
# option) any later version.
#
# MDTools is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License
# along with MDTools.  If not, see <http://www.gnu.org/licenses/>.


"""
Plot the lifetimes generated by
:mod:`misc.dtrj_lifetimes.compare_dtrj_lifetime_methods` for a given set
of lifetime distributions.
"""


__author__ = "Andreas Thum"


# Standard libraries
import glob
import os
import sys

# Third-party libraries
import matplotlib.pyplot as plt
import numpy as np
from matplotlib.backends.backend_pdf import PdfPages

# First-party libraries
import mdtools as mdt
import mdtools.plot as mdtplt  # Load MDTools plot style  # noqa: F401


if __name__ == "__main__":  # noqa: C901
    # Input parameters.
    dist_name = "Exp. Dist."
    sort_by = "n_cmps"

    dist = "_gengamma"  # _gengamma, _burr12
    beta = "_beta_1_1"
    delta = "_delta_1_1"
    tau0 = "_tau0_10_100"
    shape = "_shape_*_10"  # n_cmps, n_frames
    discard = "_discard_1000"
    seed = "_seed_5462_4894_3496_8436"
    infile_pattern = (
        "dtrj"
        + dist
        + beta
        + delta
        + tau0
        + shape
        + discard
        + seed
        + "_compare_dtrj_lifetime_methods.txt.gz"
    )
    outfile = infile_pattern.replace(".txt.gz", ".pdf")
    outfile = outfile.replace("*", "N")

    # Column indices for the input file(s).
    col_state = 0
    col_beta_true = 27
    col_delta_true = 28
    col_tau0_true = 29
    # Average lifetimes from the different methods.
    col_count = 1
    col_rate = 3
    col_int = 5
    col_kww = 7
    col_bur = 15
    col_dst = 30
    col_unc = 34
    col_cen = 36

    # Read data.
    infiles = glob.glob(infile_pattern)
    if len(infiles) < 1:
        raise ValueError(
            "The glob pattern does not match anything:"
            " {}".format(infile_pattern)
        )
    shapes = []
    data = []
    for infile in infiles:
        data_file = np.loadtxt(infile, ndmin=2)
        # Only keep the row that contains the data for state 1.
        valid = data_file[:, col_state] == 1
        if not np.any(valid):
            continue
        elif np.count_nonzero(valid) != 1:
            raise ValueError(
                "The input file contains multiple rows with state 1:"
                " '{}'".format(infile)
            )
        data.append(np.squeeze(data_file[valid]))
        shape = infile.split("_shape_")[1].split("_")[:2]
        shapes.append([int(s) for s in shape])
    if len(data) < 1:
        raise ValueError("None of the input files contained data for state 1")
    shapes = np.transpose(np.asarray(shapes))
    data = np.transpose(np.asarray(data))

    # Sort data.
    if sort_by == "n_cmps":
        sort_ix = np.argsort(shapes[0])  # Sort by number of compounds.
        xdata = shapes[0][sort_ix]
        xlim = (5e-1, 2e5)
        xlabel = "Number of Particles"
        legend_title = (
            dist_name + r", $\tau_0 = %.2f$" % data[col_tau0_true][0]
        )
    elif sort_by == "n_frames":
        sort_ix = np.argsort(shapes[1])
        xdata = shapes[1][sort_ix]
        xlim = (5e0, 2e6)
        xlabel = "Number of Frames"
        legend_title = (
            dist_name + r", $\tau_0 = %.2f$" % data[col_tau0_true][0]
        )
    elif sort_by == "beta_true":
        sort_ix = np.argsort(data[col_beta_true])
        xdata = data[col_beta_true][sort_ix]
        xlim = (1e-1, 1e1)
        xlabel = r"Shape Parameter $\beta$"
        legend_title = (
            dist_name + r", $\tau_0 = %.2f$" % data[col_tau0_true][0]
        )
    elif sort_by == "delta_true":
        sort_ix = np.argsort(data[col_delta_true])
        xdata = data[col_delta_true][sort_ix]
        xlim = (1e-1, 1e1)
        xlabel = r"Shape Parameter $\delta$"
        if dist_name == "Chi Dist.":
            legend_title = dist_name
        else:
            legend_title = (
                dist_name + r", $\tau_0 = %.2f$" % data[col_tau0_true][0]
            )
    elif sort_by == "tau0_true":
        sort_ix = np.argsort(data[col_tau0_true])
        xdata = data[col_tau0_true][sort_ix]
        xlim = (1e1, 1e3)
        xlabel = r"Scale Parameter $\tau_0$ / Frames"
        legend_title = dist_name
    else:
        raise ValueError("Unknown value for `sort_by`: {}".format(sort_by))
    shapes = shapes[:, sort_ix]
    data = data[:, sort_ix]

    lts_mom1_min = np.nanmin([data[col_dst], data[col_unc], data[col_cen]])
    lts_mom1_max = np.nanmax([data[col_dst], data[col_unc], data[col_cen]])
    lts_mom2_min = np.nanmin(
        [data[col_dst + 1], data[col_unc + 1], data[col_cen + 1]]
    )
    lts_mom2_max = np.nanmax(
        [data[col_dst + 1], data[col_unc + 1], data[col_cen + 1]]
    )

    label_true = "True"
    label_unc = "Uncen."
    label_cen = "Cens."
    label_count = "Count"
    label_rate = "Rate"
    label_int = "Area"
    label_kww = "Kohl."
    label_bur = "Burr"

    color_true = "tab:green"
    color_unc = "tab:olive"
    color_cen = "darkolivegreen"
    color_count = "tab:orange"
    color_rate = "tab:red"
    color_int = "tab:purple"
    color_kww = "tab:blue"
    color_bur = "tab:cyan"

    marker_true = "s"
    marker_unc = "D"
    marker_cen = "d"
    marker_count = "H"
    marker_rate = "h"
    marker_int = ">"
    marker_kww = "v"
    marker_bur = "^"

    alpha = 0.75

    mdt.fh.backup(outfile)
    with PdfPages(outfile) as pdf:
        # Plot lifetimes.
        fig, ax = plt.subplots(clear=True)
        # True lifetimes (from distribution).
        valid = data[col_dst] > 0
        if np.any(valid):
            ax.plot(
                xdata[valid],
                data[col_dst][valid],
                label=label_true,
                color=color_true,
                marker=marker_true,
                alpha=alpha,
            )
        # Uncensored lifetimes.
        valid = data[col_unc] > 0
        if np.any(valid):
            ax.plot(
                xdata[valid],
                data[col_unc][valid],
                label=label_unc,
                color=color_unc,
                marker=marker_unc,
                alpha=alpha,
            )
        # Censored lifetimes.
        valid = data[col_cen] > 0
        if np.any(valid):
            ax.plot(
                xdata[valid],
                data[col_cen][valid],
                label=label_cen,
                color=color_cen,
                marker=marker_cen,
                alpha=alpha,
            )
        # Method 1 (counting).
        valid = data[col_count] > 0
        if np.any(valid):
            ax.plot(
                xdata[valid],
                data[col_count][valid],
                label=label_count,
                color=color_count,
                marker=marker_count,
                alpha=alpha,
            )
        # Method 2 (inverse transition rate).
        valid = data[col_rate] > 0
        if np.any(valid):
            ax.plot(
                xdata[valid],
                data[col_rate][valid],
                label=label_rate,
                color=color_rate,
                marker=marker_rate,
                alpha=alpha,
            )
        # Method 4 (direct integral).
        valid = data[col_int] > 0
        if np.any(valid):
            ax.plot(
                xdata[valid],
                data[col_int][valid],
                label=label_int,
                color=color_int,
                marker=marker_int,
                alpha=alpha,
            )
        # Method 5 (integral of Kohlrausch fit).
        valid = data[col_kww] > 0
        if np.any(valid):
            ax.plot(
                xdata[valid],
                data[col_kww][valid],
                label=label_kww,
                color=color_kww,
                marker=marker_kww,
                alpha=alpha,
            )
        # Method 6 (integral of Burr fit).
        valid = data[col_bur] > 0
        if np.any(valid):
            ax.plot(
                xdata[valid],
                data[col_bur][valid],
                label=label_bur,
                color=color_bur,
                marker=marker_bur,
                alpha=alpha,
            )
        ax.set_xscale("log", base=10, subs=np.arange(2, 10))
        ax.set_yscale("log", base=10, subs=np.arange(2, 10))
        ylim = list(ax.get_ylim())
        if ylim[0] < lts_mom1_min / 20:
            # Round to 2nd-next lower power of ten.
            ymin = 5 * 10 ** np.floor(np.log10(lts_mom1_min) - 1)
            ylim[0] = ymin if np.isfinite(ymin) else None
        if ylim[1] > lts_mom1_max * 20:
            # Round to next higher power of ten.
            ymax = 2 * 10 ** np.ceil(np.log10(lts_mom1_max))
            ylim[1] = ymax if np.isfinite(ymax) else None
        ax.set(
            xlabel=xlabel,
            ylabel=r"Average Lifetime / Frames",
            xlim=xlim,
            ylim=ylim,
        )
        handles, labels = ax.get_legend_handles_labels()
        legend = ax.legend(
            title=legend_title,
            ncol=max(np.ceil(len(handles) / 2), 1),
            **mdtplt.LEGEND_KWARGS_XSMALL,
        )
        legend.get_title().set_multialignment("center")
        pdf.savefig()
        plt.close()

        # Plot 2nd raw moment of the lifetime distribution.
        fig, ax = plt.subplots(clear=True)
        # True lifetimes (from distribution).
        valid = data[col_dst + 1] > 0
        if np.any(valid):
            ax.plot(
                xdata[valid],
                data[col_dst + 1][valid],
                label=label_true,
                color=color_true,
                marker=marker_true,
                alpha=alpha,
            )
        # Uncensored lifetimes.
        valid = data[col_unc + 1] > 0
        if np.any(valid):
            ax.plot(
                xdata[valid],
                data[col_unc + 1][valid],
                label=label_unc,
                color=color_unc,
                marker=marker_unc,
                alpha=alpha,
            )
        # Censored lifetimes.
        valid = data[col_cen + 1] > 0
        if np.any(valid):
            ax.plot(
                xdata[valid],
                data[col_cen + 1][valid],
                label=label_cen,
                color=color_cen,
                marker=marker_cen,
                alpha=alpha,
            )
        # Method 1 (counting).
        valid = data[col_count + 1] > 0
        if np.any(valid):
            ax.plot(
                xdata[valid],
                data[col_count + 1][valid],
                label=label_count,
                color=color_count,
                marker=marker_count,
                alpha=alpha,
            )
        # Method 4 (direct integral).
        valid = data[col_int + 1] > 0
        if np.any(valid):
            ax.plot(
                xdata[valid],
                data[col_int + 1][valid],
                label=label_int,
                color=color_int,
                marker=marker_int,
                alpha=alpha,
            )
        # Method 5 (integral of Kohlrausch fit).
        valid = data[col_kww + 1] > 0
        if np.any(valid):
            ax.plot(
                xdata[valid],
                data[col_kww + 1][valid],
                label=label_kww,
                color=color_kww,
                marker=marker_kww,
                alpha=alpha,
            )
        # Method 6 (integral of Burr fit).
        valid = data[col_bur + 1] > 0
        if np.any(valid):
            ax.plot(
                xdata[valid],
                data[col_bur + 1][valid],
                label=label_bur,
                color=color_bur,
                marker=marker_bur,
                alpha=alpha,
            )
        ax.set_xscale("log", base=10, subs=np.arange(2, 10))
        ax.set_yscale("log", base=10, subs=np.arange(2, 10))
        ylim = list(ax.get_ylim())
        if ylim[0] < lts_mom2_min / 200:
            # Round to 3rd-next lower power of ten.
            ymin = 5 * 10 ** np.floor(np.log10(lts_mom2_min) - 2)
            ylim[0] = ymin if np.isfinite(ymin) else None
        if ylim[1] > lts_mom2_max * 200:
            # Round to 2nd-next higher power of ten.
            ymax = 2 * 10 ** np.ceil(np.log10(lts_mom2_max) + 1)
            ylim[1] = ymax if np.isfinite(ymax) else None
        ax.set(
            xlabel=xlabel,
            ylabel=r"2$^\mathrm{nd}$ Moment / Frames$^2$",
            xlim=xlim,
            ylim=ylim,
        )
        handles, labels = ax.get_legend_handles_labels()
        legend = ax.legend(
            title=legend_title,
            ncol=max(np.ceil(len(handles) / 2), 1),
            **mdtplt.LEGEND_KWARGS_XSMALL,
        )
        legend.get_title().set_multialignment("center")
        pdf.savefig()
        plt.close()

        # Plot fit parameter tau0.
        fig, ax = plt.subplots(clear=True)
        # True tau0 (from distribution).
        valid = data[col_tau0_true] > 0
        if np.any(valid):
            ax.plot(
                xdata[valid],
                data[col_tau0_true][valid],
                label=label_true,
                color=color_true,
                marker=marker_true,
                alpha=alpha,
            )
        # Method 5 (Kohlrausch fit).
        valid = data[col_kww + 2] > 0
        if np.any(valid):
            ax.errorbar(
                xdata[valid],
                data[col_kww + 2][valid],
                yerr=data[col_kww + 3],
                label=label_kww,
                color=color_kww,
                marker=marker_kww,
                alpha=alpha,
            )
        # Method 6 (Burr fit).
        valid = data[col_bur + 2] > 0
        if np.any(valid):
            ax.errorbar(
                xdata[valid],
                data[col_bur + 2][valid],
                yerr=data[col_bur + 3],
                label=label_bur,
                color=color_bur,
                marker=marker_bur,
                alpha=alpha,
            )
        ax.set_xscale("log", base=10, subs=np.arange(2, 10))
        ax.set_yscale("log", base=10, subs=np.arange(2, 10))
        ax.set(
            xlabel=xlabel, ylabel=r"Fit Parameter $\tau_0$ / Frames", xlim=xlim
        )
        handles, labels = ax.get_legend_handles_labels()
        legend = ax.legend(
            title=legend_title,
            ncol=max(len(handles), 1),
            **mdtplt.LEGEND_KWARGS_XSMALL,
        )
        legend.get_title().set_multialignment("center")
        pdf.savefig()
        plt.close()

        # Plot fit parameter beta.
        fig, ax = plt.subplots(clear=True)
        # True beta (from distribution).
        valid = data[col_beta_true] > 0
        if np.any(valid):
            ax.plot(
                xdata[valid],
                data[col_beta_true][valid],
                label=label_true,
                color=color_true,
                marker=marker_true,
                alpha=alpha,
            )
        # Method 5 (Kohlrausch fit).
        valid = data[col_kww + 4] > 0
        if np.any(valid):
            ax.errorbar(
                xdata[valid],
                data[col_kww + 4][valid],
                yerr=data[col_kww + 5],
                label=label_kww,
                color=color_kww,
                marker=marker_kww,
                alpha=alpha,
            )
        # Method 6 (Burr fit).
        valid = data[col_bur + 4] > 0
        if np.any(valid):
            ax.errorbar(
                xdata[valid],
                data[col_bur + 4][valid],
                yerr=data[col_bur + 5],
                label=label_bur,
                color=color_bur,
                marker=marker_bur,
                alpha=alpha,
            )
        ax.set_xscale("log", base=10, subs=np.arange(2, 10))
        ax.set_yscale("log", base=10, subs=np.arange(2, 10))
        ax.set(xlabel=xlabel, ylabel=r"Fit Parameter $\beta$", xlim=xlim)
        handles, labels = ax.get_legend_handles_labels()
        legend = ax.legend(
            title=legend_title,
            ncol=max(len(handles), 1),
            **mdtplt.LEGEND_KWARGS_XSMALL,
        )
        legend.get_title().set_multialignment("center")
        pdf.savefig()
        plt.close()

        # Plot fit parameter delta.
        fig, ax = plt.subplots(clear=True)
        # True delta (from distribution).
        valid = data[col_delta_true] > 0
        if np.any(valid):
            ax.plot(
                xdata[valid],
                data[col_delta_true][valid],
                label=label_true,
                color=color_true,
                marker=marker_true,
                alpha=alpha,
            )
        # Method 6 (Burr fit).
        valid = data[col_bur + 6] > 0
        if np.any(valid):
            ax.errorbar(
                xdata[valid],
                data[col_bur + 6][valid],
                yerr=data[col_bur + 7],
                label=label_bur,
                color=color_bur,
                marker=marker_bur,
                alpha=alpha,
            )
        ax.set_xscale("log", base=10, subs=np.arange(2, 10))
        ax.set_yscale("log", base=10, subs=np.arange(2, 10))
        ax.set(xlabel=xlabel, ylabel=r"Fit Parameter $\delta$", xlim=xlim)
        handles, labels = ax.get_legend_handles_labels()
        legend = ax.legend(
            title=legend_title,
            ncol=max(len(handles), 1),
            **mdtplt.LEGEND_KWARGS_XSMALL,
        )
        legend.get_title().set_multialignment("center")
        pdf.savefig()
        plt.close()

        # Plot R^2 value of the fits.
        fig, ax = plt.subplots(clear=True)
        # R^2 of the remain probability to the true survival function.
        valid = data[38] > 0
        if np.any(valid):
            ax.plot(
                xdata[valid],
                data[38][valid],
                label="Model",
                color=color_true,
                marker=marker_true,
                alpha=alpha,
            )
        # Method 5 (Kohlrausch fit).
        valid = data[col_kww + 6] > 0
        if np.any(valid):
            ax.plot(
                xdata[valid],
                data[col_kww + 6][valid],
                label=label_kww,
                color=color_kww,
                marker=marker_kww,
                alpha=alpha,
            )
        # Method 6 (Burr fit).
        valid = data[col_bur + 8] > 0
        if np.any(valid):
            ax.plot(
                xdata[valid],
                data[col_bur + 8][valid],
                label=label_bur,
                color=color_bur,
                marker=marker_bur,
                alpha=alpha,
            )
        ax.set_xscale("log", base=10, subs=np.arange(2, 10))
        ax.set(xlabel=xlabel, ylabel=r"Coeff. of Determ. $R^2$", xlim=xlim)
        handles, labels = ax.get_legend_handles_labels()
        legend = ax.legend(
            title=legend_title,
            ncol=max(len(handles), 1),
            **mdtplt.LEGEND_KWARGS_XSMALL,
        )
        legend.get_title().set_multialignment("center")
        pdf.savefig()
        plt.close()

        # Plot root-mean-square error.
        fig, ax = plt.subplots(clear=True)
        # RMSE of the remain probability to the true survival function.
        valid = data[39] > 0
        if np.any(valid):
            ax.plot(
                xdata[valid],
                data[39][valid],
                label="Model",
                color=color_true,
                marker=marker_true,
                alpha=alpha,
            )
        # Method 5 (Kohlrausch fit).
        valid = data[col_kww + 7] > 0
        if np.any(valid):
            ax.plot(
                xdata[valid],
                data[col_kww + 7][valid],
                label=label_kww,
                color=color_kww,
                marker=marker_kww,
                alpha=alpha,
            )
        # Method 6 (Burr fit).
        valid = data[col_bur + 9] > 0
        if np.any(valid):
            ax.plot(
                xdata[valid],
                data[col_bur + 9][valid],
                label=label_bur,
                color=color_bur,
                marker=marker_bur,
                alpha=alpha,
            )
        ax.set_xscale("log", base=10, subs=np.arange(2, 10))
        ax.set_yscale("log", base=10, subs=np.arange(2, 10))
        ax.set(xlabel=xlabel, ylabel=r"RMSE", xlim=xlim)
        handles, labels = ax.get_legend_handles_labels()
        legend = ax.legend(
            title=legend_title,
            ncol=max(len(handles), 1),
            **mdtplt.LEGEND_KWARGS_XSMALL,
        )
        legend.get_title().set_multialignment("center")
        pdf.savefig()
        plt.close()

        # Plot end of fit region.
        fig, ax = plt.subplots(clear=True)
        valid = data[26] > 0
        if np.any(valid):
            ax.plot(xdata[valid], data[26][valid], marker="v")
        ax.set_xscale("log", base=10, subs=np.arange(2, 10))
        ax.set_yscale("log", base=10, subs=np.arange(2, 10))
        ax.set(xlabel=xlabel, ylabel=r"End of Fit Region / Frames", xlim=xlim)
        legend = ax.legend(title=legend_title, **mdtplt.LEGEND_KWARGS_XSMALL)
        legend.get_title().set_multialignment("center")
        pdf.savefig()
        plt.close()

    print("Created {}".format(outfile))

    print("\n")
    print("{} done".format(os.path.basename(sys.argv[0])))
