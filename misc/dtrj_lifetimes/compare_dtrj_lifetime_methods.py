#!/usr/bin/env python3

# This file is part of MDTools.
# Copyright (C) 2021-2023  The MDTools Development Team and all
# contributors listed in the file AUTHORS.rst
#
# MDTools is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or (at your
# option) any later version.
#
# MDTools is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License
# along with MDTools.  If not, see <http://www.gnu.org/licenses/>.


r"""
Compare state lifetimes calculated from a discrete trajectory using
different methods.

Options
-------
--dtrj
    Name of the file containing the discrete trajectory.  The discrete
    trajectory must be stored as :class:`numpy.ndarray` either in a
    binary NumPy |npy_file| or in a (compressed) NumPy |npz_archive|.
    See :func:`mdtools.file_handler.load_dtrj` for more information
    about the requirements for the input file.
--rp
    Name of the file containing the remain probabilities for each state
    as generated by
    :mod:`scripts.discretization.state_lifetime_discrete`.
--param
    File containing the parameters that were used to generate the
    artificial discrete trajectory as created by
    :mod:`misc.dtrj_lifetimes.generate_dtrj.py` (optional).  If
    provided, the true lifetimes are also plotted.
-o
    Output filename pattern.
--int-thresh
    Only calculate the lifetime by directly integrating the remain
    probability if the remain probability decays below the given
    threshold.  Default: ``0.01``.
--end-fit
    End time for fitting the remain probability (in trajectory steps).
    This is inclusive, i.e. the time given here is still included in the
    fit.  If ``None``, the fit ends at 90% of the lag times.  Default:
    ``None``.
--stop-fit
    Stop fitting the remain probability as soon as it falls below the
    given value.  The fitting is stopped by whatever happens earlier:
    \--end-fit or \--stop-fit.  Default: ``0.01``.


See Also
--------
:mod:`misc.dtrj_lifetimes.generate_dtrj` :
    Generate an artificial discrete trajectory with a given number of
    states with a given lifetime distribution
"""


__author__ = "Andreas Thum"


# Standard libraries
import argparse
import os
import sys
from datetime import datetime, timedelta

# Third-party libraries
import matplotlib.pyplot as plt
import numpy as np
import psutil
from matplotlib.backends.backend_pdf import PdfPages
from matplotlib.ticker import MaxNLocator
from scipy.special import gamma

# First-party libraries
import mdtools as mdt
import mdtools.plot as mdtplt  # Load MDTools plot style  # noqa: F401


if __name__ == "__main__":  # noqa: C901
    timer_tot = datetime.now()
    proc = psutil.Process()
    proc.cpu_percent()  # Initiate monitoring of CPU usage.
    parser = argparse.ArgumentParser(
        # The description should only contain the short summary from the
        # docstring and a reference to the documentation.
        description=(
            "Compare state lifetimes calculated from a discrete trajectory"
            " using different methods"
        )
    )
    parser.add_argument(
        "--dtrj",
        dest="INFILE_DTRJ",
        type=str,
        required=True,
        help=(
            "File containing the discrete trajectory stored as numpy.ndarray"
            " in the binary .npy format or as .npz archive."
        ),
    )
    parser.add_argument(
        "--rp",
        dest="INFILE_RP",
        type=str,
        required=True,
        help=(
            "Name of the file containing the remain probabilities for each"
            " state."
        ),
    )
    parser.add_argument(
        "--param",
        dest="INFILE_PARAM",
        type=str,
        required=False,
        default=None,
        help=(
            "File containing the parameters that were used to generate the"
            " artificial discrete trajectory (optional)."
        ),
    )
    parser.add_argument(
        "-o",
        dest="OUTFILE",
        type=str,
        required=True,
        help="Output filename pattern.",
    )
    parser.add_argument(
        "--int-thresh",
        dest="INT_THRESH",
        type=float,
        required=False,
        default=0.01,
        help=(
            "Only calculate the lifetime by directly integrating the remain"
            " probability if the remain probability decays below the given"
            " threshold.  Default:  %(default)s."
        ),
    )
    parser.add_argument(
        "--end-fit",
        dest="ENDFIT",
        type=float,
        required=False,
        default=None,
        help=(
            "End time for fitting the remain probability in trajectory"
            " steps (inclusive).  If None, the fit ends at 90%% of the"
            " lag times.  Default: %(default)s."
        ),
    )
    parser.add_argument(
        "--stop-fit",
        dest="STOPFIT",
        type=float,
        required=False,
        default=0.01,
        help=(
            "Stop fitting the remain probability as soon as it falls below the"
            " given value.  The fitting is stopped by whatever happens"
            " earlier: --end-fit or --stop-fit.  Default: %(default)s"
        ),
    )
    args = parser.parse_args()
    print(mdt.rti.run_time_info_str())

    # Conversion factor to convert "trajectory steps" to some physical
    # time unit (e.g. ns).
    time_conv = 1

    print("\n")
    print("Calculating lifetimes directly from `dtrj` (Methods 1-2)...")
    timer = datetime.now()
    dtrj = mdt.fh.load_dtrj(args.INFILE_DTRJ)
    n_frames = dtrj.shape[1]

    # Method 1: Calculate the average lifetime by counting the number of
    # frames that a given compound stays in a given state.
    lts_cnt, states_cnt = mdt.dtrj.lifetimes_per_state(
        dtrj, return_states=True
    )
    lts_cnt = [lts * time_conv for lts in lts_cnt]
    lts_cnt_mom1 = np.array([np.mean(lts) for lts in lts_cnt])
    lts_cnt_mom2 = np.array([np.mean(lts**2) for lts in lts_cnt])
    del lts_cnt

    # Method 2: Calculate the transition rate as the number of
    # transitions leading out of a given state divided by the number of
    # frames that compounds have spent in this state.  The average
    # lifetime is calculated as the inverse transition rate.
    rates, states_k = mdt.dtrj.trans_rate_per_state(dtrj, return_states=True)
    lts_k = time_conv / rates
    if not np.array_equal(states_k, states_cnt):
        raise ValueError(
            "`states_k` ({}) != `states_cnt` ({})".format(states_k, states_cnt)
        )
    del dtrj, rates, states_k
    print("Elapsed time:         {}".format(datetime.now() - timer))
    print("Current memory usage: {:.2f} MiB".format(mdt.rti.mem_usage(proc)))

    print("\n")
    print("Calculating lifetimes from the remain probability (Methods 3-5)...")
    timer = datetime.now()

    # Read remain probabilities from file.
    remain_props = np.loadtxt(args.INFILE_RP)
    states = remain_props[0, 1:]  # State indices.
    times = remain_props[1:, 0]  # Lag times in trajectory steps.
    remain_props = remain_props[1:, 1:]  # Remain probability functions.
    if np.any(remain_props < 0) or np.any(remain_props > 1):
        raise ValueError(
            "Some values of the remain probability lie outside the interval"
            " [0, 1]"
        )
    if not np.array_equal(times, np.arange(n_frames)):
        raise ValueError("`times` != `np.arange(n_frames)`")
    times *= time_conv  # Lag times in the given physical time unit.
    if np.any(np.modf(states)[0] != 0):
        raise ValueError(
            "Some state indices are not integers but floats.  states ="
            " {}".format(states)
        )
    if not np.array_equal(states, states_cnt):
        raise ValueError(
            "`states` ({}) != `states_cnt` ({})".format(states, states_cnt)
        )
    del states_cnt
    states = states.astype(np.int32)
    n_states = len(states)

    # Method 3: Set the lifetime to the lag time at which the remain
    # probability crosses 1/e.
    thresh = 1 / np.e
    ix_thresh = np.nanargmax(remain_props <= thresh, axis=0)
    lts_e = np.full(n_states, np.nan, dtype=np.float64)
    for i, rp in enumerate(remain_props.T):
        if rp[ix_thresh[i]] > thresh:
            # The remain probability never falls below the threshold.
            lts_e[i] = np.nan
        elif ix_thresh[i] < 1:
            # The remain probability immediately falls below the
            # threshold.
            lts_e[i] = 0
        elif rp[ix_thresh[i] - 1] < thresh:
            raise ValueError(
                "The threshold ({}) does not lie within the remain probability"
                " interval ([{}, {}]) at the found indices ({}, {}).  This"
                " should not have happened.".format(
                    thresh,
                    rp[ix_thresh[i]],
                    rp[ix_thresh[i] - 1],
                    ix_thresh[i],
                    ix_thresh[i] - 1,
                )
            )
        else:
            slope = rp[ix_thresh[i]] - rp[ix_thresh[i] - 1]
            slope /= times[ix_thresh[i]] - times[ix_thresh[i] - 1]
            intercept = rp[ix_thresh[i]] - slope * times[ix_thresh[i]]
            lts_e[i] = (thresh - intercept) / slope
            if (
                times[ix_thresh[i] - 1] > lts_e[i]
                or times[ix_thresh[i]] < lts_e[i]
            ):
                raise ValueError(
                    "The lifetime ({}) does not lie within the time interval"
                    " ([{}, {}]) at the found indices ({}, {}).  This should"
                    " not have happened.".format(
                        lts_e[i],
                        times[ix_thresh[i] - 1],
                        times[ix_thresh[i]],
                        ix_thresh[i] - 1,
                        ix_thresh[i],
                    )
                )

    # Method 4: Calculate the lifetime as the integral of the remain
    # probability:
    #   <t^n> = n * int_0^inf t^(n-1) * `rp` dt
    lts_int_mom1 = np.full(n_states, np.nan, dtype=np.float64)
    lts_int_mom2 = np.full(n_states, np.nan, dtype=np.float64)
    for i, rp in enumerate(remain_props.T):
        valid = ~np.isnan(rp)
        lts_int_mom1[i] = np.trapz(y=rp[valid], x=times[valid])
        lts_int_mom2[i] = np.trapz(y=rp[valid] * times[valid], x=times[valid])
        lts_int_mom2[i] *= 2
    invalid = np.all(remain_props > args.INT_THRESH, axis=0)
    lts_int_mom1[invalid] = np.nan
    lts_int_mom2[invalid] = np.nan
    del valid, invalid

    # Method 5: Fit the remain probability with a Kohlrausch function
    # (stretched exponential) and calculate the lifetime as the integral
    # of the fit:
    #   f(t) = exp[-(t/tau0_kww)^beta_kww]
    #   <t^n> = n * int_0^inf t^(n-1) * f(t) dt
    #         = tau0_kww^n * Gamma(1 + n/beta_kww)
    if args.ENDFIT is None:
        end_fit = int(0.9 * len(times))
    else:
        _, end_fit = mdt.nph.find_nearest(
            times, args.ENDFIT, return_index=True
        )
    end_fit += 1  # Make `end_fit` inclusive.
    fit_start = np.zeros(n_states, dtype=np.uint32)  # Inclusive.
    fit_stop = np.zeros(n_states, dtype=np.uint32)  # Exclusive.
    for i, rp in enumerate(remain_props.T):
        stop_fit = np.nanargmax(rp < args.STOPFIT)
        if stop_fit == 0 and rp[stop_fit] >= args.STOPFIT:
            # The remain probability never falls below `args.STOPFIT`.
            stop_fit = len(rp)
        elif stop_fit < 2:
            # The remain probability immediately falls below
            # `args.STOPFIT`.
            stop_fit = 2
        fit_stop[i] = min(end_fit, stop_fit)

    # Initial guesses for `tau0_kww` and `beta_kww`.
    init_guess_kww = np.column_stack([lts_e, np.ones(n_states)])
    invalid = np.isnan(init_guess_kww)
    init_guess_kww[invalid] = 1 + remain_props[end_fit][invalid] - 1 / np.e
    init_guess_kww[invalid] *= times[end_fit]
    del invalid
    # Bounds for `tau0_kww` and `beta_kww`.
    bounds_kww = ([0, 0], [np.inf, 10])

    popt_kww = np.full((n_states, 2), np.nan, dtype=np.float64)
    perr_kww = np.full((n_states, 2), np.nan, dtype=np.float64)
    fit_r2_kww = np.full(n_states, np.nan, dtype=np.float64)
    fit_mse_kww = np.full(n_states, np.nan, dtype=np.float64)
    for i, rp in enumerate(remain_props.T):
        times_fit = times[fit_start[i] : fit_stop[i]]
        rp_fit = rp[fit_start[i] : fit_stop[i]]
        popt_kww[i], perr_kww[i] = mdt.func.fit_kww(
            xdata=times_fit,
            ydata=rp_fit,
            p0=init_guess_kww[i],
            bounds=bounds_kww,
            method="trf",
        )
        if np.any(np.isnan(popt_kww[i])):
            fit_mse_kww[i] = np.nan
            fit_r2_kww[i] = np.nan
        else:
            fit = mdt.func.kww(times_fit, *popt_kww[i])
            # Residual sum of squares.
            ss_res = np.nansum((rp_fit - fit) ** 2)
            # Mean squared error / mean squared residuals.
            fit_mse_kww[i] = ss_res / len(fit)
            # Total sum of squares.
            ss_tot = np.nansum((rp_fit - np.nanmean(rp_fit)) ** 2)
            # (Pseudo) coefficient of determination (R^2).
            # https://www.r-bloggers.com/2021/03/the-r-squared-and-nonlinear-regression-a-difficult-marriage/
            fit_r2_kww[i] = 1 - (ss_res / ss_tot)
    tau0_kww, beta_kww = popt_kww.T
    tau0_kww_sd, beta_kww_sd = perr_kww.T
    lts_kww_mom1 = tau0_kww * gamma(1 + 1 / beta_kww)
    lts_kww_mom2 = tau0_kww**2 * gamma(1 + 2 / beta_kww)
    print("Elapsed time:         {}".format(datetime.now() - timer))
    print("Current memory usage: {:.2f} MiB".format(mdt.rti.mem_usage(proc)))

    if args.INFILE_PARAM is not None:
        print("\n")
        print("Reading true lifetimes from parameters file...")
        params = np.loadtxt(args.INFILE_PARAM, unpack=True)
        states_true = params[0]
        if not np.all(np.isin(states, states_true)):
            raise ValueError(
                "`states` ({}) is not fully contained in `states_true`"
                " ({})".format(states, states_true)
            )
        del states_true
        params = params[:, states]
        # Parameters of the true lifetime distribution.
        beta_true, delta_true, tau0_true = params[1:4]
        # Moments of the true lifetime distribution.
        lts_dst_mom1, lts_dst_mom2 = params[4:6]
        # Moments of the drawn lifetimes.
        lts_drw_mom1, lts_drw_mom2 = params[6:8]
        # Moments of the uncensored lifetimes.
        lts_unc_mom1, lts_unc_mom2 = params[8:10]
        # Moments of the censored lifetimes.
        lts_cen_mom1, lts_cen_mom2 = params[10:12]

    print("\n")
    print("Creating text output...")
    timer = datetime.now()
    header = (
        "State lifetimes.\n"
        + "Average time that a given compound stays in a given state\n"
        + "calculated either directly from the discrete trajectory\n"
        + "(Method 1-2) or from the corresponding remain probability\n"
        + "function (Method 3-5). \n"
        + "\n"
        + "\n"
        + "Discrete trajectory: {:s}\n".format(args.INFILE_DTRJ)
        + "Remain probability:  {:s}\n".format(args.INFILE_RP)
    )
    if args.INFILE_PARAM is not None:
        header += (
            "Parameter file:      {:s}\n".format(args.INFILE_PARAM)
            + "\n"
            + "\n"
        )
    header += (
        "Lifetimes are calculated using five different methods:\n"
        + "\n"
        + "1) The average lifetime <t_cnt> is calculated by counting how\n"
        + "   many frames a given compound stays in a given state.  Note\n"
        + "   lifetimes calculated in this way can at maximum be as long as\n"
        + "   the trajectory and are usually biased to lower values because\n"
        + "   of edge effects.\n"
        + "\n"
        + "2) The average transition rate <k> is calculated as the number of\n"
        + "   transitions leading out of a given state divided by the number\n"
        + "   frames that compounds have spent in this state.  The average\n"
        + "   lifetime <t_k> is calculated as the inverse transition rate:\n"
        + "     <t_k> = 1 / <k>\n"
        + "\n"
        + "3) The average lifetime <t_e> is set to the lag time at which the\n"
        + "   remain probability function p(t) crosses 1/e.  If this never\n"
        + "   happens, <t_e> is set to NaN.\n"
        + "\n"
        + "4) The remain probability function p(t) is interpreted as the\n"
        + "   survival function of the underlying lifetime distribution.\n"
        + "   Thus, the lifetime can be calculated according to the\n"
        + "   alternative expectation formula [1]:\n"
        + "     <t_int^n> = n * int_0^inf t^(n-1) p(t) dt\n"
        + "   If p(t) does not decay below the given threshold of\n"
        + "   {:.4f}, <t_int^n> is set to NaN.\n".format(args.INT_THRESH)
        + "\n"
        + "5) The remain probability function p(t) is fitted by a Kohlrausch\n"
        + "   function (stretched exponential) using the 'Trust Region\n"
        + "   Reflective' method of scipy.optimize.curve_fit:\n"
        + "     I(t) = exp[-(t/tau0_kww)^beta_kww]\n"
        + "   Thereby, tau0_kww and beta_kww are confined to positive\n"
        + "   values.  The remain probability is fitted until it decays\n"
        + "   below a given threshold or until a given lag time is reached\n"
        + "   (whatever happens earlier).  The average lifetime <t_kww^n> is\n"
        + "   calculated according to the alternative expectation\n"
        + "   formula [1]:\n"
        + "     <t_kww^n> = n * int_0^inf t^(n-1) I(t) dt\n"
        + "               = tau0_kww^n * Gamma(1 + n/beta_kww)\n"
        + "   where Gamma(z) is the gamma function.\n"
        + "\n"
        + "Reference [1]:\n"
        + "  S. Chakraborti, F. Jardim, E. Epprecht,\n"
        + "  Higher-order moments using the survival function: The\n"
        + "  alternative expectation formula,\n"
        + "  The American Statistician, 2019, 73, 2, 191-194."
        + "\n"
        + "int_thresh = {:.4f}\n".format(args.INT_THRESH)
        + "\n"
        + "\n"
        + "The columns contain:\n"
        + "  1 State index (zero-based)\n"
        + "\n"
        + "  Lifetime from Method 1 (counting)\n"
        + "  2 1st moment <t_cnt> / frames\n"
        + "  3 2nd moment <t_cnt^2> / frames^2\n"
        + "\n"
        + "  Lifetime from Method 2 (inverse transition rate)\n"
        + "  4 <t_k> / frames\n"
        + "\n"
        + "  Lifetime from Method 3 (1/e criterion)\n"
        + "  5 <t_e> / frames\n"
        + "\n"
        + "  Lifetime from Method 4 (direct integral)\n"
        + "  6 1st moment <t_int> / frames\n"
        + "  7 2nd moment <t_int^2> / frames^2\n"
        + "\n"
        + "  Lifetime from Method 5 (integral of Kohlrausch fit)\n"
        + "  8 Start of fit region (inclusive) / frames\n"
        + "  9 End of fit region (exclusive) / frames\n"
        + " 10 1st moment <t_kww> / frames\n"
        + " 11 2nd moment <t_kww^2> / frames^2\n"
        + " 12 Fit parameter tau0_kww / frames\n"
        + " 13 Standard deviation of tau0_kww / frames\n"
        + " 14 Fit parameter beta_kww\n"
        + " 15 Standard deviation of beta_kww\n"
        + " 16 Coefficient of determination of the fit (R^2 value)\n"
        + " 17 Mean squared error of the fit (mean squared residuals) /"
        + " frames^2\n"
    )
    if args.INFILE_PARAM is not None:
        n_cols = 28
        header += (
            "\n"
            + "  True state lifetimes\n"
            + " 18 Shape parameter beta of the true distribution\n"
            + " 19 Shape parameter delta of the true distribution\n"
            + " 20 Scale parameter tau0 of the true distribution\n"
            + " 21 1st moment of the true distribution <t_dst> / frames\n"
            + " 22 2nd moment of the true distribution <t_dst^2> / frames^2\n"
            + " 23 1st moment of the drawn lifetimes <t_drw> / frames\n"
            + " 24 2nd moment of the drawn lifetimes <t_drw^2> / frames^2\n"
            + " 25 1st moment of the uncensored lifetimes <t_unc> / frames\n"
            + " 26 2nd moment of the uncensored lifetimes <t_unc^2> /"
            + " frames^2\n"
            + " 27 1st moment of the censored lifetimes <t_cen> / frames\n"
            + " 28 2nd moment of the censored lifetimes <t_cen^2> / frames^2\n"
        )
    else:
        n_cols = 17
    header += "\n" + "Column number:\n"
    header += "{:>14d}".format(1)
    for i in range(2, n_cols + 1):
        header += " {:>16d}".format(i)
    data = [
        states,  # 1
        #
        lts_cnt_mom1,  # 2
        lts_cnt_mom2,  # 3
        #
        lts_k,  # 4
        #
        lts_e,  # 5
        #
        lts_int_mom1,  # 6
        lts_int_mom2,  # 7
        #
        fit_start,  # 8
        fit_stop,  # 9
        lts_kww_mom1,  # 10
        lts_kww_mom2,  # 11
        tau0_kww,  # 12
        tau0_kww_sd,  # 13
        beta_kww,  # 14
        beta_kww_sd,  # 15
        fit_r2_kww,  # 16
        fit_mse_kww,  # 17
    ]
    if args.INFILE_PARAM is not None:
        data += params[1:12].tolist()
    data = np.column_stack(data)
    outfile = args.OUTFILE + ".txt"
    mdt.fh.savetxt(outfile, data, header=header)
    print("Created {}".format(outfile))
    print("Elapsed time:         {}".format(datetime.now() - timer))
    print("Current memory usage: {:.2f} MiB".format(mdt.rti.mem_usage(proc)))

    print("\n")
    print("Creating plot(s)...")
    timer = datetime.now()
    xlabel = r"State Index"
    xlim = (np.min(states) - 0.5, np.max(states) + 0.5)
    alpha = 0.75
    lt_min = np.nanmin(
        [
            lts_cnt_mom1,
            lts_k,
            lts_e,
            lts_int_mom1,
            lts_kww_mom1,
        ]
    )
    tau0_min = np.nanmin(tau0_kww)
    beta_min = np.nanmin(beta_kww)
    if args.INFILE_PARAM is not None:
        lt_min = np.nanmin([lt_min, np.nanmin(lts_true_mom1)])
        tau0_min = np.nanmin([tau0_min, np.nanmin(tau0_true)])
        beta_min = np.nanmin([beta_min, np.nanmin(beta_true)])
    cmap = plt.get_cmap()
    c_vals = np.arange(n_states)
    c_norm = n_states - 1
    c_vals_normed = c_vals / c_norm
    colors = cmap(c_vals_normed)
    outfile = args.OUTFILE + ".pdf"
    mdt.fh.backup(outfile)
    with PdfPages(outfile) as pdf:
        # Plot lifetimes vs. state indices.
        fig, ax = plt.subplots(clear=True)
        # Method 5 (integral of the fit).
        ax.errorbar(
            states,
            lts_kww_mom1,
            yerr=np.sqrt(lts_kww_mom2 - lts_kww_mom1**2),
            label="Fit",
            color="tab:cyan",
            marker="D",
            alpha=alpha,
        )
        # Method 4 (direct integral)
        ax.errorbar(
            states,
            lts_int_mom1,
            yerr=np.sqrt(lts_int_mom2 - lts_int_mom1**2),
            label="Area",
            color="tab:blue",
            marker="d",
            alpha=alpha,
        )
        # Method 3 (1/e criterion).
        ax.plot(
            states,
            lts_e,
            label=r"$1/e$",
            color="tab:purple",
            marker="s",
            alpha=alpha,
        )
        # Method 2 (inverse transition rate).
        ax.plot(
            states,
            lts_k,
            label="Rate",
            color="tab:red",
            marker="h",
            alpha=alpha,
        )
        # Method 1 (counting).
        ax.errorbar(
            states,
            lts_cnt_mom1,
            yerr=np.sqrt(lts_cnt_mom2 - lts_cnt_mom1**2),
            label="Count",
            color="tab:orange",
            marker="H",
            alpha=alpha,
        )
        if args.INFILE_PARAM is not None:
            # True lifetimes.
            ax.errorbar(
                states,
                lts_true_mom1,
                yerr=np.sqrt(lts_true_mom2 - lts_true_mom1**2),
                label="True",
                color="tab:green",
                marker="o",
                alpha=alpha,
            )
        ax.set(
            xlabel=xlabel,
            ylabel=r"Average Lifetime / Frames",
            xlim=xlim,
        )
        ylim = ax.get_ylim()
        if ylim[0] < 0:
            ax.set_ylim(0, ylim[1])
        ax.xaxis.set_major_locator(MaxNLocator(integer=True))
        # Sort legend entries.  By default, lines plotted with `ax.plot`
        # come before lines plotted with `ax.errorbar`.
        handles, labels = ax.get_legend_handles_labels()
        legend_order = (2, 3, 0, 1, 4)
        if args.INFILE_PARAM is not None:
            legend_order += (5,)
        handles = [handles[leg_ord] for leg_ord in legend_order]
        labels = [labels[leg_ord] for leg_ord in legend_order]
        legend = ax.legend(
            handles, labels, ncol=2, **mdtplt.LEGEND_KWARGS_XSMALL
        )
        legend.get_title().set_multialignment("center")
        pdf.savefig()
        # Set y axis to log scale (lifetimes vs. state indices).
        # Round y limits to next lower and higher power of ten.
        ylim = ax.get_ylim()
        ymin = 10 ** np.floor(np.log10(lt_min))
        ymax = 10 ** np.ceil(np.log10(ylim[1]))
        ax.set_ylim(ymin if not np.isnan(ymin) else None, ymax)
        ax.set_yscale("log", base=10, subs=np.arange(2, 10))
        pdf.savefig()
        plt.close()

        # Plot fitted region.
        fig, ax = plt.subplots(clear=True)
        ax.plot(states, fit_start, label="Start", marker="^")
        ax.plot(states, fit_stop, label="End", marker="v")
        ax.set(xlabel=xlabel, ylabel="Fitted Region / Frames", xlim=xlim)
        ax.xaxis.set_major_locator(MaxNLocator(integer=True))
        legend = ax.legend(ncol=2)
        pdf.savefig()
        plt.close()

        # Plot scale parameter tau0.
        fig, ax = plt.subplots(clear=True)
        ax.errorbar(
            states,
            tau0_kww,
            yerr=tau0_kww_sd,
            label="Fit",
            color="tab:cyan",
            marker="D",
        )
        if args.INFILE_PARAM is not None:
            ax.plot(
                states, tau0_true, label="True", color="tab:green", marker="o"
            )
        ax.set(
            xlabel=xlabel,
            ylabel=r"Scale Parameter $\tau_0$ / Frames",
            xlim=xlim,
        )
        ax.xaxis.set_major_locator(MaxNLocator(integer=True))
        pdf.savefig()
        # Set y axis to log scale (scale parameter tau0).
        # Round y limits to next lower and higher power of ten.
        ylim = ax.get_ylim()
        ymin = 10 ** np.floor(np.log10(tau0_min))
        ymax = 10 ** np.ceil(np.log10(ylim[1]))
        ax.set_ylim(ymin if not np.isnan(ymin) else None, ymax)
        ax.set_yscale("log", base=10, subs=np.arange(2, 10))
        pdf.savefig()
        plt.close()

        # Plot shape parameter beta.
        fig, ax = plt.subplots(clear=True)
        ax.errorbar(
            states,
            beta_kww,
            yerr=beta_kww_sd,
            label="Fit",
            color="tab:cyan",
            marker="D",
        )
        if args.INFILE_PARAM is not None:
            ax.plot(
                states, beta_true, label="True", color="tab:green", marker="o"
            )
        ax.set(
            xlabel=xlabel,
            ylabel=r"Shape Parameter $\beta$",
            xlim=xlim,
            ylim=(0, 1.05),
        )
        ax.xaxis.set_major_locator(MaxNLocator(integer=True))
        pdf.savefig()
        # Set y axis to log scale (shape parameter beta).
        # Round y limits to next lower and higher power of ten.
        ylim = ax.get_ylim()
        ymin = 10 ** np.floor(np.log10(beta_min))
        ymax = 10 ** np.ceil(np.log10(ylim[1]))
        ax.set_ylim(ymin if not np.isnan(ymin) else None, ymax)
        ax.set_yscale("log", base=10, subs=np.arange(2, 10))
        pdf.savefig()
        plt.close()

        # Plot R^2 value of the fits.
        fig, ax = plt.subplots(clear=True)
        ax.plot(states, fit_r2_kww, marker="o")
        ax.set(
            xlabel=xlabel,
            ylabel=r"Coeff. of Determ. $R^2$",
            xlim=xlim,
            ylim=(0, 1.05),
        )
        ax.xaxis.set_major_locator(MaxNLocator(integer=True))
        pdf.savefig()
        plt.close()

        # Plot mean squared error.
        fig, ax = plt.subplots(clear=True)
        ax.plot(states, fit_mse_kww, marker="o")
        ax.set(xlabel=xlabel, ylabel=r"MSE / Frames$^2$", xlim=xlim)
        ax.xaxis.set_major_locator(MaxNLocator(integer=True))
        pdf.savefig()
        if not np.all(np.isnan(fit_mse_kww)):
            # Set y axis to log scale (mean squared error).
            # Round y limits to next lower and higher power of ten.
            ylim = ax.get_ylim()
            ymin = 10 ** np.floor(
                np.log10(np.nanmin(fit_mse_kww[fit_mse_kww > 0]))
            )
            ymax = 10 ** np.ceil(np.log10(ylim[1]))
            ax.set_ylim(ymin if not np.isnan(ymin) else None, ymax)
            ax.set_yscale("log", base=10, subs=np.arange(2, 10))
            pdf.savefig()
        plt.close()

        # Plot remain probabilities and fits for each state.
        fig, ax = plt.subplots(clear=True)
        ax.set_prop_cycle(color=colors)
        for i, rp in enumerate(remain_props.T):
            times_fit = times[fit_start[i] : fit_stop[i]]
            fit = mdt.func.kww(times_fit, *popt_kww[i])
            lines = ax.plot(times, rp, label=r"$%d$" % states[i], linewidth=1)
            ax.plot(
                times_fit, fit, linestyle="dashed", color=lines[0].get_color()
            )
        ax.set(
            xlabel="Lag Time / Frames",
            ylabel="Decay Law",
            xlim=(times[1], times[-1]),
            ylim=(0, 1),
        )
        ax.set_xscale("log", base=10, subs=np.arange(2, 10))
        legend = ax.legend(
            title="State Index",
            loc="upper right",
            ncol=3,
            **mdtplt.LEGEND_KWARGS_XSMALL,
        )
        legend.get_title().set_multialignment("center")
        pdf.savefig()
        plt.close()

        # Plot fit residuals for each state.
        fig, ax = plt.subplots(clear=True)
        ax.set_prop_cycle(color=colors)
        for i, rp in enumerate(remain_props.T):
            times_fit = times[fit_start[i] : fit_stop[i]]
            fit = mdt.func.kww(times_fit, *popt_kww[i])
            res = rp[fit_start[i] : fit_stop[i]] - fit
            ax.plot(times_fit, res, label=r"$%d$" % states[i])
        ax.set(
            xlabel="Lag Time / Frames",
            ylabel="Fit Residuals",
            xlim=(times[1], times[-1]),
        )
        ax.set_xscale("log", base=10, subs=np.arange(2, 10))
        legend = ax.legend(
            title="State Index",
            loc="lower right",
            ncol=3,
            **mdtplt.LEGEND_KWARGS_XSMALL,
        )
        legend.get_title().set_multialignment("center")
        pdf.savefig()
        plt.close()
    print("Created {}".format(outfile))
    print("Elapsed time:         {}".format(datetime.now() - timer))
    print("Current memory usage: {:.2f} MiB".format(mdt.rti.mem_usage(proc)))

    print("\n")
    print("{} done".format(os.path.basename(sys.argv[0])))
    print("Totally elapsed time: {}".format(datetime.now() - timer_tot))
    _cpu_time = timedelta(seconds=sum(proc.cpu_times()[:4]))
    print("CPU time:             {}".format(_cpu_time))
    print("CPU usage:            {:.2f} %".format(proc.cpu_percent()))
    print("Current memory usage: {:.2f} MiB".format(mdt.rti.mem_usage(proc)))
