#!/usr/bin/env python3

# This file is part of MDTools.
# Copyright (C) 2021-2023  The MDTools Development Team and all
# contributors listed in the file AUTHORS.rst
#
# MDTools is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or (at your
# option) any later version.
#
# MDTools is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License
# along with MDTools.  If not, see <http://www.gnu.org/licenses/>.


r"""
Compare state lifetimes calculated from a discrete trajectory using
different methods.

Options
-------
--dtrj
    Name of the file containing the discrete trajectory.  The discrete
    trajectory must be stored as :class:`numpy.ndarray` either in a
    binary NumPy |npy_file| or in a (compressed) NumPy |npz_archive|.
    See :func:`mdtools.file_handler.load_dtrj` for more information
    about the requirements for the input file.
--rp
    Name of the file containing the remain probabilities for each state
    as generated by
    :mod:`scripts.discretization.state_lifetime_discrete`.
--param
    File containing the parameters that were used to generate the
    artificial discrete trajectory as created by
    :mod:`misc.dtrj_lifetimes.generate_dtrj.py` (optional).  If
    provided, the true lifetimes are also plotted.
-o
    Output filename pattern.
--int-thresh
    Only calculate the lifetime by directly integrating the remain
    probability if the remain probability decays below the given
    threshold.  Default: ``0.01``.
--end-fit
    End time for fitting the remain probability (in trajectory steps).
    This is inclusive, i.e. the time given here is still included in the
    fit.  If ``None``, the fit ends at 90% of the lag times.  Default:
    ``None``.
--stop-fit
    Stop fitting the remain probability as soon as it falls below the
    given value.  The fitting is stopped by whatever happens earlier:
    \--end-fit or \--stop-fit.  Default: ``0.01``.

See Also
--------
:mod:`misc.dtrj_lifetimes.generate_dtrj` :
    Generate an artificial discrete trajectory with a given number of
    states with a given lifetime distribution

Notes
-----
.. code-block:: bash

    for dtrj in *.npz; do
        fname="${dtrj::-4}"
        python3 compare_dtrj_lifetime_methods.py \
            --dtrj "${dtrj}" \
            --rp "${fname}_state_lifetime_discrete_continuous.txt.gz" \
            --param "${fname}_param.txt.gz" \
            -o "${fname}_compare_dtrj_lifetime_methods"
    done

"""


__author__ = "Andreas Thum"


# Standard libraries
import argparse
import os
import sys
from datetime import datetime, timedelta

# Third-party libraries
import matplotlib.pyplot as plt
import numpy as np
import psutil
from matplotlib.backends.backend_pdf import PdfPages
from matplotlib.ticker import MaxNLocator
from scipy.special import gamma
from scipy.stats import burr12, gengamma

# First-party libraries
import mdtools as mdt
import mdtools.plot as mdtplt  # Load MDTools plot style  # noqa: F401


if __name__ == "__main__":  # noqa: C901
    timer_tot = datetime.now()
    proc = psutil.Process()
    proc.cpu_percent()  # Initiate monitoring of CPU usage.
    parser = argparse.ArgumentParser(
        # The description should only contain the short summary from the
        # docstring and a reference to the documentation.
        description=(
            "Compare state lifetimes calculated from a discrete trajectory"
            " using different methods"
        )
    )
    parser.add_argument(
        "--dtrj",
        dest="INFILE_DTRJ",
        type=str,
        required=True,
        help=(
            "File containing the discrete trajectory stored as numpy.ndarray"
            " in the binary .npy format or as .npz archive."
        ),
    )
    parser.add_argument(
        "--rp",
        dest="INFILE_RP",
        type=str,
        required=True,
        help=(
            "Name of the file containing the remain probabilities for each"
            " state."
        ),
    )
    parser.add_argument(
        "--param",
        dest="INFILE_PARAM",
        type=str,
        required=False,
        default=None,
        help=(
            "File containing the parameters that were used to generate the"
            " artificial discrete trajectory (optional)."
        ),
    )
    parser.add_argument(
        "-o",
        dest="OUTFILE",
        type=str,
        required=True,
        help="Output filename pattern.",
    )
    parser.add_argument(
        "--int-thresh",
        dest="INT_THRESH",
        type=float,
        required=False,
        default=0.01,
        help=(
            "Only calculate the lifetime by directly integrating the remain"
            " probability if the remain probability decays below the given"
            " threshold.  Default:  %(default)s."
        ),
    )
    parser.add_argument(
        "--end-fit",
        dest="ENDFIT",
        type=float,
        required=False,
        default=None,
        help=(
            "End time for fitting the remain probability in trajectory"
            " steps (inclusive).  If None, the fit ends at 90%% of the"
            " lag times.  Default: %(default)s."
        ),
    )
    parser.add_argument(
        "--stop-fit",
        dest="STOPFIT",
        type=float,
        required=False,
        default=0.01,
        help=(
            "Stop fitting the remain probability as soon as it falls below the"
            " given value.  The fitting is stopped by whatever happens"
            " earlier: --end-fit or --stop-fit.  Default: %(default)s"
        ),
    )
    args = parser.parse_args()
    print(mdt.rti.run_time_info_str())

    # Fit method of `scipy.optimize.curve_fit` to use for all fits.
    fit_method = "trf"

    # Conversion factor to convert "trajectory steps" to some physical
    # time unit (e.g. ns).
    time_conv = 1

    print("\n")
    print("Calculating lifetimes directly from `dtrj` (Methods 1-2)...")
    timer = datetime.now()
    dtrj = mdt.fh.load_dtrj(args.INFILE_DTRJ)
    n_frames = dtrj.shape[1]

    # Method 1: Calculate the average lifetime by counting the number of
    # frames that a given compound stays in a given state.
    lts_cnt, states_cnt = mdt.dtrj.lifetimes_per_state(
        dtrj, return_states=True
    )
    lts_cnt = [lts * time_conv for lts in lts_cnt]
    lts_cnt_mom1 = np.array([np.mean(lts) for lts in lts_cnt])
    lts_cnt_mom2 = np.array([np.mean(lts**2) for lts in lts_cnt])
    del lts_cnt

    # Method 2: Calculate the transition rate as the number of
    # transitions leading out of a given state divided by the number of
    # frames that compounds have spent in this state.  The average
    # lifetime is calculated as the inverse transition rate.
    rates, states_k = mdt.dtrj.trans_rate_per_state(dtrj, return_states=True)
    lts_k = time_conv / rates
    if not np.array_equal(states_k, states_cnt):
        raise ValueError(
            "`states_k` ({}) != `states_cnt` ({})".format(states_k, states_cnt)
        )
    del dtrj, rates, states_k
    print("Elapsed time:         {}".format(datetime.now() - timer))
    print("Current memory usage: {:.2f} MiB".format(mdt.rti.mem_usage(proc)))

    print("\n")
    print("Calculating lifetimes from the remain probability (Methods 3-6)...")
    timer = datetime.now()

    # Read remain probabilities from file.
    remain_props = np.loadtxt(args.INFILE_RP)
    states = remain_props[0, 1:]  # State indices.
    times = remain_props[1:, 0]  # Lag times in trajectory steps.
    remain_props = remain_props[1:, 1:]  # Remain probability functions.
    if np.any(remain_props < 0) or np.any(remain_props > 1):
        raise ValueError(
            "Some values of the remain probability lie outside the interval"
            " [0, 1]"
        )
    if not np.array_equal(times, np.arange(n_frames)):
        raise ValueError("`times` != `np.arange(n_frames)`")
    times *= time_conv  # Lag times in the given physical time unit.
    if np.any(np.modf(states)[0] != 0):
        raise ValueError(
            "Some state indices are not integers but floats.  states ="
            " {}".format(states)
        )
    if not np.array_equal(states, states_cnt):
        raise ValueError(
            "`states` ({}) != `states_cnt` ({})".format(states, states_cnt)
        )
    del states_cnt
    states = states.astype(np.int32)
    n_states = len(states)

    # Method 3: Set the lifetime to the lag time at which the remain
    # probability crosses 1/e.
    thresh = 1 / np.e
    ix_thresh = np.nanargmax(remain_props <= thresh, axis=0)
    lts_e = np.full(n_states, np.nan, dtype=np.float64)
    for i, rp in enumerate(remain_props.T):
        if rp[ix_thresh[i]] > thresh:
            # The remain probability never falls below the threshold.
            lts_e[i] = np.nan
        elif ix_thresh[i] < 1:
            # The remain probability immediately falls below the
            # threshold.
            lts_e[i] = 0
        elif rp[ix_thresh[i] - 1] < thresh:
            raise ValueError(
                "The threshold ({}) does not lie within the remain probability"
                " interval ([{}, {}]) at the found indices ({}, {}).  This"
                " should not have happened.".format(
                    thresh,
                    rp[ix_thresh[i]],
                    rp[ix_thresh[i] - 1],
                    ix_thresh[i],
                    ix_thresh[i] - 1,
                )
            )
        else:
            slope = rp[ix_thresh[i]] - rp[ix_thresh[i] - 1]
            slope /= times[ix_thresh[i]] - times[ix_thresh[i] - 1]
            intercept = rp[ix_thresh[i]] - slope * times[ix_thresh[i]]
            lts_e[i] = (thresh - intercept) / slope
            if (
                times[ix_thresh[i] - 1] > lts_e[i]
                or times[ix_thresh[i]] < lts_e[i]
            ):
                raise ValueError(
                    "The lifetime ({}) does not lie within the time interval"
                    " ([{}, {}]) at the found indices ({}, {}).  This should"
                    " not have happened.".format(
                        lts_e[i],
                        times[ix_thresh[i] - 1],
                        times[ix_thresh[i]],
                        ix_thresh[i] - 1,
                        ix_thresh[i],
                    )
                )

    # Method 4: Calculate the lifetime as the integral of the remain
    # probability p(t):
    #   <t^n> = n * int_0^inf t^(n-1) * p(t) dt
    lts_int_mom1 = np.full(n_states, np.nan, dtype=np.float64)
    lts_int_mom2 = np.full(n_states, np.nan, dtype=np.float64)
    for i, rp in enumerate(remain_props.T):
        valid = ~np.isnan(rp)
        lts_int_mom1[i] = np.trapz(y=rp[valid], x=times[valid])
        lts_int_mom2[i] = np.trapz(y=rp[valid] * times[valid], x=times[valid])
        lts_int_mom2[i] *= 2
    invalid = np.all(remain_props > args.INT_THRESH, axis=0)
    lts_int_mom1[invalid] = np.nan
    lts_int_mom2[invalid] = np.nan
    del valid, invalid

    # Get fit region for fitting methods.
    if args.ENDFIT is None:
        end_fit = int(0.9 * len(times))
    else:
        _, end_fit = mdt.nph.find_nearest(
            times, args.ENDFIT, return_index=True
        )
    end_fit += 1  # Make `end_fit` inclusive.
    fit_start = np.zeros(n_states, dtype=np.uint32)  # Inclusive.
    fit_stop = np.zeros(n_states, dtype=np.uint32)  # Exclusive.
    for i, rp in enumerate(remain_props.T):
        stop_fit = np.nanargmax(rp < args.STOPFIT)
        if stop_fit == 0 and rp[stop_fit] >= args.STOPFIT:
            # The remain probability never falls below `args.STOPFIT`.
            stop_fit = len(rp)
        elif stop_fit < 2:
            # The remain probability immediately falls below
            # `args.STOPFIT`.
            stop_fit = 2
        fit_stop[i] = min(end_fit, stop_fit)

    # Method 5: Fit the remain probability with a Kohlrausch function
    # (stretched exponential) and calculate the lifetime as the integral
    # of the fit:
    #   I_kww(t) = exp[-(t/tau0_kww)^beta_kww]
    #   <t^n> = n * int_0^inf t^(n-1) * I_kww(t) dt
    #         = tau0_kww^n * Gamma(1 + n/beta_kww)
    bounds_kww = ([0, 0], [np.inf, 10])
    popt_kww = np.full((n_states, 2), np.nan, dtype=np.float64)
    perr_kww = np.full((n_states, 2), np.nan, dtype=np.float64)
    fit_r2_kww = np.full(n_states, np.nan, dtype=np.float64)
    fit_rmse_kww = np.full(n_states, np.nan, dtype=np.float64)
    for i, rp in enumerate(remain_props.T):
        times_fit = times[fit_start[i] : fit_stop[i]]
        rp_fit = rp[fit_start[i] : fit_stop[i]]
        popt_kww[i], perr_kww[i], valid = mdt.func.fit_kww(
            xdata=times_fit,
            ydata=rp_fit,
            return_valid=True,
            bounds=bounds_kww,
            method=fit_method,
        )
        times_fit = times_fit[valid]
        rp_fit = rp_fit[valid]
        if np.any(np.isnan(popt_kww[i])):
            fit_rmse_kww[i] = np.nan
            fit_r2_kww[i] = np.nan
        else:
            fit = mdt.func.kww(times_fit, *popt_kww[i])
            # Residual sum of squares.
            ss_res = np.sum((rp_fit - fit) ** 2)
            # Root-mean-square error / root-mean-square residuals.
            fit_rmse_kww[i] = np.sqrt(ss_res / len(fit))
            # Total sum of squares.
            ss_tot = np.sum((rp_fit - np.mean(rp_fit)) ** 2)
            # (Pseudo) coefficient of determination (R^2).
            # https://www.r-bloggers.com/2021/03/the-r-squared-and-nonlinear-regression-a-difficult-marriage/
            fit_r2_kww[i] = 1 - (ss_res / ss_tot)
    tau0_kww, beta_kww = popt_kww.T
    tau0_kww_sd, beta_kww_sd = perr_kww.T
    lts_kww_mom1 = tau0_kww * gamma(1 + 1 / beta_kww)
    lts_kww_mom2 = tau0_kww**2 * gamma(1 + 2 / beta_kww)

    # Method 6: Fit the remain probability with the survival function of
    # a Burr Type XII distribution and calculate the lifetime as the
    # integral fo the fit:
    #   I_bur(t) = 1 / [1 + (t/tau0_bur)^beta_bur]^delta_bur
    #   <t^n> = n * int_0^inf t^(n-1) * I_bur(t) dt
    #         = tau0_bur^n * Gamma(delta_bur - n/beta_bur) *
    #           Gamma(1 + n/beta_bur) / Gamma(delta_bur)
    bounds_bur = ([0, 0, 1 + 1e-6], [np.inf, 10, 100])
    popt_bur = np.full((n_states, 3), np.nan, dtype=np.float64)
    perr_bur = np.full((n_states, 3), np.nan, dtype=np.float64)
    fit_r2_bur = np.full(n_states, np.nan, dtype=np.float64)
    fit_rmse_bur = np.full(n_states, np.nan, dtype=np.float64)
    for i, rp in enumerate(remain_props.T):
        times_fit = times[fit_start[i] : fit_stop[i]]
        rp_fit = rp[fit_start[i] : fit_stop[i]]
        popt_bur[i], perr_bur[i], valid = mdt.func.fit_burr12_sf_alt(
            xdata=times_fit,
            ydata=rp_fit,
            return_valid=True,
            bounds=bounds_bur,
            method=fit_method,
        )
        times_fit = times_fit[valid]
        rp_fit = rp_fit[valid]
        if np.any(np.isnan(popt_bur[i])):
            fit_rmse_bur[i] = np.nan
            fit_r2_bur[i] = np.nan
        else:
            fit = mdt.func.burr12_sf_alt(times_fit, *popt_bur[i])
            # Residual sum of squares.
            ss_res = np.sum((rp_fit - fit) ** 2)
            # Root-mean-square error / root-mean-square residuals.
            fit_rmse_bur[i] = np.sqrt(ss_res / len(fit))
            # Total sum of squares.
            ss_tot = np.sum((rp_fit - np.mean(rp_fit)) ** 2)
            # (Pseudo) coefficient of determination (R^2).
            # https://www.r-bloggers.com/2021/03/the-r-squared-and-nonlinear-regression-a-difficult-marriage/
            fit_r2_bur[i] = 1 - (ss_res / ss_tot)
    tau0_bur, beta_bur, d_bur = popt_bur.T
    tau0_bur_sd, beta_bur_sd, d_bur_sd = perr_bur.T
    delta_bur = d_bur / beta_bur
    delta_bur_sd = np.sqrt(  # Propagation of uncertainty.
        delta_bur**2
        * (
            (d_bur_sd / d_bur) ** 2
            + (beta_bur_sd / beta_bur) ** 2
            - 2 * d_bur_sd * beta_bur_sd / (d_bur * beta_bur)
        )
    )
    lts_bur_mom1 = (
        tau0_bur
        * gamma(delta_bur - 1 / beta_bur)
        * gamma(1 + 1 / beta_bur)
        / gamma(delta_bur)
    )
    lts_bur_mom2 = (
        tau0_bur**2
        * gamma(delta_bur - 2 / beta_bur)
        * gamma(1 + 2 / beta_bur)
        / gamma(delta_bur)
    )
    print("Elapsed time:         {}".format(datetime.now() - timer))
    print("Current memory usage: {:.2f} MiB".format(mdt.rti.mem_usage(proc)))

    if args.INFILE_PARAM is not None:
        print("\n")
        print("Reading true lifetimes from parameters file...")
        params = np.loadtxt(args.INFILE_PARAM, unpack=True)
        states_true = params[0]
        if not np.all(np.isin(states, states_true)):
            raise ValueError(
                "`states` ({}) is not fully contained in `states_true`"
                " ({})".format(states, states_true)
            )
        del states_true
        params = params[:, states]
        # Parameters of the true lifetime distribution.
        beta_true, delta_true, tau0_true = params[1:4]
        # Moments of the true lifetime distribution.
        lts_dst_mom1, lts_dst_mom2 = params[4:6]
        # Moments of the drawn lifetimes.
        lts_drw_mom1, lts_drw_mom2 = params[6:8]
        # Moments of the uncensored lifetimes.
        lts_unc_mom1, lts_unc_mom2 = params[8:10]
        # Moments of the censored lifetimes.
        lts_cen_mom1, lts_cen_mom2 = params[10:12]
        # Lifetime distributions used to generate the trajectory.
        dist = None
        with mdt.fh.xopen(args.INFILE_PARAM, "r") as file:
            for line in file.readlines():
                if line.startswith("# Lifetime dist.:"):
                    dist = line.split()[-1]
                    break
        if dist is None:
            raise ValueError(
                "Could not determine the used lifetime distribution from"
                " {}".format(args.INFILE_PARAM)
            )
        elif dist == "generalized_gamma":
            lt_dists = [
                gengamma(
                    a=delta_true[i] / beta_true[i],
                    c=beta_true[i],
                    loc=0,
                    scale=tau0_true[i],
                )
                for i in range(n_states)
            ]
        elif dist == "burr12":
            lt_dists = [
                burr12(
                    c=beta_true[i], d=delta_true[i], loc=0, scale=tau0_true[i]
                )
                for i in range(n_states)
            ]
        else:
            raise ValueError("Unknown lifetime distribution: {}".format(dist))

    print("\n")
    print("Creating text output...")
    timer = datetime.now()
    data = [
        states,  # 1
        # Method 1 (counting).
        lts_cnt_mom1,  # 2
        lts_cnt_mom2,  # 3
        # Method 2 (inverse transition rate).
        lts_k,  # 4
        # Method 3 (1/e criterion).
        lts_e,  # 5
        # Method 4 (direct integral).
        lts_int_mom1,  # 6
        lts_int_mom2,  # 7
        # Method 5 (integral of Kohlrausch fit).
        lts_kww_mom1,  # 8
        lts_kww_mom2,  # 9
        tau0_kww,  # 10
        tau0_kww_sd,  # 11
        beta_kww,  # 12
        beta_kww_sd,  # 13
        fit_r2_kww,  # 14
        fit_rmse_kww,  # 15
        # Method 6 (integral of Burr fit).
        lts_bur_mom1,  # 16
        lts_bur_mom2,  # 17
        tau0_bur,  # 18
        tau0_bur_sd,  # 19
        beta_bur,  # 20
        beta_bur_sd,  # 21
        delta_bur,  # 22
        delta_bur_sd,  # 23
        fit_r2_bur,  # 24
        fit_rmse_bur,  # 25
        # Fit region
        fit_start,  # 26
        fit_stop,  # 27
    ]
    if args.INFILE_PARAM is not None:
        data += params[1:12].tolist()
    data = np.column_stack(data)
    header = (
        "State lifetimes.\n"
        + "Average time that a given compound stays in a given state\n"
        + "calculated either directly from the discrete trajectory\n"
        + "(Method 1-2) or from the corresponding remain probability\n"
        + "function (Method 3-6). \n"
        + "\n"
        + "\n"
        + "Discrete trajectory: {:s}\n".format(args.INFILE_DTRJ)
        + "Remain probability:  {:s}\n".format(args.INFILE_RP)
    )
    if args.INFILE_PARAM is not None:
        header += (
            "Parameter file:      {:s}\n".format(args.INFILE_PARAM)
            + "\n"
            + "\n"
        )
    header += (
        "Lifetimes are calculated using six different methods:\n"
        + "\n"
        + "1) The average lifetime <t_cnt> is calculated by counting how\n"
        + "   many frames a given compound stays in a given state.  Note\n"
        + "   lifetimes calculated in this way can at maximum be as long as\n"
        + "   the trajectory and are usually biased to lower values because\n"
        + "   of edge effects (censoring).\n"
        + "\n"
        + "2) The average transition rate <k> is calculated as the number of\n"
        + "   transitions leading out of a given state divided by the number\n"
        + "   frames that compounds have spent in this state.  The average\n"
        + "   lifetime <t_k> is calculated as the inverse transition rate:\n"
        + "     <t_k> = 1 / <k>\n"
        + "\n"
        + "3) The average lifetime <t_e> is set to the lag time at which the\n"
        + "   remain probability function p(t) crosses 1/e.  If this never\n"
        + "   happens, <t_e> is set to NaN.\n"
        + "\n"
        + "4) The remain probability function p(t) is interpreted as the\n"
        + "   survival function of the underlying lifetime distribution.\n"
        + "   Thus, the lifetime can be calculated according to the\n"
        + "   alternative expectation formula [1]:\n"
        + "     <t_int^n> = n * int_0^inf t^(n-1) p(t) dt\n"
        + "   If p(t) does not decay below the given threshold of\n"
        + "   {:.4f}, <t_int^n> is set to NaN.\n".format(args.INT_THRESH)
        + "\n"
        + "5) The remain probability function p(t) is fitted by a Kohlrausch\n"
        + "   function (stretched exponential, survival function of the\n"
        + "   Weibull distribution):\n"
        + "     I_kww(t) = exp[-(t/tau0_kww)^beta_kww]\n"
        + "   Thereby, tau0_kww is confined to the interval\n"
        + "   [{:.4f}, {:.4f}] and beta_kww is confined to the\n".format(
            bounds_kww[0][0], bounds_kww[1][0]
        )
        + "   interval [{:.4f}, {:.4f}].\n".format(
            bounds_kww[0][1], bounds_kww[1][1]
        )
        + "   The average lifetime <t_kww^n> is calculated according to the\n"
        + "   alternative expectation formula [1]:\n"
        + "     <t_kww^n> = n * int_0^inf t^(n-1) I_kww(t) dt\n"
        + "               = tau0_kww^n * Gamma(1 + n/beta_kww)\n"
        + "   where Gamma(z) is the gamma function.\n"
        + "\n"
        + "6) The remain probability function p(t) is fitted by the survival\n"
        + "   function of a Burr Type XII distribution:\n"
        + "     I_bur(t) = 1 / [1 + (t/tau0_bur)^beta_bur]^delta_bur\n"
        + "   Thereby, tau0_bur is confined to the interval\n"
        + "   [{:.4f}, {:.4f}], beta_bur is confined to the interval\n".format(
            bounds_bur[0][0], bounds_bur[1][0]
        )
        + "   [{:.4f}, {:.4f}] and beta_bur * delta_bur is confined\n".format(
            bounds_bur[0][1], bounds_bur[1][1]
        )
        + "   to the interval [{:.4f}, {:.4f}].\n".format(
            bounds_bur[0][2], bounds_bur[1][2]
        )
        + "   The average lifetime <t_bur^n> is calculated according to the\n"
        + "   alternative expectation\n"
        + "   formula [1]:\n"
        + "     <t_bur^n> = n * int_0^inf t^(n-1) I_bur(t) dt\n"
        + "               = tau0_bur^n * Gamma(delta_bur - n/beta_bur) *\n"
        + "                 Gamma(1 + n/beta_bur) / Gamma(delta_bur)\n"
        + "   where Gamma(z) is the gamma function.\n"
        + "\n"
        + "All fits are done using scipy.optimize.curve_fit with the 'Trust\n"
        + "Region Reflective' method.  The remain probability is always\n"
        + "fitted until it decays below the given threshold or until the\n"
        + "given lag time is reached (whatever happens earlier).\n"
        + "\n"
        + "int_thresh = {:.4f}\n".format(args.INT_THRESH)
        + "end_fit  = {}\n".format(args.ENDFIT)
        + "stop_fit = {:.4f}\n".format(args.STOPFIT)
        + "\n"
        + "Reference [1]:\n"
        + "  S. Chakraborti, F. Jardim, E. Epprecht,\n"
        + "  Higher-order moments using the survival function: The\n"
        + "  alternative expectation formula,\n"
        + "  The American Statistician, 2019, 73, 2, 191-194."
        + "\n"
        + "\n"
        + "The columns contain:\n"
        + "  1 State index (zero-based)\n"
        + "\n"
        + "  Lifetime from Method 1 (counting)\n"
        + "  2 1st moment <t_cnt> / frames\n"
        + "  3 2nd moment <t_cnt^2> / frames^2\n"
        + "\n"
        + "  Lifetime from Method 2 (inverse transition rate)\n"
        + "  4 <t_k> / frames\n"
        + "\n"
        + "  Lifetime from Method 3 (1/e criterion)\n"
        + "  5 <t_e> / frames\n"
        + "\n"
        + "  Lifetime from Method 4 (direct integral)\n"
        + "  6 1st moment <t_int> / frames\n"
        + "  7 2nd moment <t_int^2> / frames^2\n"
        + "\n"
        + "  Lifetime from Method 5 (integral of Kohlrausch fit)\n"
        + "  8 1st moment <t_kww> / frames\n"
        + "  9 2nd moment <t_kww^2> / frames^2\n"
        + " 10 Fit parameter tau0_kww / frames\n"
        + " 11 Standard deviation of tau0_kww / frames\n"
        + " 12 Fit parameter beta_kww\n"
        + " 13 Standard deviation of beta_kww\n"
        + " 14 Coefficient of determination of the fit (R^2 value)\n"
        + " 15 Root-mean-square error (RMSE) of the fit / frames\n"
        + "\n"
        + "  Lifetime from Method 6 (integral of Burr fit)\n"
        + " 16 1st moment <t_bur> / frames\n"
        + " 17 2nd moment <t_bur^2> / frames^2\n"
        + " 18 Fit parameter tau0_burr / frames\n"
        + " 19 Standard deviation of tau0_burr / frames\n"
        + " 20 Fit parameter beta_burr\n"
        + " 21 Standard deviation of beta_burr\n"
        + " 22 Fit parameter delta_burr\n"
        + " 23 Standard deviation of delta_burr\n"
        + " 24 Coefficient of determination of the fit (R^2 value)\n"
        + " 25 Root-mean-square error (RMSE) of the fit / frames\n"
        + "\n"
        + "  Fit region for all fitting methods\n"
        + " 26 Start of fit region (inclusive) / frames\n"
        + " 27 End of fit region (exclusive) / frames\n"
    )
    if args.INFILE_PARAM is not None:
        header += (
            "\n"
            + "  True state lifetimes\n"
            + " 28 Shape parameter beta of the true distribution\n"
            + " 29 Shape parameter delta of the true distribution\n"
            + " 30 Scale parameter tau0 of the true distribution\n"
            + " 31 1st moment of the true distribution <t_dst> / frames\n"
            + " 32 2nd moment of the true distribution <t_dst^2> / frames^2\n"
            + " 33 1st moment of the drawn lifetimes <t_drw> / frames\n"
            + " 34 2nd moment of the drawn lifetimes <t_drw^2> / frames^2\n"
            + " 35 1st moment of the uncensored lifetimes <t_unc> / frames\n"
            + " 36 2nd moment of the uncensored lifetimes <t_unc^2> /"
            + " frames^2\n"
            + " 37 1st moment of the censored lifetimes <t_cen> / frames\n"
            + " 38 2nd moment of the censored lifetimes <t_cen^2> / frames^2\n"
        )
    header += "\n" + "Column number:\n"
    header += "{:>14d}".format(1)
    for i in range(2, data.shape[-1] + 1):
        header += " {:>16d}".format(i)
    outfile = args.OUTFILE + ".txt"
    mdt.fh.savetxt(outfile, data, header=header)
    print("Created {}".format(outfile))
    print("Elapsed time:         {}".format(datetime.now() - timer))
    print("Current memory usage: {:.2f} MiB".format(mdt.rti.mem_usage(proc)))

    print("\n")
    print("Creating plot(s)...")
    timer = datetime.now()
    lts_mom1s = [
        lts_cnt_mom1,
        lts_k,
        lts_e,
        lts_int_mom1,
        lts_kww_mom1,
        lts_bur_mom1,
    ]
    tau0s = [tau0_kww, tau0_bur]
    betas = [beta_kww, beta_bur]
    deltas = [delta_bur]
    fit_r2s = [fit_r2_kww, fit_r2_bur]
    fit_rmses = [fit_rmse_kww, fit_rmse_bur]
    if args.INFILE_PARAM is not None:
        lts_mom1s.append(params[[4, 8, 10]])  # lts_dst, lts_unc, lts_cen
        tau0s.append(tau0_true)
        betas.append(beta_true)
        deltas.append(delta_true)
    lts_mom1s = np.vstack(lts_mom1s)
    tau0s = np.vstack(tau0s)
    betas = np.vstack(betas)
    deltas = np.vstack(deltas)
    fit_r2s = np.vstack(fit_r2s)
    fit_rmses = np.vstack(fit_rmses)

    xlabel = r"State Index"
    xlim = (np.min(states) - 0.5, np.max(states) + 0.5)
    alpha = 0.75
    cmap = plt.get_cmap()
    c_vals = np.arange(n_states)
    c_norm = max(1, n_states - 1)
    c_vals_normed = c_vals / c_norm
    colors = cmap(c_vals_normed)

    outfile = args.OUTFILE + ".pdf"
    mdt.fh.backup(outfile)
    with PdfPages(outfile) as pdf:
        # Plot lifetimes vs. state indices.
        fig, ax = plt.subplots(clear=True)
        # Method 6 (integral of Burr fit).
        ax.errorbar(
            states,
            lts_bur_mom1,
            yerr=np.sqrt(lts_bur_mom2 - lts_bur_mom1**2),
            label="Burr",
            color="tab:cyan",
            marker="^",
            alpha=alpha,
        )
        # Method 5 (integral of Kohlrausch fit).
        ax.errorbar(
            states,
            lts_kww_mom1,
            yerr=np.sqrt(lts_kww_mom2 - lts_kww_mom1**2),
            label="Kohlrausch",
            color="tab:blue",
            marker="v",
            alpha=alpha,
        )
        # Method 4 (direct integral)
        ax.errorbar(
            states,
            lts_int_mom1,
            yerr=np.sqrt(lts_int_mom2 - lts_int_mom1**2),
            label="Area",
            color="tab:purple",
            marker=">",
            alpha=alpha,
        )
        # Method 3 (1/e criterion).
        ax.errorbar(
            states,
            lts_e,
            yerr=None,
            label=r"$1/e$",
            color="tab:pink",
            marker="<",
            alpha=alpha,
        )
        # Method 2 (inverse transition rate).
        ax.errorbar(
            states,
            lts_k,
            yerr=None,
            label="Rate",
            color="tab:red",
            marker="h",
            alpha=alpha,
        )
        # Method 1 (counting).
        ax.errorbar(
            states,
            lts_cnt_mom1,
            yerr=np.sqrt(lts_cnt_mom2 - lts_cnt_mom1**2),
            label="Count",
            color="tab:orange",
            marker="H",
            alpha=alpha,
        )
        if args.INFILE_PARAM is not None:
            # True lifetimes (from distribution).
            ax.errorbar(
                states,
                lts_dst_mom1,
                yerr=np.sqrt(lts_dst_mom2 - lts_dst_mom1**2),
                label="True",
                color="tab:green",
                marker="s",
                alpha=alpha,
            )
            # Uncensored lifetimes.
            ax.errorbar(
                states,
                lts_unc_mom1,
                yerr=np.sqrt(lts_unc_mom2 - lts_unc_mom1**2),
                label="Uncensored",
                color="tab:olive",
                marker="D",
                alpha=alpha,
            )
            # Censored lifetimes.
            ax.errorbar(
                states,
                lts_cen_mom1,
                yerr=np.sqrt(lts_cen_mom2 - lts_cen_mom1**2),
                label="Censored",
                color="darkolivegreen",
                marker="d",
                alpha=alpha,
            )
        ax.set(
            xlabel=xlabel,
            ylabel=r"Average Lifetime / Frames",
            xlim=xlim,
        )
        ylim = ax.get_ylim()
        if ylim[0] < 0:
            ax.set_ylim(0, ylim[1])
        ax.xaxis.set_major_locator(MaxNLocator(integer=True))
        ax.set_xticks([], minor=True)
        ax.legend(loc="upper left", ncol=3, **mdtplt.LEGEND_KWARGS_XSMALL)
        pdf.savefig()
        # Set y axis to log scale (lifetimes vs. state indices).
        # Round y limits to next lower and higher power of ten.
        ylim = ax.get_ylim()
        ymin = 10 ** np.floor(np.log10(np.nanmin(lts_mom1s)))
        ymax = 10 ** np.ceil(np.log10(ylim[1]))
        ax.set_ylim(ymin if np.isfinite(ymin) else None, ymax)
        ax.set_yscale("log", base=10, subs=np.arange(2, 10))
        pdf.savefig()
        plt.close()

        # Plot scale parameter tau0.
        fig, ax = plt.subplots(clear=True)
        # Method 6 (Burr fit).
        ax.errorbar(
            states,
            tau0_bur,
            yerr=tau0_bur_sd,
            label="Burr",
            color="tab:cyan",
            marker="^",
        )
        # Method 5 (Kohlrausch fit).
        ax.errorbar(
            states,
            tau0_kww,
            yerr=tau0_kww_sd,
            label="Kohlrausch",
            color="tab:blue",
            marker="v",
        )
        if args.INFILE_PARAM is not None:
            # True tau0 (from distribution).
            ax.errorbar(
                states,
                tau0_true,
                yerr=None,
                label="True",
                color="tab:green",
                marker="s",
            )
        ax.set(
            xlabel=xlabel,
            ylabel=r"Scale Parameter $\tau_0$ / Frames",
            xlim=xlim,
        )
        ylim = ax.get_ylim()
        if ylim[0] < 0:
            ax.set_ylim(0, ylim[1])
        ax.xaxis.set_major_locator(MaxNLocator(integer=True))
        ax.set_xticks([], minor=True)
        ax.legend(loc="upper left", **mdtplt.LEGEND_KWARGS_XSMALL)
        pdf.savefig()
        if np.any(np.isfinite(tau0s)):
            # Set y axis to log scale (scale parameter tau0).
            # Round y limits to next lower and higher power of ten.
            ylim = ax.get_ylim()
            ymin = 10 ** np.floor(np.log10(np.nanmin(tau0s)))
            ymax = 10 ** np.ceil(np.log10(ylim[1]))
            ax.set_ylim(ymin if np.isfinite(ymin) else None, ymax)
            ax.set_yscale("log", base=10, subs=np.arange(2, 10))
            pdf.savefig()
        plt.close()

        # Plot shape parameter beta.
        fig, ax = plt.subplots(clear=True)
        # Method 6 (Burr fit).
        ax.errorbar(
            states,
            beta_bur,
            yerr=beta_bur_sd,
            label="Burr",
            color="tab:cyan",
            marker="^",
        )
        # Method 5 (Kohlrausch fit).
        ax.errorbar(
            states,
            beta_kww,
            yerr=beta_kww_sd,
            label="Kohlrausch",
            color="tab:blue",
            marker="v",
        )
        if args.INFILE_PARAM is not None:
            # True beta (from distribution).
            ax.errorbar(
                states,
                beta_true,
                yerr=None,
                label="True",
                color="tab:green",
                marker="s",
            )
        ax.set(
            xlabel=xlabel,
            ylabel=r"Shape Parameter $\beta$",
            xlim=xlim,
        )
        ylim = ax.get_ylim()
        if ylim[0] < 0:
            ax.set_ylim(0, ylim[1])
        ax.xaxis.set_major_locator(MaxNLocator(integer=True))
        ax.set_xticks([], minor=True)
        ax.legend(**mdtplt.LEGEND_KWARGS_XSMALL)
        pdf.savefig()
        if np.any(np.isfinite(betas)):
            # Set y axis to log scale (shape parameter beta).
            # Round y limits to next lower and higher power of ten.
            ylim = ax.get_ylim()
            ymin = 10 ** np.floor(np.log10(np.nanmin(betas)))
            ymax = 10 ** np.ceil(np.log10(ylim[1]))
            ax.set_ylim(ymin if np.isfinite(ymin) else None, ymax)
            ax.set_yscale("log", base=10, subs=np.arange(2, 10))
            pdf.savefig()
        plt.close()

        # Plot shape parameter delta.
        fig, ax = plt.subplots(clear=True)
        # Method 6 (Burr fit).
        ax.errorbar(
            states,
            delta_bur,
            yerr=delta_bur_sd,
            label="Burr",
            color="tab:cyan",
            marker="^",
        )
        if args.INFILE_PARAM is not None:
            # True delta (from distribution).
            ax.errorbar(
                states,
                delta_true,
                yerr=None,
                label="True",
                color="tab:green",
                marker="s",
            )
        ax.set(
            xlabel=xlabel,
            ylabel=r"Shape Parameter $\delta$",
            xlim=xlim,
        )
        ylim = ax.get_ylim()
        if ylim[0] < 0:
            ax.set_ylim(0, ylim[1])
        ax.xaxis.set_major_locator(MaxNLocator(integer=True))
        ax.set_xticks([], minor=True)
        ax.legend(**mdtplt.LEGEND_KWARGS_XSMALL)
        pdf.savefig()
        if np.any(np.isfinite(deltas)):
            # Set y axis to log scale (shape parameter delta).
            # Round y limits to next lower and higher power of ten.
            ylim = ax.get_ylim()
            ymin = 10 ** np.floor(np.log10(np.nanmin(deltas)))
            ymax = 10 ** np.ceil(np.log10(ylim[1]))
            ax.set_ylim(ymin if np.isfinite(ymin) else None, ymax)
            ax.set_yscale("log", base=10, subs=np.arange(2, 10))
            pdf.savefig()
        plt.close()

        # Plot R^2 value of the fits.
        fig, ax = plt.subplots(clear=True)
        # Method 6 (Burr fit).
        ax.plot(
            states,
            fit_r2_bur,
            label="Burr",
            color="tab:cyan",
            marker="^",
        )
        # Method 5 (Kohlrausch fit).
        ax.plot(
            states,
            fit_r2_kww,
            label="Kohlrausch",
            color="tab:blue",
            marker="v",
        )
        ax.set(
            xlabel=xlabel,
            ylabel=r"Coeff. of Determ. $R^2$",
            xlim=xlim,
            ylim=(0, 1.05),
        )
        ax.xaxis.set_major_locator(MaxNLocator(integer=True))
        ax.set_xticks([], minor=True)
        ax.legend(**mdtplt.LEGEND_KWARGS_XSMALL)
        pdf.savefig()
        if np.any(np.isfinite(fit_r2s)):
            # Set y axis to log scale (R^2 value of the fits).
            # Round `ymin` to next lower power of ten.
            ylim = ax.get_ylim()
            ymin = 10 ** np.floor(np.log10(np.nanmin(fit_r2s)))
            ymax = 2
            ax.set_ylim(ymin if np.isfinite(ymin) else None, ymax)
            ax.set_yscale("log", base=10, subs=np.arange(2, 10))
            pdf.savefig()
        plt.close()

        # Plot root-mean-square error.
        fig, ax = plt.subplots(clear=True)
        # Method 6 (Burr fit).
        ax.plot(
            states,
            fit_rmse_bur,
            label="Burr",
            color="tab:cyan",
            marker="^",
        )
        # Method 5 (Kohlrausch fit).
        ax.plot(
            states,
            fit_rmse_kww,
            label="Kohlrausch",
            color="tab:blue",
            marker="v",
        )
        ax.set(xlabel=xlabel, ylabel=r"RMSE / Frames", xlim=xlim)
        ylim = ax.get_ylim()
        if ylim[0] < 0:
            ax.set_ylim(0, ylim[1])
        ax.xaxis.set_major_locator(MaxNLocator(integer=True))
        ax.set_xticks([], minor=True)
        ax.legend(**mdtplt.LEGEND_KWARGS_XSMALL)
        pdf.savefig()
        if np.any(np.isfinite(fit_rmses)):
            # Set y axis to log scale (root-mean-square error).
            # Round y limits to next lower and higher power of ten.
            ylim = ax.get_ylim()
            ymin = 10 ** np.floor(np.log10(np.nanmin(fit_rmses)))
            ymax = 10 ** np.ceil(np.log10(ylim[1]))
            ax.set_ylim(ymin if np.isfinite(ymin) else None, ymax)
            ax.set_yscale("log", base=10, subs=np.arange(2, 10))
            pdf.savefig()
        plt.close()

        # Plot fitted region.
        fig, ax = plt.subplots(clear=True)
        ax.plot(states, fit_start, label="Start", marker="^")
        ax.plot(states, fit_stop, label="End", marker="v")
        ax.set(xlabel=xlabel, ylabel="Fitted Region / Frames", xlim=xlim)
        ax.xaxis.set_major_locator(MaxNLocator(integer=True))
        ax.set_xticks([], minor=True)
        ax.legend(ncol=2)
        pdf.savefig()
        plt.close()

        # Plot remain probabilities and Burr fits for each state.
        fig, ax = plt.subplots(clear=True)
        ax.set_prop_cycle(color=colors)
        for i, rp in enumerate(remain_props.T):
            times_fit = times[fit_start[i] : fit_stop[i]]
            fit = mdt.func.burr12_sf_alt(times_fit, *popt_bur[i])
            lines = ax.plot(times, rp, label=r"$%d$" % states[i], linewidth=1)
            ax.plot(
                times_fit,
                fit,
                label="Burr" if i == n_states - 1 else None,
                linestyle="dashed",
                color=lines[0].get_color(),
            )
        ax.set(
            xlabel="Lag Time / Frames",
            ylabel="Decay Law",
            xlim=(times[1], times[-1]),
            ylim=(0, 1),
        )
        ax.set_xscale("log", base=10, subs=np.arange(2, 10))
        legend = ax.legend(
            title="State Index",
            loc="upper right",
            ncol=2,
            **mdtplt.LEGEND_KWARGS_XSMALL,
        )
        legend.get_title().set_multialignment("center")
        pdf.savefig()
        plt.close()

        # Plot Burr fit residuals for each state.
        fig, ax = plt.subplots(clear=True)
        ax.set_prop_cycle(color=colors)
        for i, rp in enumerate(remain_props.T):
            times_fit = times[fit_start[i] : fit_stop[i]]
            fit = mdt.func.burr12_sf_alt(times_fit, *popt_bur[i])
            res = rp[fit_start[i] : fit_stop[i]] - fit
            ax.plot(times_fit, res, label=r"$%d$" % states[i])
        ax.set(
            xlabel="Lag Time / Frames",
            ylabel="Burr Fit Residuals",
            xlim=(times[1], times[-1]),
        )
        ax.set_xscale("log", base=10, subs=np.arange(2, 10))
        legend = ax.legend(
            title="State Index",
            loc="lower right",
            ncol=2,
            **mdtplt.LEGEND_KWARGS_XSMALL,
        )
        legend.get_title().set_multialignment("center")
        pdf.savefig()
        plt.close()

        # Plot remain probabilities and Kohlrausch fits for each state.
        fig, ax = plt.subplots(clear=True)
        ax.set_prop_cycle(color=colors)
        for i, rp in enumerate(remain_props.T):
            times_fit = times[fit_start[i] : fit_stop[i]]
            fit = mdt.func.kww(times_fit, *popt_kww[i])
            lines = ax.plot(times, rp, label=r"$%d$" % states[i], linewidth=1)
            ax.plot(
                times_fit,
                fit,
                label="Kohlrausch" if i == n_states - 1 else None,
                linestyle="dashed",
                color=lines[0].get_color(),
            )
        ax.set(
            xlabel="Lag Time / Frames",
            ylabel="Decay Law",
            xlim=(times[1], times[-1]),
            ylim=(0, 1),
        )
        ax.set_xscale("log", base=10, subs=np.arange(2, 10))
        legend = ax.legend(
            title="State Index",
            loc="upper right",
            ncol=2,
            **mdtplt.LEGEND_KWARGS_XSMALL,
        )
        legend.get_title().set_multialignment("center")
        pdf.savefig()
        plt.close()

        # Plot Kohlrausch fit residuals for each state.
        fig, ax = plt.subplots(clear=True)
        ax.set_prop_cycle(color=colors)
        for i, rp in enumerate(remain_props.T):
            times_fit = times[fit_start[i] : fit_stop[i]]
            fit = mdt.func.kww(times_fit, *popt_kww[i])
            res = rp[fit_start[i] : fit_stop[i]] - fit
            ax.plot(times_fit, res, label=r"$%d$" % states[i])
        ax.set(
            xlabel="Lag Time / Frames",
            ylabel="Kohlrausch Fit Residuals",
            xlim=(times[1], times[-1]),
        )
        ax.set_xscale("log", base=10, subs=np.arange(2, 10))
        legend = ax.legend(
            title="State Index",
            loc="lower right",
            ncol=2,
            **mdtplt.LEGEND_KWARGS_XSMALL,
        )
        legend.get_title().set_multialignment("center")
        pdf.savefig()
        plt.close()

        if args.INFILE_PARAM is not None:
            # Plot remain probabilities and true survival functions for
            # each state.
            fig, ax = plt.subplots(clear=True)
            ax.set_prop_cycle(color=colors)
            for i, rp in enumerate(remain_props.T):
                lines = ax.plot(
                    times, rp, label=r"$%d$" % states[i], linewidth=1
                )
                ax.plot(
                    times,
                    lt_dists[i].sf(times),
                    label="True SF" if i == n_states - 1 else None,
                    linestyle="dashed",
                    color=lines[0].get_color(),
                )
            ax.set(
                xlabel="Lag Time / Frames",
                ylabel="Decay Law",
                xlim=(times[1], times[-1]),
                ylim=(0, 1),
            )
            ax.set_xscale("log", base=10, subs=np.arange(2, 10))
            legend = ax.legend(
                title="State Index",
                loc="upper right",
                ncol=2,
                **mdtplt.LEGEND_KWARGS_XSMALL,
            )
            legend.get_title().set_multialignment("center")
            pdf.savefig()
            plt.close()

            # Plot difference of the remain probabilities to the true
            # survival functions for each state.
            fig, ax = plt.subplots(clear=True)
            ax.set_prop_cycle(color=colors)
            for i, rp in enumerate(remain_props.T):
                res = lt_dists[i].sf(times) - rp
                ax.plot(times, res, label=r"$%d$" % states[i])
            ax.set(
                xlabel="Lag Time / Frames",
                ylabel=r"True SF $-$ Remain Prob.",
                xlim=(times[1], times[-1]),
            )
            ax.set_xscale("log", base=10, subs=np.arange(2, 10))
            legend = ax.legend(
                title="State Index",
                loc="lower right",
                ncol=2,
                **mdtplt.LEGEND_KWARGS_XSMALL,
            )
            legend.get_title().set_multialignment("center")
            pdf.savefig()
            plt.close()
    print("Created {}".format(outfile))
    print("Elapsed time:         {}".format(datetime.now() - timer))
    print("Current memory usage: {:.2f} MiB".format(mdt.rti.mem_usage(proc)))

    print("\n")
    print("{} done".format(os.path.basename(sys.argv[0])))
    print("Totally elapsed time: {}".format(datetime.now() - timer_tot))
    _cpu_time = timedelta(seconds=sum(proc.cpu_times()[:4]))
    print("CPU time:             {}".format(_cpu_time))
    print("CPU usage:            {:.2f} %".format(proc.cpu_percent()))
    print("Current memory usage: {:.2f} MiB".format(mdt.rti.mem_usage(proc)))
