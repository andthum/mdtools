#!/usr/bin/env python3

# This file is part of MDTools.
# Copyright (C) 2021-2023  The MDTools Development Team and all
# contributors listed in the file AUTHORS.rst
#
# MDTools is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or (at your
# option) any later version.
#
# MDTools is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License
# along with MDTools.  If not, see <http://www.gnu.org/licenses/>.


r"""
Compare state lifetimes calculated from a discrete trajectory using
different methods.

Options
-------
--dtrj
    Name of the file containing the discrete trajectory.  The discrete
    trajectory must be stored as :class:`numpy.ndarray` either in a
    binary NumPy |npy_file| or in a (compressed) NumPy |npz_archive|.
    See :func:`mdtools.file_handler.load_dtrj` for more information
    about the requirements for the input file.
--rp
    Name of the file containing the remain probabilities for each state
    as generated by
    :mod:`scripts.discretization.state_lifetime_discrete`.
--param
    File containing the parameters that were used to generate the
    artificial discrete trajectory as created by
    :mod:`misc.dtrj_lifetimes.generate_dtrj.py` (optional).  If
    provided, the true lifetimes are also plotted.
-o
    Output filename pattern.
--int-thresh
    Only calculate the lifetime by directly integrating the remain
    probability if the remain probability decays below the given
    threshold.  Default: ``0.01``.
--end-fit
    End time for fitting the remain probability (in trajectory steps).
    This is inclusive, i.e. the time given here is still included in the
    fit.  If ``None``, the fit ends at 90% of the lag times.  Default:
    ``None``.
--stop-fit
    Stop fitting the remain probability as soon as it falls below the
    given value.  The fitting is stopped by whatever happens earlier:
    \--end-fit or \--stop-fit.  Default: ``0.01``.
--time-conv
    Time conversion factor.  Multiply times by this factor.  Default:
    ``1``.

See Also
--------
:mod:`misc.dtrj_lifetimes.generate_dtrj` :
    Generate an artificial discrete trajectory with a given number of
    states with a given lifetime distribution

Notes
-----
.. code-block:: bash

    for dtrj in *.npz; do
        fname="${dtrj::-4}"
        python3 compare_dtrj_lifetime_methods.py \
            --dtrj "${dtrj}" \
            --rp "${fname}_state_lifetime_discrete_continuous.txt.gz" \
            --param "${fname}_param.txt.gz" \
            -o "${fname}_compare_dtrj_lifetime_methods"
    done

"""


__author__ = "Andreas Thum"


# Standard libraries
import argparse
import os
import sys
import warnings
from datetime import datetime, timedelta

# Third-party libraries
import matplotlib.pyplot as plt
import numpy as np
import psutil
from matplotlib.backends.backend_pdf import PdfPages
from matplotlib.ticker import MaxNLocator
from scipy import stats
from scipy.special import gamma

# First-party libraries
import mdtools as mdt
import mdtools.plot as mdtplt  # Load MDTools plot style  # noqa: F401


def dist_charac(a, axis=-1):
    """
    Calculate distribution characteristics of a given sample.

    Parameters
    ----------
    a : array_like
        Array of samples.
    axis : int, optional
        The axis along which to compute the distribution
        characteristics.

    Returns
    -------
    charac : numpy.ndarray
        Array of shape ``(8, )`` containing the

            1. Sample mean
            2. Corrected sample standard deviation
            3. Unbiased sample skewness
            4. Unbiased sample excess kurtosis (according to Fisher)
            5. Sample median
            6. Sample minimum
            7. Sample maximum
            8. Number of samples

    """
    a = np.asarray(a)
    nobs, min_max, mean, var, skew, kurt = stats.describe(
        a, axis=axis, ddof=1, bias=False
    )
    median = np.median(a, axis=axis)
    charac = np.array(
        [
            mean,  # Sample mean.
            np.sqrt(var),  # Corrected sample standard deviation.
            skew,  # Unbiased sample skewness.
            kurt,  # Unbiased sample excess kurtosis (Fisher).
            median,  # Median of the sample.
            min_max[0],  # Minimum value of the sample.
            min_max[1],  # Maximum value of the sample.
            nobs,  # Number of observations (sample points).
        ]
    )
    return charac


def raw_moment_integrate(sf, x, n=1):
    r"""
    Calculate the :math:`n`-th raw moment through numerical integration
    of the survival function using of the alternative expectation
    formula.
    [1]_

    .. math::

        \langle x^n \rangle =
        n \int_{-\infty}^\infty x^{n-1} S(x) \text{ d}x

    Here, :math:`S(x)` is the survival function of the probability
    density function of :math:`x`.  The integral is evaluated
    numerically using :func:`numpy.trapz`.

    Parameters
    ----------
    sf : array_like
        Values of the survival function :math:`S(x)`.
    x : array_like
        Corresponding :math:`x` values.
    n : int, optional
        Order of the moment.

    Returns
    -------
    rm_n : float
        The :math:`n`-th raw moment.

    Notes
    -----
    Values were `sf` or `x` are NaN or infinite are removed prior to
    computing the integral.

    References
    ----------
    .. [1] S. Chakraborti, F. Jardim, E. Epprecht,
        `Higher-order moments using the survival function: The
        alternative expectation formula
        <https://doi.org/10.1080/00031305.2017.1356374>`_,
        The American Statistician, 2019, 73, 2, 191-194.
    """
    valid = np.isfinite(x) & np.isfinite(sf)
    if not np.any(valid):
        warnings.warn("No valid values for numerical integration")
        return np.nan
    if n < 1 or np.any(np.modf(n)[0] != 0):
        raise ValueError(
            "The moment order, `n` ({}), must be a positive integer".format(n)
        )
    integrand = x[valid] ** (n - 1)
    integrand *= sf[valid]
    integral = np.trapz(y=integrand, x=x[valid])
    integral *= n
    return integral


def raw_moment_weibull(tau0, beta, n=1):
    r"""
    Calculate the :math:`n`-th raw moment of the Weibull distribution.

    .. math::

        \langle t^n \rangle =
        \tau_0^n \Gamma(1 + \frac{n}{\beta})

    Parameters
    ----------
    tau0 : scalar or array_like
        The scale parameter of the Weibull distribution.
    beta : scalar or array_like
        The shape parameter of the Weibull distribution.
    n : int or array of int, optional
        Order of the moment.

    Returns
    -------
    rm_n : scalar or numpy.ndarray
        The :math:`n`-th raw moment.

    Notes
    -----
    If more than one input argument is an array, all arrays must be
    broadcastable.
    """
    rm_n = np.power(tau0, n)
    rm_n *= gamma(1 + np.divide(n, beta))
    return rm_n


def raw_moment_burr12(tau0, beta, delta, n=1):
    r"""
    Calculate the :math:`n`-th raw moment of the Burr Type XII
    distribution.

    .. math::

        \langle t^n \rangle =
        \tau_0^n
        \frac{
            \Gamma\left( \delta - \frac{n}{\beta} \right)
            \Gamma\left( 1      + \frac{n}{\beta} \right)
        }{
            \Gamma(\delta)
        }

    Parameters
    ----------
    tau0 : scalar or array_like
        The scale parameter of the Burr Type XII distribution.
    beta, delta : scalar or array_like
        The shape parameters of the Burr Type XII distribution.
    n : int or array of int, optional
        Order of the moment.

    Returns
    -------
    rm_n : scalar or numpy.ndarray
        The :math:`n`-th raw moment.

    Notes
    -----
    If more than one input argument is an array, all arrays must be
    broadcastable.
    """
    rm_n = np.power(tau0, n)
    rm_n *= gamma(np.subtract(delta, np.divide(n, beta)))
    rm_n *= gamma(1 + np.divide(n, beta))
    rm_n /= gamma(delta)
    return rm_n


def skewness(mu2, mu3):
    r"""
    Calculate the skewness of a distribution from the second and third
    central moment.

    .. math::

        \gamma_1 = \frac{\mu_3}{\mu_2^{3/2}}

    Here, :math:`\mu_n = \langle (x - \mu)^n \rangle` is the
    :math:`n`-th central moment.

    Parameters
    ----------
    mu2, mu3 : scalar or array_like
        The second and third central moment.

    Returns
    -------
    skew : scalar or numpy.ndarray
        The skewness of the distribution.

    Notes
    -----
    If more than one input argument is an array, all arrays must be
    broadcastable.
    """
    return np.divide(mu3, np.power(mu2, 3 / 2))


def kurtosis(mu2, mu4):
    r"""
    Calculate the excess kurtosis (according to Fisher) of a
    distribution from the second and fourth central moment.

    .. math::

        \gamma_2 = \frac{\mu_4}{\mu_2^2} - 3

    Here, :math:`\mu_n = \langle (x - \mu)^n \rangle` is the
    :math:`n`-th central moment.

    Parameters
    ----------
    mu2, mu4 : scalar or array_like
        The second and fourth central moment.

    Returns
    -------
    kurt : scalar or numpy.ndarray
        The excess kurtosis of the distribution.

    Notes
    -----
    If more than one input argument is an array, all arrays must be
    broadcastable.
    """
    return np.divide(mu4, np.power(mu2, 2)) - 3


def cross(y, x, f):
    r"""
    Return the `x` value where the array `f` falls below the given `y`
    value for the first time.

    If `f` never falls below the given `y` value, ``numpy.nan`` is
    returned.

    If `f` falls immediately below the given `y` value, ``0`` is
    returned.

    Parameters
    ----------
    y : scalar
        The `y` value for which to get the `x` value.
    x, f : array_like
        The `x` values and corresponding `f` values.

    Returns
    -------
    x_of_y : scalar
        The `x` value that belongs to the given `y` value.
    """
    ix_y = np.nanargmax(f <= y)
    if f[ix_y] > y:
        # `f` never falls below the given `y` value.
        return np.nan
    elif ix_y < 1:
        # `f` falls immediately below the given `y` value.
        return 0
    elif f[ix_y] == y:
        return x[ix_y]
    else:
        # Linearly interpolate between `f[ix_y]` and `f[ix_y - 1]` to
        # estimate the `x` value that belongs to the given `y` value.
        slope = f[ix_y] - f[ix_y - 1]
        slope /= x[ix_y] - x[ix_y - 1]
        intercept = f[ix_y] - slope * x[ix_y]
        return (y - intercept) / slope


def fit_goodness(data, fit):
    """
    Calculate quantities to assess the goodness of a fit.

    Parameters
    ----------
    data : array_like
        The true data.
    fit : array_like
        Array of the same shape as `data` containing the corresponding
        fit/model values.

    Returns
    -------
    r2 : scalar
        Coefficient of determination.
    rmse : scalar
        The root-mean-square error, also known as root-mean-square
        residuals.
    """
    data = np.asarray(data)
    fit = np.asarray(fit)
    # Residual sum of squares.
    ss_res = np.sum((data - fit) ** 2)
    # Root-mean-square error / root-mean-square residuals.
    rmse = np.sqrt(ss_res / len(fit))
    # Total sum of squares.
    ss_tot = np.sum((data - np.mean(data)) ** 2)
    # (Pseudo) coefficient of determination (R^2).
    # https://www.r-bloggers.com/2021/03/the-r-squared-and-nonlinear-regression-a-difficult-marriage/
    r2 = 1 - (ss_res / ss_tot)
    return r2, rmse


if __name__ == "__main__":  # noqa: C901
    timer_tot = datetime.now()
    proc = psutil.Process()
    proc.cpu_percent()  # Initiate monitoring of CPU usage.
    parser = argparse.ArgumentParser(
        # The description should only contain the short summary from the
        # docstring and a reference to the documentation.
        description=(
            "Compare state lifetimes calculated from a discrete trajectory"
            " using different methods"
        )
    )
    parser.add_argument(
        "--dtrj",
        dest="INFILE_DTRJ",
        type=str,
        required=True,
        help=(
            "File containing the discrete trajectory stored as numpy.ndarray"
            " in the binary .npy format or as .npz archive."
        ),
    )
    parser.add_argument(
        "--rp",
        dest="INFILE_RP",
        type=str,
        required=True,
        help=(
            "Name of the file containing the remain probabilities for each"
            " state."
        ),
    )
    parser.add_argument(
        "--param",
        dest="INFILE_PARAM",
        type=str,
        required=False,
        default=None,
        help=(
            "File containing the parameters that were used to generate the"
            " artificial discrete trajectory (optional)."
        ),
    )
    parser.add_argument(
        "-o",
        dest="OUTFILE",
        type=str,
        required=True,
        help="Output filename pattern.",
    )
    parser.add_argument(
        "--int-thresh",
        dest="INT_THRESH",
        type=float,
        required=False,
        default=0.01,
        help=(
            "Only calculate the lifetime by directly integrating the remain"
            " probability if the remain probability decays below the given"
            " threshold.  Default:  %(default)s."
        ),
    )
    parser.add_argument(
        "--end-fit",
        dest="ENDFIT",
        type=float,
        required=False,
        default=None,
        help=(
            "End time for fitting the remain probability in trajectory"
            " steps (inclusive).  If None, the fit ends at 90%% of the"
            " lag times.  Default: %(default)s."
        ),
    )
    parser.add_argument(
        "--stop-fit",
        dest="STOPFIT",
        type=float,
        required=False,
        default=0.01,
        help=(
            "Stop fitting the remain probability as soon as it falls below the"
            " given value.  The fitting is stopped by whatever happens"
            " earlier: --end-fit or --stop-fit.  Default: %(default)s"
        ),
    )
    parser.add_argument(
        "--time-conv",
        dest="TIME_CONV",
        type=float,
        required=False,
        default=1,
        help="Time conversion factor.  Default: %(default)s",
    )
    args = parser.parse_args()
    print(mdt.rti.run_time_info_str())

    # Number of moments to calculate.  For calculating the skewness, the
    # 2nd and 3rd (central) moments are required, for the kurtosis the
    # 2nd and 4th (central) moments are required.
    n_moms = 4
    # Fit method of `scipy.optimize.curve_fit` to use for all fits.
    fit_method = "trf"

    ####################################################################
    print("\n")
    print("Calculating lifetimes directly from `dtrj`...")
    timer = datetime.now()
    dtrj = mdt.fh.load_dtrj(args.INFILE_DTRJ)
    n_frames = dtrj.shape[1]

    # Method 1: Calculate the average lifetime by counting the number of
    # frames that a given compound stays in a given state including
    # truncated states at the trajectory edges -> censored.
    lts_cnt_cen, states = mdt.dtrj.lifetimes_per_state(
        dtrj, uncensored=False, return_states=True
    )
    lts_cnt_cen = [lts * args.TIME_CONV for lts in lts_cnt_cen]
    n_states = len(states)
    lts_cnt_cen_characs = np.full((n_states, 8), np.nan, dtype=np.float64)
    lts_cnt_cen_characs[:, -1] = 0  # Default number of observations.
    for i, lts in enumerate(lts_cnt_cen):
        lts_cnt_cen_characs[i] = dist_charac(lts)
    del lts_cnt_cen

    # Method 2: Calculate the average lifetime by counting the number of
    # frames that a given compound stays in a given state excluding
    # truncated states at the trajectory edges -> uncensored.
    lts_cnt_unc, states_cnt_unc = mdt.dtrj.lifetimes_per_state(
        dtrj, uncensored=True, return_states=True
    )
    lts_cnt_unc = [lts * args.TIME_CONV for lts in lts_cnt_unc]
    if not np.all(np.isin(states_cnt_unc, states)):
        raise ValueError(
            "`states_cnt_unc` ({}) is not fully contained in `states`"
            " ({})".format(states_cnt_unc, states)
        )
    lts_cnt_unc_characs = np.full((n_states, 8), np.nan, dtype=np.float64)
    lts_cnt_unc_characs[:, -1] = 0  # Default number of observations.
    for i, lts in enumerate(lts_cnt_unc):
        if len(lts) == 0:
            continue
        else:
            lts_cnt_unc_characs[i] = dist_charac(lts)
    del lts_cnt_unc, states_cnt_unc

    # Method 3: Calculate the transition rate as the number of
    # transitions leading out of a given state divided by the number of
    # frames that compounds have spent in this state.  The average
    # lifetime is calculated as the inverse transition rate.
    rates, states_k = mdt.dtrj.trans_rate_per_state(dtrj, return_states=True)
    lts_k = args.TIME_CONV / rates
    if not np.array_equal(states_k, states):
        raise ValueError(
            "`states_k` ({}) != `states` ({})".format(states_k, states)
        )
    del dtrj, rates, states_k
    print("Elapsed time:         {}".format(datetime.now() - timer))
    print("Current memory usage: {:.2f} MiB".format(mdt.rti.mem_usage(proc)))

    ####################################################################
    print("\n")
    print("Calculating lifetimes from the remain probability...")
    timer = datetime.now()

    # Read remain probabilities from file.
    remain_props = np.loadtxt(args.INFILE_RP)
    states_rp = remain_props[0, 1:]  # State indices.
    times = remain_props[1:, 0]  # Lag times in trajectory steps.
    remain_props = remain_props[1:, 1:]  # Remain probability functions.
    if np.any(remain_props < 0) or np.any(remain_props > 1):
        raise ValueError(
            "Some values of the remain probability lie outside the interval"
            " [0, 1]"
        )
    if not np.array_equal(times, np.arange(n_frames)):
        raise ValueError("`times` != `np.arange(n_frames)`")
    times *= args.TIME_CONV  # Lag times in the given physical time unit.
    if np.any(np.modf(states_rp)[0] != 0):
        raise ValueError(
            "Some state indices are not integers but floats.  `states_rp` ="
            " {}".format(states_rp)
        )
    if not np.array_equal(states_rp, states):
        raise ValueError(
            "`states_rp` ({}) != `states` ({})".format(states_rp, states)
        )
    del states_rp

    # Method 4: Set the lifetime to the lag time at which the remain
    # probability crosses 1/e.
    lts_e = np.array(
        [cross(y=1 / np.e, x=times, f=rp) for rp in remain_props.T]
    )

    # Method 5: Calculate the lifetime as the integral of the remain
    # probability p(t).
    lts_int_characs = np.full((n_states, 5), np.nan, dtype=np.float64)
    for i, rp in enumerate(remain_props.T):
        raw_moms = np.full(n_moms, np.nan, dtype=np.float64)
        cen_moms = np.full(n_moms, np.nan, dtype=np.float64)
        if np.any(rp <= args.INT_THRESH):
            # Only calculate the (raw) moments by numerically
            # integrating the remain probability if the remain
            # probability falls below the given threshold.
            for n in range(n_moms):
                raw_moms[n] = raw_moment_integrate(sf=rp, x=times, n=n + 1)
                cen_moms[n] = mdt.stats.moment_raw2cen(raw_moms[: n + 1])
        skew = skewness(mu2=cen_moms[1], mu3=cen_moms[2])
        kurt = kurtosis(mu2=cen_moms[1], mu4=cen_moms[3])
        # Estimate of the median assuming that the remain probability is
        # equal to the survival function of the underlying distribution
        # of lifetimes.
        median = cross(y=0.5, x=times, f=rp)
        lts_int_characs[i] = np.array(
            [raw_moms[0], np.sqrt(cen_moms[1]), skew, kurt, median]
        )

    # Get fit region for fitting methods.
    if args.ENDFIT is None:
        end_fit = int(0.9 * len(times))
    else:
        _, end_fit = mdt.nph.find_nearest(
            times, args.ENDFIT, return_index=True
        )
    end_fit += 1  # Make `end_fit` inclusive.
    fit_start = np.zeros(n_states, dtype=np.uint32)  # Inclusive.
    fit_stop = np.zeros(n_states, dtype=np.uint32)  # Exclusive.
    for i, rp in enumerate(remain_props.T):
        stop_fit = np.nanargmax(rp < args.STOPFIT)
        if rp[stop_fit] >= args.STOPFIT:
            # The remain probability never falls below `args.STOPFIT`.
            stop_fit = len(rp)
        elif stop_fit < 2:
            # The remain probability immediately falls below
            # `args.STOPFIT`.
            stop_fit = 2
        fit_stop[i] = min(end_fit, stop_fit)

    # Method 6: Fit the remain probability with a Kohlrausch function
    # (stretched exponential) and calculate the lifetime as the integral
    # of the fit:
    #   I_kww(t) = exp[-(t/tau0_kww)^beta_kww]
    #   <t^n> = n * int_0^inf t^(n-1) * I_kww(t) dt
    #         = tau0_kww^n * Gamma(1 + n/beta_kww)
    bounds_kww = ([0, 0], [np.inf, 10])
    popt_kww = np.full((n_states, 2), np.nan, dtype=np.float64)
    perr_kww = np.full((n_states, 2), np.nan, dtype=np.float64)
    lts_kww_fit_goodness = np.full((n_states, 2), np.nan, dtype=np.float64)
    lts_kww_characs = np.full((n_states, 5), np.nan, dtype=np.float64)
    for i, rp in enumerate(remain_props.T):
        # Fit remain probability.
        times_fit = times[fit_start[i] : fit_stop[i]]
        rp_fit = rp[fit_start[i] : fit_stop[i]]
        popt_kww[i], perr_kww[i], valid = mdt.func.fit_kww(
            xdata=times_fit,
            ydata=rp_fit,
            return_valid=True,
            bounds=bounds_kww,
            method=fit_method,
        )
        fit = mdt.func.kww(times_fit[valid], *popt_kww[i])
        r2, rmse = fit_goodness(data=rp_fit[valid], fit=fit)
        lts_kww_fit_goodness[i] = np.array([r2, rmse])
        # Calculate distribution characteristics.
        raw_moms = np.full(n_moms, np.nan, dtype=np.float64)
        cen_moms = np.full(n_moms, np.nan, dtype=np.float64)
        for n in range(n_moms):
            raw_moms[n] = raw_moment_weibull(*popt_kww[i], n=n + 1)
            cen_moms[n] = mdt.stats.moment_raw2cen(raw_moms[: n + 1])
        skew = skewness(mu2=cen_moms[1], mu3=cen_moms[2])
        kurt = kurtosis(mu2=cen_moms[1], mu4=cen_moms[3])
        # Median = tau_0 * ln(2)^(1/beta)
        median = popt_kww[i][0] * np.log(2) ** (1 / popt_kww[i][1])
        lts_kww_characs[i] = np.array(
            [raw_moms[0], np.sqrt(cen_moms[1]), skew, kurt, median]
        )
    tau0_kww, beta_kww = popt_kww.T
    tau0_kww_sd, beta_kww_sd = perr_kww.T

    # Method 7: Fit the remain probability with the survival function of
    # a Burr Type XII distribution and calculate the lifetime as the
    # integral fo the fit:
    #   I_bur(t) = 1 / [1 + (t/tau0_bur)^beta_bur]^delta_bur
    #   <t^n> = n * int_0^inf t^(n-1) * I_bur(t) dt
    #         = tau0_bur^n * Gamma(delta_bur - n/beta_bur) *
    #           Gamma(1 + n/beta_bur) / Gamma(delta_bur)
    bounds_bur = ([0, 0, 1 + 1e-6], [np.inf, 10, 100])
    popt_bur = np.full((n_states, 3), np.nan, dtype=np.float64)
    perr_bur = np.full((n_states, 3), np.nan, dtype=np.float64)
    lts_bur_fit_goodness = np.full((n_states, 2), np.nan, dtype=np.float64)
    lts_bur_characs = np.full((n_states, 5), np.nan, dtype=np.float64)
    for i, rp in enumerate(remain_props.T):
        # Fit remain probability.
        times_fit = times[fit_start[i] : fit_stop[i]]
        rp_fit = rp[fit_start[i] : fit_stop[i]]
        popt_bur[i], perr_bur[i], valid = mdt.func.fit_burr12_sf_alt(
            xdata=times_fit,
            ydata=rp_fit,
            return_valid=True,
            bounds=bounds_bur,
            method=fit_method,
        )
        fit = mdt.func.burr12_sf_alt(times_fit[valid], *popt_bur[i])
        r2, rmse = fit_goodness(data=rp_fit[valid], fit=fit)
        lts_bur_fit_goodness[i] = np.array([r2, rmse])
        # Calculate distribution characteristics.
        tau0 = popt_bur[i][0]
        beta = popt_bur[i][1]
        delta = popt_bur[i][2] / beta
        raw_moms = np.full(n_moms, np.nan, dtype=np.float64)
        cen_moms = np.full(n_moms, np.nan, dtype=np.float64)
        for n in range(n_moms):
            raw_moms[n] = raw_moment_burr12(tau0, beta, delta, n=n + 1)
            cen_moms[n] = mdt.stats.moment_raw2cen(raw_moms[: n + 1])
        skew = skewness(mu2=cen_moms[1], mu3=cen_moms[2])
        kurt = kurtosis(mu2=cen_moms[1], mu4=cen_moms[3])
        # Median = tau_0 * (2^(1/delta) - 1)^(1/beta)
        median = tau0 * (2 ** (1 / delta) - 1) ** (1 / beta)
        lts_bur_characs[i] = np.array(
            [raw_moms[0], np.sqrt(cen_moms[1]), skew, kurt, median]
        )
    tau0_bur, beta_bur, d_bur = popt_bur.T
    tau0_bur_sd, beta_bur_sd, d_bur_sd = perr_bur.T
    delta_bur = d_bur / beta_bur
    delta_bur_sd = np.sqrt(  # Propagation of uncertainty.
        delta_bur**2
        * (
            (d_bur_sd / d_bur) ** 2
            + (beta_bur_sd / beta_bur) ** 2
            - 2 * d_bur_sd * beta_bur_sd / (d_bur * beta_bur)
        )
    )
    print("Elapsed time:         {}".format(datetime.now() - timer))
    print("Current memory usage: {:.2f} MiB".format(mdt.rti.mem_usage(proc)))

    ####################################################################
    if args.INFILE_PARAM is not None:
        print("\n")
        print("Reading true lifetimes from parameters file...")
        params = np.loadtxt(args.INFILE_PARAM, usecols=np.arange(4))
        states_true = params[:, 0]
        if not np.all(np.isin(states, states_true)):
            raise ValueError(
                "`states` ({}) is not fully contained in `states_true`"
                " ({})".format(states, states_true)
            )
        del states_true
        params = params[states]
        # Parameters of the true lifetime distribution.
        beta_true, delta_true, tau0_true = params[:, 1:4].T
        dist_params = np.column_stack([tau0_true, beta_true, delta_true])

        # Lifetime distributions used to generate the trajectory.
        dist = None
        with mdt.fh.xopen(args.INFILE_PARAM, "r") as file:
            for line in file.readlines():
                if line.startswith("# Lifetime dist.:"):
                    dist = line.split()[-1]
                    break
        if dist is None:
            raise ValueError(
                "Could not determine the used lifetime distribution from"
                " {}".format(args.INFILE_PARAM)
            )
        elif dist == "generalized_gamma":
            lt_dists = [
                stats.gengamma(
                    a=delta_true[i] / beta_true[i],
                    c=beta_true[i],
                    loc=0,
                    scale=tau0_true[i],
                )
                for i in range(n_states)
            ]
        elif dist == "burr12":
            lt_dists = [
                stats.burr12(
                    c=beta_true[i], d=delta_true[i], loc=0, scale=tau0_true[i]
                )
                for i in range(n_states)
            ]
        else:
            raise ValueError("Unknown lifetime distribution: {}".format(dist))

        lts_true_rp_goodness = np.full((n_states, 2), np.nan, dtype=np.float64)
        lts_true_characs = np.full((n_states, 5), np.nan, dtype=np.float64)
        for i, rp in enumerate(remain_props.T):
            # R^2 and RMSE if the remain probability is seen as fit of
            # the true survival function.
            valid = np.isfinite(rp)
            sf_true = lt_dists[i].sf(times[valid])
            r2, rmse = fit_goodness(data=sf_true, fit=rp[valid])
            lts_true_rp_goodness[i] = np.array([r2, rmse])
            # Calculate distribution characteristics.
            lts_true_characs[i] = np.array(
                [
                    # Mean, variance, skewness, kurtosis.
                    *lt_dists[i].stats("mvsk"),
                    # Median
                    lt_dists[i].median(),
                ]
            )
            # Variance -> Standard deviation.
            lts_true_characs[i, 1] = np.sqrt(lts_true_characs[i, 1])

    ####################################################################
    print("\n")
    print("Creating text output...")
    timer = datetime.now()
    data = [
        states,  # 1
        # Method 1 (censored counting).
        lts_cnt_cen_characs,  # 2-9
        # Method 2 (uncensored counting).
        lts_cnt_unc_characs,  # 10-17
        # Method 3 (inverse transition rate).
        lts_k,  # 18
        # Method 4 (1/e criterion).
        lts_e,  # 19
        # Method 5 (direct integral).
        lts_int_characs,  # 20-24
        # Method 6 (integral of Kohlrausch fit).
        lts_kww_characs,  # 25-29
        tau0_kww,  # 30
        tau0_kww_sd,  # 31
        beta_kww,  # 32
        beta_kww_sd,  # 33
        lts_kww_fit_goodness,  # 34-35
        # Method 7 (integral of Burr fit).
        lts_bur_characs,  # 36-40
        tau0_bur,  # 41
        tau0_bur_sd,  # 42
        beta_bur,  # 43
        beta_bur_sd,  # 44
        delta_bur,  # 45
        delta_bur_sd,  # 46
        lts_bur_fit_goodness,  # 47-48
        # Fit region
        fit_start,  # 49
        fit_stop - 1,  # 50
    ]
    if args.INFILE_PARAM is not None:
        data += [
            lts_true_characs,  # 51-55
            dist_params,  # 56-58
            lts_true_rp_goodness,  # 59-60
        ]
    data = np.column_stack(data)
    header = (
        "State lifetimes.\n"
        + "Average time that a given compound stays in a given state\n"
        + "calculated either directly from the discrete trajectory\n"
        + "(Method 1-3) or from the corresponding remain probability\n"
        + "function (Method 4-7). \n"
        + "\n"
        + "\n"
        + "Discrete trajectory: {:s}\n".format(args.INFILE_DTRJ)
        + "Remain probability:  {:s}\n".format(args.INFILE_RP)
    )
    if args.INFILE_PARAM is not None:
        header += (
            "Parameter file:      {:s}\n".format(args.INFILE_PARAM)
            + "\n"
            + "\n"
        )
    header += (
        "Lifetimes are calculated using different methods:\n"
        + "\n"
        + "1) The average lifetime <t_cnt_cen> is calculated by counting how\n"
        + "   many frames a given compound stays in a given state including\n"
        + "   truncated states at the trajectory edges -> censored counting.\n"
        + "   Note that lifetimes calculated in this way are usually biased\n"
        + "   to lower values because of the limited length of the\n"
        + "   trajectory and because of truncation/censoring at the\n"
        + "   trajectory edges.\n"
        + "\n"
        + "2) The average lifetime <t_cnt_unc> is calculated by counting how\n"
        + "   many frames a given compound stays in a given state excluding\n"
        + "   truncated states at the trajectory edges -> uncensored\n"
        + "   counting.  Note that lifetimes calculated in this way are\n"
        + "   usually biased to lower values because of the limited length\n"
        + "   of the trajectory.  Uncensored counting might waste a\n"
        + "   significant amount of the trajectory.\n"
        + "\n"
        + "3) The average transition rate <k> is calculated as the number of\n"
        + "   transitions leading out of a given state divided by the number\n"
        + "   of frames that compounds have spent in this state.  The\n"
        + "   average lifetime <t_k> is calculated as the inverse transition\n"
        + "   rate:\n"
        + "     <t_k> = 1 / <k>\n"
        + "\n"
        + "4) The average lifetime <t_e> is set to the lag time at which the\n"
        + "   remain probability function p(t) crosses 1/e.  If this never\n"
        + "   happens, <t_e> is set to NaN.\n"
        + "\n"
        + "5) The remain probability function p(t) is interpreted as the\n"
        + "   survival function of the underlying lifetime distribution.\n"
        + "   Thus, the lifetime can be calculated according to the\n"
        + "   alternative expectation formula [1]:\n"
        + "     <t_int^n> = n * int_0^inf t^(n-1) p(t) dt\n"
        + "   If p(t) does not decay below the given threshold of\n"
        + "   {:.4f}, <t_int^n> is set to NaN.\n".format(args.INT_THRESH)
        + "\n"
        + "6) The remain probability function p(t) is fitted by a Kohlrausch\n"
        + "   function (stretched exponential, survival function of the\n"
        + "   Weibull distribution):\n"
        + "     I_kww(t) = exp[-(t/tau0_kww)^beta_kww]\n"
        + "   Thereby, tau0_kww is confined to the interval\n"
        + "   [{:.4f}, {:.4f}] and beta_kww is confined to the\n".format(
            bounds_kww[0][0], bounds_kww[1][0]
        )
        + "   interval [{:.4f}, {:.4f}].\n".format(
            bounds_kww[0][1], bounds_kww[1][1]
        )
        + "   The average lifetime <t_kww^n> is calculated according to the\n"
        + "   alternative expectation formula [1]:\n"
        + "     <t_kww^n> = n * int_0^inf t^(n-1) I_kww(t) dt\n"
        + "               = tau0_kww^n * Gamma(1 + n/beta_kww)\n"
        + "   where Gamma(z) is the gamma function.\n"
        + "\n"
        + "7) The remain probability function p(t) is fitted by the survival\n"
        + "   function of a Burr Type XII distribution:\n"
        + "     I_bur(t) = 1 / [1 + (t/tau0_bur)^beta_bur]^delta_bur\n"
        + "   Thereby, tau0_bur is confined to the interval\n"
        + "   [{:.4f}, {:.4f}], beta_bur is confined to the interval\n".format(
            bounds_bur[0][0], bounds_bur[1][0]
        )
        + "   [{:.4f}, {:.4f}] and beta_bur * delta_bur is confined\n".format(
            bounds_bur[0][1], bounds_bur[1][1]
        )
        + "   to the interval [{:.4f}, {:.4f}].\n".format(
            bounds_bur[0][2], bounds_bur[1][2]
        )
        + "   The average lifetime <t_bur^n> is calculated according to the\n"
        + "   alternative expectation formula [1]:\n"
        + "     <t_bur^n> = n * int_0^inf t^(n-1) I_bur(t) dt\n"
        + "               = tau0_bur^n * Gamma(delta_bur - n/beta_bur) *\n"
        + "                 Gamma(1 + n/beta_bur) / Gamma(delta_bur)\n"
        + "   where Gamma(z) is the gamma function.\n"
        + "\n"
        + "All fits are done using scipy.optimize.curve_fit with the 'Trust\n"
        + "Region Reflective' method.  The remain probability is always\n"
        + "fitted until it decays below the given threshold or until the\n"
        + "given lag time is reached (whatever happens earlier).\n"
        + "\n"
        + "int_thresh = {:.4f}\n".format(args.INT_THRESH)
        + "end_fit  = {}\n".format(args.ENDFIT)
        + "stop_fit = {:.4f}\n".format(args.STOPFIT)
        + "\n"
        + "Reference [1]:\n"
        + "  S. Chakraborti, F. Jardim, E. Epprecht,\n"
        + "  Higher-order moments using the survival function: The\n"
        + "  alternative expectation formula,\n"
        + "  The American Statistician, 2019, 73, 2, 191-194."
        + "\n"
        + "\n"
        + "The columns contain:\n"
        + "  1 State index (zero-based)\n"
        + "\n"
        + "  Lifetime from Method 1 (censored counting)\n"
        + "  2 Sample mean <t_cnt_cen> / frames\n"
        + "  3 Corrected sample standard deviation / frames\n"
        + "  4 Unbiased sample skewness\n"
        + "  5 Unbiased sample excess kurtosis (Fisher)\n"
        + "  6 Sample median / frames\n"
        + "  7 Sample minimum / frames\n"
        + "  8 Sample maximum / frames\n"
        + "  9 Number of observations/samples\n"
        + "\n"
        + "  Lifetime from Method 2 (uncensored counting)\n"
        + " 10-17 As Method 1\n"
        + "\n"
        + "  Lifetime from Method 3 (inverse transition rate)\n"
        + " 18 <t_k> / frames\n"
        + "\n"
        + "  Lifetime from Method 4 (1/e criterion)\n"
        + " 19 <t_e> / frames\n"
        + "\n"
        + "  Lifetime from Method 5 (direct integral)\n"
        + " 20 Mean <t_int> / frames\n"
        + " 21 Standard deviation / frames\n"
        + " 22 Skewness\n"
        + " 23 Excess kurtosis (Fisher)\n"
        + " 24 Median / frames\n"
        + "\n"
        + "  Lifetime from Method 6 (integral of Kohlrausch fit)\n"
        + " 25-29 As Method 5\n"
        + " 30 Fit parameter tau0_kww / frames\n"
        + " 31 Standard deviation of tau0_kww / frames\n"
        + " 32 Fit parameter beta_kww\n"
        + " 33 Standard deviation of beta_kww\n"
        + " 34 Coefficient of determination of the fit (R^2 value)\n"
        + " 35 Root-mean-square error (RMSE) of the fit\n"
        + "\n"
        + "  Lifetime from Method 7 (integral of Burr fit)\n"
        + " 36-44 As Method 6\n"
        + " 45 Fit parameter delta_burr\n"
        + " 46 Standard deviation of delta_burr\n"
        + " 47 Coefficient of determination of the fit (R^2 value)\n"
        + " 48 Root-mean-square error (RMSE) of the fit\n"
        + "\n"
        + "  Fit region for all fitting methods\n"
        + " 49 Start of fit region (inclusive) / frames\n"
        + " 50 End of fit region (exclusive) / frames\n"
    )
    if args.INFILE_PARAM is not None:
        header += (
            "\n"
            + "  True state lifetimes\n"
            + " 51-55 As Method 5\n"
            + " 56 Scale parameter tau0 of the true distribution\n"
            + " 57 Shape parameter beta of the true distribution\n"
            + " 58 Shape parameter delta of the true distribution\n"
            + " 59 R^2 if the remain probability is seen as fit of the\n"
            + "    survival function (SF) of the true distribution\n"
            + " 60 RMSE of the remain probability to the true SF\n"
        )
    header += "\n" + "Column number:\n"
    header += "{:>14d}".format(1)
    for i in range(2, data.shape[-1] + 1):
        header += " {:>16d}".format(i)
    outfile = args.OUTFILE + ".txt"
    mdt.fh.savetxt(outfile, data, header=header)
    print("Created {}".format(outfile))
    print("Elapsed time:         {}".format(datetime.now() - timer))
    print("Current memory usage: {:.2f} MiB".format(mdt.rti.mem_usage(proc)))

    ####################################################################
    print("\n")
    print("Creating plot(s)...")
    timer = datetime.now()

    label_true = "True"
    # label_cen = "True Cens."
    # label_unc = "True Uncen."
    label_cnt_cen = "Cens."  # Count
    label_cnt_unc = "Uncens."  # Count
    label_k = "Rate"
    # label_e = r"$1/e$"
    label_int = "Area"
    label_kww = "Kohl."
    label_bur = "Burr"

    color_true = "tab:green"
    # color_cen = "tab:olive"
    # color_unc = "darkolivegreen"
    color_cnt_cen = "tab:orange"
    color_cnt_unc = "tab:red"
    color_k = "tab:brown"
    # color_e = "tab:pink"
    color_int = "tab:purple"
    color_kww = "tab:blue"
    color_bur = "tab:cyan"

    marker_true = "s"
    # marker_cen = "D"
    # marker_unc = "d"
    marker_cnt_cen = "H"
    marker_cnt_unc = "h"
    marker_k = "p"
    # marker_e = "<"
    marker_int = ">"
    marker_kww = "^"
    marker_bur = "v"

    xlabel = r"State Index"
    xlim = (np.min(states) - 0.5, np.max(states) + 0.5)
    alpha = 0.75
    cmap = plt.get_cmap()
    c_vals = np.arange(n_states)
    c_norm = max(1, n_states - 1)
    c_vals_normed = c_vals / c_norm
    colors = cmap(c_vals_normed)

    outfile = args.OUTFILE + ".pdf"
    mdt.fh.backup(outfile)
    with PdfPages(outfile) as pdf:
        # Plot distribution characteristics vs. state indices.
        ylabels = (
            "Average Lifetime / Frames",
            "Std. Dev. / Frames",
            "Skewness",
            "Excess Kurtosis",
            "Median / Frames",
        )
        for i, ylabel in enumerate(ylabels):
            fig, ax = plt.subplots(clear=True)
            if args.INFILE_PARAM is not None:
                # True lifetimes distribution.
                ax.plot(
                    states,
                    lts_true_characs[:, i],
                    label=label_true,
                    color=color_true,
                    marker=marker_true,
                    alpha=alpha,
                )
            # Method 1 (censored counting).
            ax.plot(
                states,
                lts_cnt_cen_characs[:, i],
                label=label_cnt_cen,
                color=color_cnt_cen,
                marker=marker_cnt_cen,
                alpha=alpha,
            )
            # Method 2 (uncensored counting).
            ax.plot(
                states,
                lts_cnt_unc_characs[:, i],
                label=label_cnt_unc,
                color=color_cnt_unc,
                marker=marker_cnt_unc,
                alpha=alpha,
            )
            if i == 0:
                # Method 3 (inverse transition rate).
                ax.plot(
                    states,
                    lts_k,
                    label=label_k,
                    color=color_k,
                    marker=marker_k,
                    alpha=alpha,
                )
                # # Method 4 (1/e criterion).
                # ax.plot(
                #     states,
                #     lts_e,
                #     label=label_e,
                #     color=color_e,
                #     marker=marker_e,
                #     alpha=alpha,
                # )
            # Method 5 (direct integral)
            ax.plot(
                states,
                lts_int_characs[:, i],
                label=label_int,
                color=color_int,
                marker=marker_int,
                alpha=alpha,
            )
            # Method 6 (integral of Kohlrausch fit).
            ax.plot(
                states,
                lts_kww_characs[:, i],
                label=label_kww,
                color=color_kww,
                marker=marker_kww,
                alpha=alpha,
            )
            # Method 7 (integral of Burr fit).
            ax.plot(
                states,
                lts_bur_characs[:, i],
                label=label_bur,
                color=color_bur,
                marker=marker_bur,
                alpha=alpha,
            )
            ax.set(xlabel=xlabel, ylabel=ylabel, xlim=xlim)
            ylim = ax.get_ylim()
            if i not in (2, 3) and ylim[0] < 0:
                ax.set_ylim(0, ylim[1])
            ax.xaxis.set_major_locator(MaxNLocator(integer=True))
            ax.set_xticks([], minor=True)
            ax.legend(ncol=3, **mdtplt.LEGEND_KWARGS_XSMALL)
            pdf.savefig()
            ydata = [line.get_ydata() for line in ax.get_lines()]
            yd_min = np.array(
                [np.min(yd[yd > 0]) for yd in ydata if np.any(yd > 0)]
            )
            yd_max = np.array(
                [np.max(yd[yd > 0]) for yd in ydata if np.any(yd > 0)]
            )
            if i not in (2, 3) and len(yd_min) > 0:
                # Set y axis to log scale.
                # Round y limits to next lower and higher power of ten.
                ylim = ax.get_ylim()
                ymin = 10 ** np.floor(np.log10(np.min(yd_min)))
                ymax = 10 ** np.ceil(np.log10(np.max(yd_max)))
                ax.set_ylim(
                    ymin if np.isfinite(ymin) else None,
                    ymax if np.isfinite(ymax) else None,
                )
                ax.set_yscale("log", base=10, subs=np.arange(2, 10))
                pdf.savefig()
            plt.close()

        # Plot number of min, max and number of samples for count
        # methods.
        ylabels = (
            "Min. Lifetime / Frames",
            "Max. Lifetime / Frames",
            "No. of Samples",
        )
        for i, ylabel in enumerate(ylabels):
            fig, ax = plt.subplots(clear=True)
            # Method 1 (censored counting).
            ax.plot(
                states,
                lts_cnt_cen_characs[:, 5 + i],
                label=label_cnt_cen,
                color=color_cnt_cen,
                marker=marker_cnt_cen,
                alpha=alpha,
            )
            # Method 2 (uncensored counting).
            ax.plot(
                states,
                lts_cnt_unc_characs[:, 5 + i],
                label=label_cnt_unc,
                color=color_cnt_unc,
                marker=marker_cnt_unc,
                alpha=alpha,
            )
            ax.set(xlabel=xlabel, ylabel=ylabel, xlim=xlim)
            ylim = ax.get_ylim()
            if ylim[0] < 0:
                ax.set_ylim(0, ylim[1])
            ax.xaxis.set_major_locator(MaxNLocator(integer=True))
            ax.set_xticks([], minor=True)
            ax.legend(**mdtplt.LEGEND_KWARGS_XSMALL)
            pdf.savefig()
            ydata = [line.get_ydata() for line in ax.get_lines()]
            yd_min = np.array(
                [np.min(yd[yd > 0]) for yd in ydata if np.any(yd > 0)]
            )
            yd_max = np.array(
                [np.max(yd[yd > 0]) for yd in ydata if np.any(yd > 0)]
            )
            if len(yd_min) > 0:
                # Set y axis to log scale (fit parameter delta).
                # Round y limits to next lower and higher power of ten.
                ylim = ax.get_ylim()
                ymin = 10 ** np.floor(np.log10(np.min(yd_min)))
                ymax = 10 ** np.ceil(np.log10(np.max(yd_max)))
                ax.set_ylim(
                    ymin if np.isfinite(ymin) else None,
                    ymax if np.isfinite(ymax) else None,
                )
                ax.set_yscale("log", base=10, subs=np.arange(2, 10))
                pdf.savefig()
            plt.close()

        # Plot fit parameters tau0 and beta.
        ylabels = (
            r"Fit Parameter $\tau_0$ / Frames",
            r"Fit Parameter $\beta$",
        )
        for i, ylabel in enumerate(ylabels):
            fig, ax = plt.subplots(clear=True)
            if args.INFILE_PARAM is not None:
                # True distribution.
                ax.errorbar(
                    states,
                    dist_params[:, i],
                    yerr=None,
                    label=label_true,
                    color=color_true,
                    marker=marker_true,
                    alpha=alpha,
                )
            # Method 6 (Kohlrausch fit).
            ax.errorbar(
                states,
                popt_kww[:, i],
                yerr=perr_kww[:, i],
                label=label_kww,
                color=color_kww,
                marker=marker_kww,
                alpha=alpha,
            )
            # Method 7 (Burr fit).
            ax.errorbar(
                states,
                popt_bur[:, i],
                yerr=perr_bur[:, i],
                label=label_bur,
                color=color_bur,
                marker=marker_bur,
                alpha=alpha,
            )
            ax.set(xlabel=xlabel, ylabel=ylabel, xlim=xlim)
            ylim = ax.get_ylim()
            if ylim[0] < 0:
                ax.set_ylim(0, ylim[1])
            ax.xaxis.set_major_locator(MaxNLocator(integer=True))
            ax.set_xticks([], minor=True)
            ax.legend(**mdtplt.LEGEND_KWARGS_XSMALL)
            pdf.savefig()
            ydata = [line.get_ydata() for line in ax.get_lines()]
            yd_min = np.array(
                [np.min(yd[yd > 0]) for yd in ydata if np.any(yd > 0)]
            )
            yd_max = np.array(
                [np.max(yd[yd > 0]) for yd in ydata if np.any(yd > 0)]
            )
            if len(yd_min) > 0:
                # Set y axis to log scale.
                # Round y limits to next lower and higher power of ten.
                ylim = ax.get_ylim()
                ymin = 10 ** np.floor(np.log10(np.min(yd_min)))
                ymax = 10 ** np.ceil(np.log10(np.max(yd_max)))
                ax.set_ylim(
                    ymin if np.isfinite(ymin) else None,
                    ymax if np.isfinite(ymax) else None,
                )
                ax.set_yscale("log", base=10, subs=np.arange(2, 10))
                pdf.savefig()
            plt.close()

        # Plot fit parameter delta.
        fig, ax = plt.subplots(clear=True)
        if args.INFILE_PARAM is not None:
            # True distribution.
            ax.errorbar(
                states,
                delta_true,
                yerr=None,
                label=label_true,
                color=color_true,
                marker=marker_true,
                alpha=alpha,
            )
        # Method 7 (Burr fit).
        ax.errorbar(
            states,
            delta_bur,
            yerr=delta_bur_sd,
            label=label_bur,
            color=color_bur,
            marker=marker_bur,
            alpha=alpha,
        )
        ax.set(xlabel=xlabel, ylabel=r"Fit Parameter $\delta$", xlim=xlim)
        ylim = ax.get_ylim()
        if ylim[0] < 0:
            ax.set_ylim(0, ylim[1])
        ax.xaxis.set_major_locator(MaxNLocator(integer=True))
        ax.set_xticks([], minor=True)
        ax.legend(**mdtplt.LEGEND_KWARGS_XSMALL)
        pdf.savefig()
        ydata = [line.get_ydata() for line in ax.get_lines()]
        yd_min = np.array(
            [np.min(yd[yd > 0]) for yd in ydata if np.any(yd > 0)]
        )
        yd_max = np.array(
            [np.max(yd[yd > 0]) for yd in ydata if np.any(yd > 0)]
        )
        if len(yd_min) > 0:
            # Set y axis to log scale (fit parameter delta).
            # Round y limits to next lower and higher power of ten.
            ylim = ax.get_ylim()
            ymin = 10 ** np.floor(np.log10(np.min(yd_min)))
            ymax = 10 ** np.ceil(np.log10(np.max(yd_max)))
            ax.set_ylim(
                ymin if np.isfinite(ymin) else None,
                ymax if np.isfinite(ymax) else None,
            )
            ax.set_yscale("log", base=10, subs=np.arange(2, 10))
            pdf.savefig()
        plt.close()

        # Plot goodness of fit quantities.
        ylabels = (r"Coeff. of Determ. $R^2$", "RMSE")
        for i, ylabel in enumerate(ylabels):
            fig, ax = plt.subplots(clear=True)
            if args.INFILE_PARAM is not None:
                # Remain probability to the true survival function.
                ax.plot(
                    states,
                    lts_true_rp_goodness[:, i],
                    label=r"$C(t)$",
                    color=color_true,
                    marker=marker_true,
                    alpha=alpha,
                )
            # Method 6 (Kohlrausch fit).
            ax.plot(
                states,
                lts_kww_fit_goodness[:, i],
                label=label_kww,
                color=color_kww,
                marker=marker_kww,
                alpha=alpha,
            )
            # Method 7 (Burr fit).
            ax.plot(
                states,
                lts_bur_fit_goodness[:, i],
                label=label_bur,
                color=color_bur,
                marker=marker_bur,
                alpha=alpha,
            )
            ax.set(xlabel=xlabel, ylabel=ylabel, xlim=xlim)
            ylim = ax.get_ylim()
            if ylim[0] < 0:
                ax.set_ylim(0, ylim[1])
            ax.xaxis.set_major_locator(MaxNLocator(integer=True))
            ax.set_xticks([], minor=True)
            ax.legend(**mdtplt.LEGEND_KWARGS_XSMALL)
            pdf.savefig()
            ydata = [line.get_ydata() for line in ax.get_lines()]
            yd_min = np.array(
                [np.min(yd[yd > 0]) for yd in ydata if np.any(yd > 0)]
            )
            yd_max = np.array(
                [np.max(yd[yd > 0]) for yd in ydata if np.any(yd > 0)]
            )
            if len(yd_min) > 0:
                # Set y axis to log scale (R^2 value of the fits).
                # Round `ymin` to next lower power of ten.
                ylim = ax.get_ylim()
                ymin = 10 ** np.floor(np.log10(np.min(yd_min)))
                if i == 0:
                    ymax = 2
                else:
                    ymax = 10 ** np.ceil(np.log10(np.max(yd_max)))
                ax.set_ylim(
                    ymin if np.isfinite(ymin) else None,
                    ymax if np.isfinite(ymax) else None,
                )
                ax.set_yscale("log", base=10, subs=np.arange(2, 10))
                pdf.savefig()
            plt.close()

        # Plot end of fit region.
        fig, ax = plt.subplots(clear=True)
        ax.plot(states, fit_stop - 1, marker="v")
        ax.set_yscale("log", base=10, subs=np.arange(2, 10))
        ax.set(xlabel=xlabel, ylabel="End of Fit Region / Frames", xlim=xlim)
        ax.xaxis.set_major_locator(MaxNLocator(integer=True))
        ax.set_xticks([], minor=True)
        pdf.savefig()
        plt.close()

        if args.INFILE_PARAM is not None:
            # Plot remain probabilities and true survival functions for
            # each state.
            fig, ax = plt.subplots(clear=True)
            ax.set_prop_cycle(color=colors)
            for i, rp in enumerate(remain_props.T):
                lines = ax.plot(
                    times,
                    rp,
                    label=r"$%d$" % states[i],
                    linewidth=1,
                    alpha=alpha,
                )
                ax.plot(
                    times,
                    lt_dists[i].sf(times),
                    label=r"True $S(t)$" if i == n_states - 1 else None,
                    linestyle="dashed",
                    color=lines[0].get_color(),
                    alpha=alpha,
                )
            ax.set(
                xlabel="Time / Frames",
                ylabel=r"Autocorrelation $C(t)$",
                xlim=(times[1], times[-1]),
                ylim=(0, 1),
            )
            ax.set_xscale("log", base=10, subs=np.arange(2, 10))
            legend = ax.legend(
                title="State Index",
                loc="upper right",
                ncol=2,
                **mdtplt.LEGEND_KWARGS_XSMALL,
            )
            legend.get_title().set_multialignment("center")
            pdf.savefig()
            plt.close()

            # Plot difference of the remain probabilities to the true
            # survival functions for each state.
            fig, ax = plt.subplots(clear=True)
            ax.set_prop_cycle(color=colors)
            for i, rp in enumerate(remain_props.T):
                res = lt_dists[i].sf(times) - rp
                ax.plot(times, res, label=r"$%d$" % states[i], alpha=alpha)
            ax.set(
                xlabel="Time / Frames",
                ylabel=r"$S(t) - C(t)$",
                xlim=(times[1], times[-1]),
            )
            ax.set_xscale("log", base=10, subs=np.arange(2, 10))
            legend = ax.legend(
                title="State Index",
                loc="lower right",
                ncol=2,
                **mdtplt.LEGEND_KWARGS_XSMALL,
            )
            legend.get_title().set_multialignment("center")
            pdf.savefig()
            plt.close()

        # Plot remain probabilities and Kohlrausch fits for each state.
        fig, ax = plt.subplots(clear=True)
        ax.set_prop_cycle(color=colors)
        for i, rp in enumerate(remain_props.T):
            times_fit = times[fit_start[i] : fit_stop[i]]
            fit = mdt.func.kww(times_fit, *popt_kww[i])
            lines = ax.plot(
                times, rp, label=r"$%d$" % states[i], linewidth=1, alpha=alpha
            )
            ax.plot(
                times_fit,
                fit,
                label=label_kww if i == n_states - 1 else None,
                linestyle="dashed",
                color=lines[0].get_color(),
                alpha=alpha,
            )
        ax.set(
            xlabel="Time / Frames",
            ylabel=r"Autocorrelation $C(t)$",
            xlim=(times[1], times[-1]),
            ylim=(0, 1),
        )
        ax.set_xscale("log", base=10, subs=np.arange(2, 10))
        legend = ax.legend(
            title="State Index",
            loc="upper right",
            ncol=2,
            **mdtplt.LEGEND_KWARGS_XSMALL,
        )
        legend.get_title().set_multialignment("center")
        pdf.savefig()
        plt.close()

        # Plot Kohlrausch fit residuals for each state.
        fig, ax = plt.subplots(clear=True)
        ax.set_prop_cycle(color=colors)
        for i, rp in enumerate(remain_props.T):
            times_fit = times[fit_start[i] : fit_stop[i]]
            fit = mdt.func.kww(times_fit, *popt_kww[i])
            res = rp[fit_start[i] : fit_stop[i]] - fit
            ax.plot(times_fit, res, label=r"$%d$" % states[i], alpha=alpha)
        ax.set(
            xlabel="Time / Frames",
            ylabel="Kohlrausch Fit Residuals",
            xlim=(times[1], times[-1]),
        )
        ax.set_xscale("log", base=10, subs=np.arange(2, 10))
        legend = ax.legend(
            title="State Index",
            loc="lower right",
            ncol=2,
            **mdtplt.LEGEND_KWARGS_XSMALL,
        )
        legend.get_title().set_multialignment("center")
        pdf.savefig()
        plt.close()

        # Plot remain probabilities and Burr fits for each state.
        fig, ax = plt.subplots(clear=True)
        ax.set_prop_cycle(color=colors)
        for i, rp in enumerate(remain_props.T):
            times_fit = times[fit_start[i] : fit_stop[i]]
            fit = mdt.func.burr12_sf_alt(times_fit, *popt_bur[i])
            lines = ax.plot(
                times, rp, label=r"$%d$" % states[i], linewidth=1, alpha=alpha
            )
            ax.plot(
                times_fit,
                fit,
                label=label_bur if i == n_states - 1 else None,
                linestyle="dashed",
                color=lines[0].get_color(),
                alpha=alpha,
            )
        ax.set(
            xlabel="Time / Frames",
            ylabel=r"Autocorrelation $C(t)$",
            xlim=(times[1], times[-1]),
            ylim=(0, 1),
        )
        ax.set_xscale("log", base=10, subs=np.arange(2, 10))
        legend = ax.legend(
            title="State Index",
            loc="upper right",
            ncol=2,
            **mdtplt.LEGEND_KWARGS_XSMALL,
        )
        legend.get_title().set_multialignment("center")
        pdf.savefig()
        plt.close()

        # Plot Burr fit residuals for each state.
        fig, ax = plt.subplots(clear=True)
        ax.set_prop_cycle(color=colors)
        for i, rp in enumerate(remain_props.T):
            times_fit = times[fit_start[i] : fit_stop[i]]
            fit = mdt.func.burr12_sf_alt(times_fit, *popt_bur[i])
            res = rp[fit_start[i] : fit_stop[i]] - fit
            ax.plot(times_fit, res, label=r"$%d$" % states[i], alpha=alpha)
        ax.set(
            xlabel="Time / Frames",
            ylabel="Burr Fit Residuals",
            xlim=(times[1], times[-1]),
        )
        ax.set_xscale("log", base=10, subs=np.arange(2, 10))
        legend = ax.legend(
            title="State Index",
            loc="lower right",
            ncol=2,
            **mdtplt.LEGEND_KWARGS_XSMALL,
        )
        legend.get_title().set_multialignment("center")
        pdf.savefig()
        plt.close()
    print("Created {}".format(outfile))
    print("Elapsed time:         {}".format(datetime.now() - timer))
    print("Current memory usage: {:.2f} MiB".format(mdt.rti.mem_usage(proc)))

    print("\n")
    print("{} done".format(os.path.basename(sys.argv[0])))
    print("Totally elapsed time: {}".format(datetime.now() - timer_tot))
    _cpu_time = timedelta(seconds=sum(proc.cpu_times()[:4]))
    print("CPU time:             {}".format(_cpu_time))
    print("CPU usage:            {:.2f} %".format(proc.cpu_percent()))
    print("Current memory usage: {:.2f} MiB".format(mdt.rti.mem_usage(proc)))
