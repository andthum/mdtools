#!/usr/bin/env python3

# This file is part of MDTools.
# Copyright (C) 2021-2023  The MDTools Development Team and all
# contributors listed in the file AUTHORS.rst
#
# MDTools is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or (at your
# option) any later version.
#
# MDTools is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License
# along with MDTools.  If not, see <http://www.gnu.org/licenses/>.


r"""
Generate an artificial discrete trajectory with a given number of states
with a given lifetime distribution.

The lifetime distribution follows the generalized gamma distribution

.. math::

    f(t) =
    \frac{1}{\Gamma\left( \frac{\delta}{\beta} \right)}
    \frac{\beta}{\tau_0}
    \left( \frac{t}{\tau_0} \right)^{\delta - 1}
    \exp{\left[ \left( -\frac{t}{\tau_0} \right)^\beta \right]}

with :math:`\Gamma(z)` being the gamma function.

Options
-------
--dtrj-out
    Output filename for the generated discrete trajectory.   The
    discrete trajectory is written as binary :file:`dtrj.npy` file in a
    compressed |npz_archive| of the given filename.  The discrete
    trajectory is stored as :class:`numpy.ndarray` of dtype
    :attr:`numpy.uint8` and shape ``(n, f)``, where ``n`` is the number
    of compounds and ``f`` is the number of frames.  The elements of the
    discrete trajectory are the states in which a given compound resides
    at a given frame.
--param-out
    Output filename containing the parameters used to create the
    discrete trajectory (optional).
--hist-plot
    Output filename for a histogram plot of the drawn state lifetimes
    (optional).  The histogram shows the lifetimes that were drawn from
    the exponential distribution for each state.
--delta
    :math:`\delta` values to use for the lifetime distribution of each
    state.  The number of :math:`\delta` values determines the number of
    different states in the generated discrete trajectory.  States are
    sequentially numbered starting from zero.  At least two values must
    be given.  Default: ``[1, 1]``
--beta
    :math:`\beta` values to use for the lifetime distribution of each
    state.  The number of given :math:`\beta` values must match the
    number of given :math:`\delta` values.  Default: ``[1, 1]``.
--tau0
    :math:`\tau_0` values to use for the lifetime distribution of each
    state.  The number of given :math:`\tau_0` values must match the
    number of given :math:`\delta` values.  Default: ``[10, 100]``.
--shape
    The shape ``(n, f)`` of the generated discrete trajectory.  Default:
    ``(100, 100000)``.
--discard
    Number of frames to discard at the beginning of the generated
    trajectory.  Set to something greater than zero to emulate a
    left-censoring of the state lifetimes or a discarded equilibration
    period.  Note that the generated trajectory will always have the
    shape given with \--shape.  Default: ``1000``.
--seed
    Seed to use for the random number generator.  If ``None``, a random
    seed will be generated by calling ``secrets.randbits(128)``.
    Default: ``None``.

See Also
--------
:mod:`misc.dtrj_lifetimes.compare_dtrj_lifetime_methods` :
    Compare state lifetimes calculated from a discrete trajectory using
    different methods
:mod:`misc.dtrj_lifetimes.plot_gengamma` :
    Plot the PDF, CDF, Survival and Hazard function of the generalized
    gamma distribution for a given set of shape and scale parameters

Notes
-----
The discrete trajectory is generated in the following way:

    1. Select a random state.  Thereby, ensure that the selected state
       is different from the previously selected state.
    2. Draw a random number from the generalized gamma distribution of
       lifetimes assigned to the selected state.  The drawn number is
       rounded to the nearest integer.  If the drawn number is zero, the
       selected state is discarded and another state is selected.
    3. Extend the discrete trajectory with the selected state by as many
       frames as determined by the drawn lifetime.
    4. Discard a given number of frames (\--discard) at the beginning of
       the trajectory and clip the trajectory at the end such that it
       has the number of frames given with \--shape.

The generalized gamma distribution reduces to many other distributions,
e.g. to the

    * Stretched exponential distribution if :math:`\delta` is unity.
    * Gamma distribution if :math:`\beta` is unity.
    * Weibull distribution if :math:`\delta` equals :math:`\beta`.
    * Exponential distribution if both :math:`\delta` and :math:`\beta`
      are unity.

Examples
--------
Generate discrete trajectories with different number of frames.

.. code-block:: bash

    delta=1
    beta=1
    tau0=100
    n_cmps=1
    discard=1000
    for n_frames in 10 100 1000 10000 100000; do
        fname="dtrj_delta_1_${delta}_beta_1_${beta}_tau0_10_${tau0}_shape_${n_cmps}_${n_frames}_discard_${discard}_seed_5462_4894_3496_8436"
        python3 generate_dtrj.py \
            --dtrj-out "${fname}.npz" \
            --param-out "${fname}_param.txt.gz" \
            --hist-plot "${fname}_drawn_lifetimes_hist.pdf" \
            --delta 1 "${delta}" \
            --beta 1 "${beta}" \
            --tau0 10 "${tau0}" \
            --shape "${n_cmps}" "${n_frames}" \
            --discard "${discard}" \
            --seed 5462489434968436
    done

Generate discrete trajectories with different number of compounds.

.. code-block:: bash

    delta=1
    beta=1
    tau0=100
    n_frames=10
    discard=1000
    for n_cmps in 1 10 100 1000 10000 100000; do
        fname="dtrj_delta_1_${delta}_beta_1_${beta}_tau0_10_${tau0}_shape_${n_cmps}_${n_frames}_discard_${discard}_seed_5462_4894_3496_8436"
        python3 generate_dtrj.py \
            --dtrj-out "${fname}.npz" \
            --param-out "${fname}_param.txt.gz" \
            --hist-plot "${fname}_drawn_lifetimes_hist.pdf" \
            --delta 1 "${delta}" \
            --beta 1 "${beta}" \
            --tau0 10 "${tau0}" \
            --shape "${n_cmps}" "${n_frames}" \
            --discard "${discard}" \
            --seed 5462489434968436
    done

Generate discrete trajectories with different :math:`\beta` values
whereas :math:`\delta` is fixed to unity => Stretched exponential
distribution.

.. code-block:: bash

    delta=1
    tau0=100
    n_cmps=100
    n_frames=100000
    discard=1000
    for beta in 0.25 0.50 1.00 2.00 4.00; do
        fname="dtrj_delta_1_${delta}_beta_1_${beta}_tau0_10_${tau0}_shape_${n_cmps}_${n_frames}_discard_${discard}_seed_5462_4894_3496_8436"
        python3 generate_dtrj.py \
            --dtrj-out "${fname}.npz" \
            --param-out "${fname}_param.txt.gz" \
            --hist-plot "${fname}_drawn_lifetimes_hist.pdf" \
            --delta 1 "${delta}" \
            --beta 1 "${beta}" \
            --tau0 "${tau0}" "${tau0}" \
            --shape "${n_cmps}" "${n_frames}" \
            --discard "${discard}" \
            --seed 5462489434968436
    done

Generate discrete trajectories with different :math:`\delta` values
whereas :math:`\beta` is fixed to unity => Gamma distribution.

.. code-block:: bash

    beta=1
    tau0=100
    n_cmps=100
    n_frames=100000
    discard=1000
    for delta in 0.25 0.50 1.00 2.00 4.00; do
        fname="dtrj_delta_1_${delta}_beta_1_${beta}_tau0_10_${tau0}_shape_${n_cmps}_${n_frames}_discard_${discard}_seed_5462_4894_3496_8436"
        python3 generate_dtrj.py \
            --dtrj-out "${fname}.npz" \
            --param-out "${fname}_param.txt.gz" \
            --hist-plot "${fname}_drawn_lifetimes_hist.pdf" \
            --delta 1 "${delta}" \
            --beta 1 "${beta}" \
            --tau0 "${tau0}" "${tau0}" \
            --shape "${n_cmps}" "${n_frames}" \
            --discard "${discard}" \
            --seed 5462489434968436
    done

Generate discrete trajectories with different :math:`\delta` values
whereas :math:`\beta` is set to :math:`\delta` => Weibull distribution.

.. code-block:: bash

    tau0=100
    n_cmps=100
    n_frames=100000
    discard=1000
    for delta in 0.25 0.50 1.00 2.00 4.00; do
        fname="dtrj_delta_1_${delta}_beta_1_${delta}_tau0_10_${tau0}_shape_${n_cmps}_${n_frames}_discard_${discard}_seed_5462_4894_3496_8436"
        python3 generate_dtrj.py \
            --dtrj-out "${fname}.npz" \
            --param-out "${fname}_param.txt.gz" \
            --hist-plot "${fname}_drawn_lifetimes_hist.pdf" \
            --delta 1 "${delta}" \
            --beta 1 "${delta}" \
            --tau0 "${tau0}" "${tau0}" \
            --shape "${n_cmps}" "${n_frames}" \
            --discard "${discard}" \
            --seed 5462489434968436
    done

"""


__author__ = "Andreas Thum"


# Standard libraries
import argparse
import os
import secrets
import sys
from datetime import datetime, timedelta

# Third-party libraries
import matplotlib.pyplot as plt
import numpy as np
import psutil
from matplotlib.backends.backend_pdf import PdfPages
from matplotlib.ticker import MaxNLocator
from scipy.special import gamma
from scipy.stats import gengamma

# First-party libraries
import mdtools as mdt
import mdtools.plot as mdtplt  # Load MDTools plot style  # noqa: F401


if __name__ == "__main__":  # noqa: C901
    timer_tot = datetime.now()
    proc = psutil.Process()
    proc.cpu_percent()  # Initiate monitoring of CPU usage.
    parser = argparse.ArgumentParser(
        description=(
            "Generate artificial discrete trajectories for testing purposes."
        )
    )
    parser.add_argument(
        "--dtrj-out",
        dest="DTRJ_OUT",
        type=str,
        required=True,
        help="Output filename for the generated discrete trajectory.",
    )
    parser.add_argument(
        "--param-out",
        dest="PARAM_OUT",
        type=str,
        required=False,
        default=None,
        help=(
            "Output filename containing the parameters used to create the"
            " discrete trajectory (optional)."
        ),
    )
    parser.add_argument(
        "--hist-plot",
        dest="HIST_PLOT",
        type=str,
        required=False,
        default=None,
        help=(
            "Output filename for a histogram plot of the drawn state lifetimes"
            " (optional)."
        ),
    )
    parser.add_argument(
        "--delta",
        dest="DELTA",
        type=float,
        nargs="+",
        required=False,
        default=[1, 1],
        help=(
            "delta values to use for the lifetime distribution of each state."
            "  Default: %(default)s."
        ),
    )
    parser.add_argument(
        "--beta",
        dest="BETA",
        type=float,
        nargs="+",
        required=False,
        default=[1, 1],
        help=(
            "beta values to use for the lifetime distribution of each state."
            "  Default: %(default)s."
        ),
    )
    parser.add_argument(
        "--tau0",
        dest="TAU0",
        type=float,
        nargs="+",
        required=False,
        default=[10, 100],
        help=(
            "tau0 values to use for the lifetime distribution of each state."
            "  Default: %(default)s."
        ),
    )
    parser.add_argument(
        "--shape",
        dest="SHAPE",
        type=int,
        nargs=2,
        required=False,
        default=[100, 100000],
        help=(
            "The shape of the generated discrete trajectory.  Default:"
            " %(default)s."
        ),
    )
    parser.add_argument(
        "--discard",
        dest="DISCARD",
        type=int,
        required=False,
        default=1000,
        help=(
            "Number of frames to discard at the beginning of the generated"
            " trajectory.  Default: %(default)s"
        ),
    )
    parser.add_argument(
        "--seed",
        dest="SEED",
        type=int,
        required=False,
        default=None,
        help=(
            "Seed to use for the random number generator.  Default:"
            " %(default)s"
        ),
    )
    args = parser.parse_args()
    print(mdt.rti.run_time_info_str())
    delta = np.asarray(args.DELTA)
    if np.any(delta < 0):
        raise ValueError("--delta ({}) must be positive".format(args.DELTA))
    if len(delta) < 2:
        raise ValueError(
            "--delta ({}) must get at least two values".format(args.DELTA)
        )
    beta = np.asarray(args.BETA)
    if np.any(beta < 0):
        raise ValueError("--beta ({}) must be positive".format(args.BETA))
    if beta.shape != delta.shape:
        raise ValueError(
            "--beta ({}) must get as many values as --delta"
            " ({})".format(args.BETA, args.DELTA)
        )
    tau0 = np.asarray(args.TAU0)
    if np.any(tau0 < 0):
        raise ValueError("--tau0 ({}) must be positive".format(args.TAU0))
    if tau0.shape != delta.shape:
        raise ValueError(
            "--tau0 ({}) must get as many values as --delta"
            " ({})".format(args.TAU0, args.DELTA)
        )
    shape = tuple(args.SHAPE)
    if np.any(np.less(shape, 1)):
        raise ValueError(
            "--shape ({}) must be greater than one".format(args.SHAPE)
        )
    if args.DISCARD < 0:
        raise ValueError(
            "--discard ({}) must not be negative".format(args.DISCARD)
        )
    if args.SEED is not None and args.SEED < 0:
        raise ValueError("--seed ({}) must not be negative".format(args.SEED))

    n_cmps, n_frames = shape
    n_frames_tot = n_frames + args.DISCARD
    n_states = len(delta)
    state_ix = np.arange(n_states, dtype=np.uint8)
    if args.HIST_PLOT is not None:
        lifetimes = [[] for six in state_ix]
    if args.SEED is None:
        args.SEED = secrets.randbits(128)
    rng = np.random.default_rng(args.SEED)
    # List of lifetime distributions for each state.
    lt_dists = [
        gengamma(a=delta[six] / beta[six], c=beta[six], loc=0, scale=tau0[six])
        for six in state_ix
    ]

    print("\n")
    print("Generating discrete trajectory...")
    timer = datetime.now()
    dtrj = [[] for cmp_ix in range(n_cmps)]
    # Loop over all compounds.
    for cmp_ix in range(n_cmps):
        n_frames_cmp = np.uint32(0)
        six_prev = rng.choice(state_ix)
        # Generate a discrete trajectory for the current compound.
        while n_frames_cmp < n_frames_tot:
            # Select a random state.  Thereby, ensure that the selected
            # state is different from the previously selected state.
            mask = state_ix != six_prev
            six = rng.choice(state_ix[mask])
            # Draw a random number from the lifetime distribution of the
            # selected state.
            lifetime = lt_dists[six].rvs(random_state=rng)
            lifetime = np.uint32(round(lifetime))
            if args.HIST_PLOT is not None:
                # Histogram of the *drawn* lifetimes (`lifetime`), not
                # the actually appended lifetimes (`n_frames_append`).
                lifetimes[six].append(lifetime)
            if lifetime == 0:
                # Discard the selected state and select another state.
                continue
            # Extend the trajectory with the selected state as many
            # frames as determined by the drawn lifetime.  If the
            # trajectory exceeds the pre-defined length, clip it.
            n_frames_append = min(lifetime, n_frames_tot - n_frames_cmp)
            if n_frames_append <= 0:
                raise ValueError(
                    "`n_frames_append` ({}) <= 0.  This should not have"
                    " happened".format(n_frames_append)
                )
            dtrj[cmp_ix].append(np.full(n_frames_append, six, dtype=np.uint8))
            # Increase frame counter.
            n_frames_cmp += n_frames_append
            # Store the selected state as previous state.
            six_prev = six
        dtrj[cmp_ix] = np.concatenate(dtrj[cmp_ix])
        # Discard the first `args.DISCARD` frames to emulate a
        # left-censoring of the state lifetimes.
        dtrj[cmp_ix] = dtrj[cmp_ix][args.DISCARD :]
        if len(dtrj[cmp_ix]) != n_frames:
            raise ValueError(
                "len(dtrj[{}]) ({}) != n_frames ({}).  This should not have"
                " happened".format(cmp_ix, len(dtrj[cmp_ix]), n_frames)
            )
    dtrj = np.asarray(dtrj)
    if dtrj.shape != shape:
        raise ValueError(
            "dtrj.shape ({}) != shape ({}).  This should not have"
            " happened".format(dtrj.shape, shape)
        )
    print("Elapsed time:         {}".format(datetime.now() - timer))
    print("Current memory usage: {:.2f} MiB".format(mdt.rti.mem_usage(proc)))

    print("\n")
    print("Creating output...")
    timer = datetime.now()

    mdt.fh.save_dtrj(args.DTRJ_OUT, dtrj)
    del dtrj
    print("Created {}".format(args.DTRJ_OUT))

    if args.PARAM_OUT is not None:
        data = np.column_stack([state_ix, delta, beta, tau0])
        header = (
            "Parameters used to generate an artificial discrete trajectory.\n"
            + "\n"
            + "State lifetimes were sampled from a generalized gamma\n"
            + "distribution:\n"
            + "  f(t) = 1/Gamma(delta/beta) * beta/tau0 *\n"
            + "         (t/tau0)^(delta-1) * exp[-(t/tau0)^beta]\n"
            + "where Gamma(z) is the gamma function.\n"
            + "\n"
            + "RNG Seed:            {:d}\n".format(args.SEED)
            + "Number of states:    {:d}\n".format(n_states)
            + "Number of compounds: {:d}\n".format(n_cmps)
            + "Number of frames:    {:d}\n".format(n_frames)
            + "Discarded frames:    {:d}\n".format(args.DISCARD)
            + "\n"
            + "\n"
            + "The columns contain:\n"
            + "  1 The state index (zero-based)\n"
            + "  2 delta values of each state\n"
            + "  3 beta values of each state\n"
            + "  4 tau0 values of each state\n"
            + "\n"
            + "{:>14d}".format(1)
        )
        for col in range(2, data.shape[-1] + 1):
            header += " {:>16d}".format(col)
        mdt.fh.savetxt(args.PARAM_OUT, data, header=header)
        print("Created {}".format(args.PARAM_OUT))

    if args.HIST_PLOT is not None:
        # Estimate common bin edges for the lifetime distributions of
        # all states.
        # Mean of the generalized gamma distribution.
        mean = tau0 * gamma((delta + 1) / beta) / gamma(delta / beta)
        bin_width = max(1, np.min(mean) // 2)
        lifetime_max = [np.max(lt) if len(lt) > 0 else 0 for lt in lifetimes]
        lifetime_max = max(1, np.max(lifetime_max))
        bins = np.arange(
            0, lifetime_max + bin_width, bin_width, dtype=np.uint32
        )
        bin_mids = bins[1:] - np.diff(bins) / 2

        alpha = 0.75
        cmap = plt.get_cmap()
        c_vals = np.arange(n_states)
        c_norm = n_states - 1
        c_vals_normed = c_vals / c_norm
        colors = cmap(c_vals_normed)

        mdt.fh.backup(args.HIST_PLOT)
        with PdfPages(args.HIST_PLOT) as pdf:
            for density in (False, True):
                fig, ax = plt.subplots(clear=True)
                for six, lt in enumerate(lifetimes):
                    hist, bin_edges, patches = ax.hist(
                        lt,
                        bins=bins,
                        density=density,
                        label="$%d$" % six,
                        color=colors[six],
                        alpha=0.5,
                        rasterized=True,
                    )
                    if density:
                        lines = ax.plot(
                            bin_mids,
                            lt_dists[six].pdf(bin_mids),
                            linestyle="dashed",
                            color=colors[six],
                            alpha=alpha,
                        )
                for six in state_ix:
                    # New loop to put the labels of `ax.axvline` at last
                    # in the legend.
                    ax.axvline(
                        mean[six],
                        linestyle="dotted",
                        color=colors[six],
                        alpha=alpha,
                    )
                ax.set(
                    xlabel="State Lifetime / Frames",
                    ylabel="Probability" if density else "Count",
                    xlim=(0, None),
                    ylim=(0, None),
                )
                ax.xaxis.set_major_locator(MaxNLocator(integer=True))
                ax.legend(
                    title="State",
                    loc="upper right",
                    ncol=1 + n_states // 6,
                    **mdtplt.LEGEND_KWARGS_XSMALL,
                )
                pdf.savefig()
                plt.close()
        print("Created {}".format(args.HIST_PLOT))

    print("Elapsed time:         {}".format(datetime.now() - timer))
    print("Current memory usage: {:.2f} MiB".format(mdt.rti.mem_usage(proc)))

    print("\n")
    print("{} done".format(os.path.basename(sys.argv[0])))
    print("Totally elapsed time: {}".format(datetime.now() - timer_tot))
    _cpu_time = timedelta(seconds=sum(proc.cpu_times()[:4]))
    print("CPU time:             {}".format(_cpu_time))
    print("CPU usage:            {:.2f} %".format(proc.cpu_percent()))
    print("Current memory usage: {:.2f} MiB".format(mdt.rti.mem_usage(proc)))
