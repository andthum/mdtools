#!/usr/bin/env python3

# This file is part of MDTools.
# Copyright (C) 2021-2023  The MDTools Development Team and all
# contributors listed in the file AUTHORS.rst
#
# MDTools is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or (at your
# option) any later version.
#
# MDTools is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License
# along with MDTools.  If not, see <http://www.gnu.org/licenses/>.


r"""
Generate an artificial discrete trajectory with a given number of states
with a given lifetime distribution.

For the lifetime distribution you can choose between the generalized
gamma distribution

.. math::

    f(t) =
    \frac{1}{\Gamma\left( \frac{\delta}{\beta} \right)}
    \frac{\beta}{\tau_0}
    \left( \frac{t}{\tau_0} \right)^{\delta - 1}
    \exp{\left[ \left( -\frac{t}{\tau_0} \right)^\beta \right]}

with :math:`\Gamma(z)` being the gamma function, and the Burr Type XII
distribution

.. math::

    f(t) =
    \frac{\beta \delta}{\tau_0}
    \left( \frac{t}{\tau_0} \right)^{\beta - 1}
    \frac{
        1
    }{
        \left[
            1 + \left( \frac{t}{\tau_0} \right)^\beta
        \right]^{\delta - 1}
    }

Note that the n-th raw moment of the Burr Type XII distribution only
exists if :math:`n < \beta \delta`.

Options
-------
--dtrj-out
    Output filename for the generated discrete trajectory.   The
    discrete trajectory is written as binary :file:`dtrj.npy` file in a
    compressed |npz_archive| of the given filename.  The discrete
    trajectory is stored as :class:`numpy.ndarray` of dtype
    :attr:`numpy.uint8` and shape ``(n, f)``, where ``n`` is the number
    of compounds and ``f`` is the number of frames.  The elements of the
    discrete trajectory are the states in which a given compound resides
    at a given frame.
--param-out
    Output filename containing the parameters used to create the
    discrete trajectory (optional).
--hist-plot
    Output filename for a histogram plot of the drawn state lifetimes
    (optional).  The histogram shows the lifetimes that were drawn from
    the exponential distribution for each state.
--dist
    {'generalized_gamma', 'burr12'}

    Which distribution to use as lifetime distribution.
--beta
    :math:`\beta` values (shape parameter) to use for the lifetime
    distribution of each state.  The number of given :math:`\beta`
    values determines the number of different states in the generated
    discrete trajectory.  States are sequentially numbered starting from
    zero.  At least two values must be given.  Default: ``[1, 1]``.
--delta
    :math:`\delta` values (shape parameter) to use for the lifetime
    distribution of each state.  The number of given :math:`\delta`
    values must match the number of given :math:`\beta` values.
    Default: ``[1, 1]``.
--tau0
    :math:`\tau_0` values (scale parameter) to use for the lifetime
    distribution of each state.  The number of given :math:`\tau_0`
    values must match the number of given :math:`\beta` values.
    Default: ``[10, 100]``.
--shape
    The shape ``(n, f)`` of the generated discrete trajectory.  Default:
    ``(100, 100000)``.
--discard
    Number of frames to discard at the beginning of the generated
    trajectory.  Set to something greater than zero to emulate a
    left-censoring of the state lifetimes or a discarded equilibration
    period.  Note that the generated trajectory will always have the
    shape given with \--shape.  Default: ``1000``.
--seed
    Seed to use for the random number generator.  If ``None``, a random
    seed will be generated by calling ``secrets.randbits(128)``.
    Default: ``None``.
--adjacent
    If given, the next state must be a neighbor of the previous state.
    Otherwise, the next state is selected fully randomly with the only
    conditions that it must be different from the previous state.

See Also
--------
:mod:`misc.dtrj_lifetimes.compare_dtrj_lifetime_methods` :
    Compare state lifetimes calculated from a discrete trajectory using
    different methods
:mod:`misc.dtrj_lifetimes.plot_lifetime_distributions` :
    Plot the PDF, CDF, Survival and Hazard function of the generalized
    gamma distribution or the Burr Type XII distribution for a given set
    of shape and scale parameters.

Notes
-----
The discrete trajectory is generated in the following way:

    1. Select a random state.  Thereby, ensure that the selected state
       is different from the previously selected state.  If \--adjacent
       is given, the next state must be a neighbor of the previous
       state.
    2. Draw a random number from the selected lifetime distribution.
       The drawn number is rounded to the nearest integer.  If the drawn
       number is zero, the selected state is discarded and the loop
       restarts at Step 1.
    3. Extend the discrete trajectory with the selected state by as many
       frames as determined by the drawn lifetime.  Redo Steps 1-3 until
       the trajectory has (at least) the desired length.
    4. Discard a given number of frames (\--discard) at the beginning of
       the trajectory and clip the trajectory at the end such that it
       has the number of frames given with \--shape.

The generalized gamma distribution reduces to many other distributions,
e.g. to the

    * Stretched exponential distribution if :math:`\delta` is unity.
    * Weibull distribution if :math:`\delta` equals :math:`\beta`.
    * Gamma distribution if :math:`\beta` is unity.
    * Chi distribution if :math:`\beta` is two and :math:`\tau` is
      :math:`\sqrt{2}`.
    * Exponential distribution if both :math:`\delta` and :math:`\beta`
      are unity.

The Burr Type XII distribution reduces to the

    * Log-logistic distribution if :math:`\delta` is unity.
    * Lomax distribution if :math:`\beta` is unity.

Examples
--------
Generalized Gamma Distribution

    **Dependence on trajectory size**

    Generate discrete trajectories with different number of frames.
    :math:`\beta = \delta = 1` => Exponential distribution.

    .. code-block:: bash

        beta=1
        delta=1
        tau0=100
        n_cmps=1
        discard=1000
        for n_frames in 10 100 1000 10000 100000; do
            fname="dtrj_gengamma_beta_1_${beta}_delta_1_${delta}_tau0_10_${tau0}_shape_${n_cmps}_${n_frames}_discard_${discard}_seed_5462_4894_3496_8436"
            python3 generate_dtrj.py \
                --dtrj-out "${fname}.npz" \
                --param-out "${fname}_param.txt.gz" \
                --hist-plot "${fname}_drawn_lifetimes_hist.pdf" \
                --dist generalized_gamma \
                --beta 1 "${beta}" \
                --delta 1 "${delta}" \
                --tau0 10 "${tau0}" \
                --shape "${n_cmps}" "${n_frames}" \
                --discard "${discard}" \
                --seed 5462489434968436
        done

    Generate discrete trajectories with different number of compounds.
    :math:`\beta = \delta = 1` => Exponential distribution.

    .. code-block:: bash

        beta=1
        delta=1
        tau0=100
        n_frames=10
        discard=1000
        for n_cmps in 1 10 100 1000 10000 100000; do
            fname="dtrj_gengamma_beta_1_${beta}_delta_1_${delta}_tau0_10_${tau0}_shape_${n_cmps}_${n_frames}_discard_${discard}_seed_5462_4894_3496_8436"
            python3 generate_dtrj.py \
                --dtrj-out "${fname}.npz" \
                --param-out "${fname}_param.txt.gz" \
                --hist-plot "${fname}_drawn_lifetimes_hist.pdf" \
                --dist generalized_gamma \
                --beta 1 "${beta}" \
                --delta 1 "${delta}" \
                --tau0 10 "${tau0}" \
                --shape "${n_cmps}" "${n_frames}" \
                --discard "${discard}" \
                --seed 5462489434968436
        done

    **Dependence on lifetime distribution**

    Generate discrete trajectories with different :math:`\tau_0` values
    whereas :math:`\beta = \delta = 1` => Exponential distribution.

    .. code-block:: bash

        beta=1
        delta=1
        n_cmps=100
        n_frames=100000
        discard=1000
        for tau0 in 25 50 100 200 400; do
            fname="dtrj_gengamma_beta_1_${beta}_delta_1_${delta}_tau0_10_${tau0}_shape_${n_cmps}_${n_frames}_discard_${discard}_seed_5462_4894_3496_8436"
            python3 generate_dtrj.py \
                --dtrj-out "${fname}.npz" \
                --param-out "${fname}_param.txt.gz" \
                --hist-plot "${fname}_drawn_lifetimes_hist.pdf" \
                --dist generalized_gamma \
                --beta 1 "${beta}" \
                --delta 1 "${delta}" \
                --tau0 10 "${tau0}" \
                --shape "${n_cmps}" "${n_frames}" \
                --discard "${discard}" \
                --seed 5462489434968436
        done

    Generate discrete trajectories with different :math:`\beta` values
    whereas :math:`\delta` is fixed to unity => Stretched exponential
    distribution.

    .. code-block:: bash

        delta=1
        tau0=100
        n_cmps=100
        n_frames=100000
        discard=1000
        for beta in 0.25 0.50 1.00 2.00 4.00; do
            fname="dtrj_gengamma_beta_1_${beta}_delta_1_${delta}_tau0_${tau0}_${tau0}_shape_${n_cmps}_${n_frames}_discard_${discard}_seed_5462_4894_3496_8436"
            python3 generate_dtrj.py \
                --dtrj-out "${fname}.npz" \
                --param-out "${fname}_param.txt.gz" \
                --hist-plot "${fname}_drawn_lifetimes_hist.pdf" \
                --dist generalized_gamma \
                --beta 1 "${beta}" \
                --delta 1 "${delta}" \
                --tau0 "${tau0}" "${tau0}" \
                --shape "${n_cmps}" "${n_frames}" \
                --discard "${discard}" \
                --seed 5462489434968436
        done

    Generate discrete trajectories with different :math:`\beta` values
    whereas :math:`\delta` is set to :math:`\beta` => Weibull
    distribution.

    .. code-block:: bash

        tau0=100
        n_cmps=100
        n_frames=100000
        discard=1000
        for beta in 0.25 0.50 1.00 2.00 4.00; do
            fname="dtrj_gengamma_beta_1_${beta}_delta_1_${beta}_tau0_${tau0}_${tau0}_shape_${n_cmps}_${n_frames}_discard_${discard}_seed_5462_4894_3496_8436"
            python3 generate_dtrj.py \
                --dtrj-out "${fname}.npz" \
                --param-out "${fname}_param.txt.gz" \
                --hist-plot "${fname}_drawn_lifetimes_hist.pdf" \
                --dist generalized_gamma \
                --beta 1 "${beta}" \
                --delta 1 "${beta}" \
                --tau0 "${tau0}" "${tau0}" \
                --shape "${n_cmps}" "${n_frames}" \
                --discard "${discard}" \
                --seed 5462489434968436
        done

    Generate discrete trajectories with different :math:`\delta` values
    whereas :math:`\beta` is fixed to unity => Gamma distribution.

    .. code-block:: bash

        beta=1
        tau0=100
        n_cmps=100
        n_frames=100000
        discard=1000
        for delta in 0.25 0.50 1.00 2.00 4.00; do
            fname="dtrj_gengamma_beta_1_${beta}_delta_1_${delta}_tau0_${tau0}_${tau0}_shape_${n_cmps}_${n_frames}_discard_${discard}_seed_5462_4894_3496_8436"
            python3 generate_dtrj.py \
                --dtrj-out "${fname}.npz" \
                --param-out "${fname}_param.txt.gz" \
                --hist-plot "${fname}_drawn_lifetimes_hist.pdf" \
                --dist generalized_gamma \
                --beta 1 "${beta}" \
                --delta 1 "${delta}" \
                --tau0 "${tau0}" "${tau0}" \
                --shape "${n_cmps}" "${n_frames}" \
                --discard "${discard}" \
                --seed 5462489434968436
        done

    Generate discrete trajectories with different :math:`\delta` values
    whereas :math:`\beta` is fixed to two and :math:`\tau_0` is fixed to
    :math:`\sqrt{2}` => Chi distribution.

    .. code-block:: bash

        beta=2
        tau0_long=$(echo "scale=30; sqrt(2)" | bc)
        tau0="${tau0_long::4}"  # Only two decimal places.
        n_cmps=100
        n_frames=100000
        discard=1000
        for delta in 0.25 0.50 1.00 2.00 4.00 8.00 16.00; do
            fname="dtrj_gengamma_beta_1_${beta}_delta_1_${delta}_tau0_${tau0}_${tau0}_shape_${n_cmps}_${n_frames}_discard_${discard}_seed_5462_4894_3496_8436"
            python3 generate_dtrj.py \
                --dtrj-out "${fname}.npz" \
                --param-out "${fname}_param.txt.gz" \
                --hist-plot "${fname}_drawn_lifetimes_hist.pdf" \
                --dist generalized_gamma \
                --beta 1 "${beta}" \
                --delta 1 "${delta}" \
                --tau0 "${tau0_long}" "${tau0_long}" \
                --shape "${n_cmps}" "${n_frames}" \
                --discard "${discard}" \
                --seed 5462489434968436
        done

Burr Type XII Distribution

    Generate discrete trajectories with different :math:`\beta` values
    whereas :math:`\delta` is fixed to unity => Log-logistic
    distribution.

    .. code-block:: bash

        delta=1
        tau0=100
        n_cmps=100
        n_frames=100000
        discard=1000
        for beta in 2.00 4.00 8.00 16.00; do
            fname="dtrj_burr12_beta_4_${beta}_delta_${delta}_${delta}_tau0_${tau0}_${tau0}_shape_${n_cmps}_${n_frames}_discard_${discard}_seed_5462_4894_3496_8436"
            python3 generate_dtrj.py \
                --dtrj-out "${fname}.npz" \
                --param-out "${fname}_param.txt.gz" \
                --hist-plot "${fname}_drawn_lifetimes_hist.pdf" \
                --dist burr12 \
                --beta 4 "${beta}" \
                --delta "${delta}" "${delta}" \
                --tau0 "${tau0}" "${tau0}" \
                --shape "${n_cmps}" "${n_frames}" \
                --discard "${discard}" \
                --seed 5462489434968436
        done

    Generate discrete trajectories with different :math:`\delta` values
    whereas :math:`\beta` is fixed to unity => Lomax distribution.

    .. code-block:: bash

        beta=1
        tau0=100
        n_cmps=100
        n_frames=100000
        discard=1000
        for delta in 2.00 4.00 8.00 16.00; do
            fname="dtrj_burr12_beta_${beta}_${beta}_delta_4_${delta}_tau0_${tau0}_${tau0}_shape_${n_cmps}_${n_frames}_discard_${discard}_seed_5462_4894_3496_8436"
            python3 generate_dtrj.py \
                --dtrj-out "${fname}.npz" \
                --param-out "${fname}_param.txt.gz" \
                --hist-plot "${fname}_drawn_lifetimes_hist.pdf" \
                --dist burr12 \
                --beta "${beta}" "${beta}" \
                --delta 4 "${delta}" \
                --tau0 "${tau0}" "${tau0}" \
                --shape "${n_cmps}" "${n_frames}" \
                --discard "${discard}" \
                --seed 5462489434968436
        done

"""


__author__ = "Andreas Thum"


# Standard libraries
import argparse
import os
import secrets
import sys
from datetime import datetime, timedelta

# Third-party libraries
import matplotlib.pyplot as plt
import numpy as np
import psutil
from matplotlib.backends.backend_pdf import PdfPages
from matplotlib.ticker import MaxNLocator
from scipy.stats import burr12, gengamma

# First-party libraries
import mdtools as mdt
import mdtools.plot as mdtplt  # Load MDTools plot style  # noqa: F401


if __name__ == "__main__":  # noqa: C901
    timer_tot = datetime.now()
    proc = psutil.Process()
    proc.cpu_percent()  # Initiate monitoring of CPU usage.
    parser = argparse.ArgumentParser(
        description=(
            "Generate an artificial discrete trajectory with a given number of"
            " states with a given lifetime distribution."
        )
    )
    parser.add_argument(
        "--dtrj-out",
        dest="DTRJ_OUT",
        type=str,
        required=True,
        help="Output filename for the generated discrete trajectory.",
    )
    parser.add_argument(
        "--param-out",
        dest="PARAM_OUT",
        type=str,
        required=False,
        default=None,
        help=(
            "Output filename containing the parameters used to create the"
            " discrete trajectory (optional)."
        ),
    )
    parser.add_argument(
        "--hist-plot",
        dest="HIST_PLOT",
        type=str,
        required=False,
        default=None,
        help=(
            "Output filename for a histogram plot of the drawn state lifetimes"
            " (optional)."
        ),
    )
    parser.add_argument(
        "--dist",
        dest="DIST",
        type=str,
        choices=("generalized_gamma", "burr12"),
        required=False,
        default="generalized_gamma",
        help="Which distribution to use as lifetime distribution",
    )
    parser.add_argument(
        "--beta",
        dest="BETA",
        type=float,
        nargs="+",
        required=False,
        default=[1, 1],
        help=(
            "beta values (shape parameters) to use for the lifetime"
            " distribution of each state.  Default: %(default)s."
        ),
    )
    parser.add_argument(
        "--delta",
        dest="DELTA",
        type=float,
        nargs="+",
        required=False,
        default=[1, 1],
        help=(
            "delta values (shape parameters) to use for the lifetime"
            " distribution of each state.  Default: %(default)s."
        ),
    )
    parser.add_argument(
        "--tau0",
        dest="TAU0",
        type=float,
        nargs="+",
        required=False,
        default=[10, 100],
        help=(
            "tau0 values (scale parameters) to use for the lifetime"
            " distribution of each state.  Default: %(default)s."
        ),
    )
    parser.add_argument(
        "--shape",
        dest="SHAPE",
        type=int,
        nargs=2,
        required=False,
        default=[100, 100000],
        help=(
            "The shape of the generated discrete trajectory.  Default:"
            " %(default)s."
        ),
    )
    parser.add_argument(
        "--discard",
        dest="DISCARD",
        type=int,
        required=False,
        default=1000,
        help=(
            "Number of frames to discard at the beginning of the generated"
            " trajectory.  Default: %(default)s"
        ),
    )
    parser.add_argument(
        "--seed",
        dest="SEED",
        type=int,
        required=False,
        default=None,
        help=(
            "Seed to use for the random number generator.  Default:"
            " %(default)s"
        ),
    )
    parser.add_argument(
        "--adjacent",
        dest="ADJACENT",
        required=False,
        default=False,
        action="store_true",
        help=(
            "If given, the next state must be a neighbor of the previous"
            " state."
        ),
    )
    args = parser.parse_args()
    print(mdt.rti.run_time_info_str())
    beta = np.asarray(args.BETA)
    if np.any(beta < 0):
        raise ValueError("--beta ({}) must be positive".format(args.BETA))
    if len(beta) < 2:
        raise ValueError(
            "--beta ({}) must get at least two values".format(args.BETA)
        )
    delta = np.asarray(args.DELTA)
    if np.any(delta < 0):
        raise ValueError("--delta ({}) must be positive".format(args.DELTA))
    if delta.shape != beta.shape:
        raise ValueError(
            "--delta ({}) must get as many values as --beta"
            " ({})".format(args.DELTA, args.BETA)
        )
    tau0 = np.asarray(args.TAU0)
    if np.any(tau0 < 0):
        raise ValueError("--tau0 ({}) must be positive".format(args.TAU0))
    if tau0.shape != beta.shape:
        raise ValueError(
            "--tau0 ({}) must get as many values as --beta"
            " ({})".format(args.TAU0, args.BETA)
        )
    shape = tuple(args.SHAPE)
    if np.any(np.less(shape, 1)):
        raise ValueError(
            "--shape ({}) must be greater than one".format(args.SHAPE)
        )
    if args.DISCARD < 0:
        raise ValueError(
            "--discard ({}) must not be negative".format(args.DISCARD)
        )
    if args.SEED is not None and args.SEED < 0:
        raise ValueError("--seed ({}) must not be negative".format(args.SEED))

    n_cmps, n_frames = shape
    n_frames_tot = n_frames + args.DISCARD
    n_states = len(beta)
    state_ix = np.arange(n_states, dtype=np.uint8)
    if args.SEED is None:
        args.SEED = secrets.randbits(128)
    rng = np.random.default_rng(args.SEED)
    # List of lifetime distributions for each state.
    if args.DIST == "generalized_gamma":
        lt_dists = [
            gengamma(
                a=delta[six] / beta[six], c=beta[six], loc=0, scale=tau0[six]
            )
            for six in state_ix
        ]
    elif args.DIST == "burr12":
        lt_dists = [
            burr12(c=beta[six], d=delta[six], loc=0, scale=tau0[six])
            for six in state_ix
        ]
    else:
        raise ValueError("Invalid --dist ({})".format(args.DIST))
    # List of drawn lifetimes for each state.
    lts_drw = [[] for six in state_ix]
    # List of uncensored lifetimes for each state.
    lts_unc = [[] for six in state_ix]
    # List of censored lifetimes for each state.
    lts_cen = [[] for six in state_ix]

    print("\n")
    print("Generating discrete trajectory...")
    timer = datetime.now()
    dtrj = [[] for cmp_ix in range(n_cmps)]
    # Loop over all compounds.
    for cmp_ix in range(n_cmps):
        n_frames_cmp = np.uint32(0)
        six_prev = rng.choice(state_ix)
        # Generate a discrete trajectory for the current compound.
        while n_frames_cmp < n_frames_tot:
            # Randomly select the next state.
            if args.ADJACENT:
                # The next state must be a neighbor of the previously
                # selected state.
                available_states = [
                    six_prev - 1 if six_prev > state_ix[0] else six_prev + 1,
                    six_prev + 1 if six_prev < state_ix[-1] else six_prev - 1,
                ]
            else:
                # The next state must be different from the previously
                # selected state.  No other conditions.
                mask = state_ix != six_prev
                available_states = state_ix[mask]
            six = rng.choice(available_states)
            # Draw a random number from the lifetime distribution of the
            # selected state.
            lt_drw = lt_dists[six].rvs(random_state=rng)
            lt_drw = np.uint32(round(lt_drw))
            if lt_drw == 0:
                # Discard the selected state and select another state.
                continue
            lts_drw[six].append(lt_drw)
            if n_frames_cmp + lt_drw > args.DISCARD:
                # If the drawn lifetime lies at least partially within
                # the censored trajectory, append it to the list of
                # uncensored lifetimes.
                lts_unc[six].append(lt_drw)
            # Extend the trajectory with the selected state by as many
            # frames as determined by the drawn lifetime.  If the
            # trajectory exceeds the pre-defined length, clip it.
            n_frames_append = min(lt_drw, n_frames_tot - n_frames_cmp)
            if n_frames_append <= 0:
                raise ValueError(
                    "`n_frames_append` ({}) <= 0.  This should not have"
                    " happened".format(n_frames_append)
                )
            dtrj[cmp_ix].append(np.full(n_frames_append, six, dtype=np.uint8))
            if n_frames_cmp + n_frames_append > args.DISCARD:
                # Calculate the censored lifetime from
                # `n_frames_append`.  The maximum possible value for
                # `n_frames_append` is
                # ``n_frames_tot = n_frames + args.DISCARD``.  However,
                # the maximum possible value for `lt_cen` is `n_frames`.
                lt_cen = min(n_frames_append, n_frames)
                lts_cen[six].append(lt_cen)
            # Increase the frame counter.
            n_frames_cmp += n_frames_append
            # Store the selected state as previous state.
            six_prev = six
        dtrj[cmp_ix] = np.concatenate(dtrj[cmp_ix])
        # Discard the first `args.DISCARD` frames to emulate a
        # left-censoring of the state lifetimes.
        dtrj[cmp_ix] = dtrj[cmp_ix][args.DISCARD :]
        if len(dtrj[cmp_ix]) != n_frames:
            raise ValueError(
                "len(dtrj[{}]) ({}) != n_frames ({}).  This should not have"
                " happened".format(cmp_ix, len(dtrj[cmp_ix]), n_frames)
            )
    dtrj = np.asarray(dtrj)
    if dtrj.shape != shape:
        raise ValueError(
            "dtrj.shape ({}) != shape ({}).  This should not have"
            " happened".format(dtrj.shape, shape)
        )
    lts_drw = [np.array(lts) for lts in lts_drw]
    lts_unc = [np.array(lts) for lts in lts_unc]
    lts_cen = [np.array(lts) for lts in lts_cen]
    for lts in lts_cen:
        if np.any(lts > n_frames):
            raise ValueError(
                "any(lts_cen) > n_frames ({}).  This should not have"
                " happened".format(n_frames)
            )
    print("Elapsed time:         {}".format(datetime.now() - timer))
    print("Current memory usage: {:.2f} MiB".format(mdt.rti.mem_usage(proc)))

    print("\n")
    print("Creating output...")
    timer = datetime.now()

    mdt.fh.save_dtrj(args.DTRJ_OUT, dtrj)
    del dtrj
    print("Created {}".format(args.DTRJ_OUT))

    if args.PARAM_OUT is not None:
        lt_dists_mom1 = np.array([dist.moment(order=1) for dist in lt_dists])
        lt_dists_mom2 = np.array([dist.moment(order=2) for dist in lt_dists])
        lts_drw_mom1 = np.array(
            [np.mean(lts) if len(lts) > 0 else np.nan for lts in lts_drw]
        )
        lts_drw_mom2 = np.array(
            [np.mean(lts**2) if len(lts) > 0 else np.nan for lts in lts_drw]
        )
        lts_unc_mom1 = np.array(
            [np.mean(lts) if len(lts) > 0 else np.nan for lts in lts_unc]
        )
        lts_unc_mom2 = np.array(
            [np.mean(lts**2) if len(lts) > 0 else np.nan for lts in lts_unc]
        )
        lts_cen_mom1 = np.array(
            [np.mean(lts) if len(lts) > 0 else np.nan for lts in lts_cen]
        )
        lts_cen_mom2 = np.array(
            [np.mean(lts**2) if len(lts) > 0 else np.nan for lts in lts_cen]
        )
        if np.any(lts_cen_mom1 > lts_unc_mom1):
            raise ValueError(
                "`lts_cen_mom1` ({}) > `lts_unc_mom1`"
                " ({})".format(lts_cen_mom1, lts_unc_mom1)
            )
        data = np.column_stack(
            [
                state_ix,  # 1
                beta,  # 2
                delta,  # 3
                tau0,  # 4
                lt_dists_mom1,  # 5
                lt_dists_mom2,  # 6
                lts_drw_mom1,  # 7
                lts_drw_mom2,  # 8
                lts_unc_mom1,  # 9
                lts_unc_mom2,  # 10
                lts_cen_mom1,  # 11
                lts_cen_mom2,  # 12
            ]
        )
        header = (
            "Parameters used to generate the artificial discrete trajectory\n"
            + "{:s}\n".format(args.DTRJ_OUT)
            + "\n"
        )
        if args.DIST == "generalized_gamma":
            header += (
                "State lifetimes were sampled from a generalized gamma\n"
                + "distribution:\n"
                + "  f(t) = 1/Gamma(delta/beta) * beta/tau0 *\n"
                + "         (t/tau0)^(delta-1) * exp[-(t/tau0)^beta]\n"
                + "where Gamma(z) is the gamma function.\n"
                + "\n"
            )
        elif args.DIST == "burr12":
            header += (
                "State lifetimes were sampled from a Burr Type XII\n"
                + "distribution:\n"
                + "  f(t) = beta*delta/tau0 * (t/tau0)^beta *\n"
                + "         1 / [1 + (t/tau0)^beta]^(delta-1)\n"
                + "\n"
            )
        header += (
            "Lifetime dist.:      {:s}\n".format(args.DIST)
            + "RNG seed:            {:d}\n".format(args.SEED)
            + "Number of states:    {:d}\n".format(n_states)
            + "Number of compounds: {:d}\n".format(n_cmps)
            + "Number of frames:    {:d}\n".format(n_frames)
            + "Discarded frames:    {:d}\n".format(args.DISCARD)
            + "Adjacent:            {}\n".format(args.ADJACENT)
            + "\n"
            + "\n"
            + "The columns contain:\n"
            + "  1 State index (zero-based)\n"
            + "  2 Shape parameter beta of the distribution\n"
            + "  3 Shape parameter delta of the distribution\n"
            + "  4 Scale parameter tau0 of the distribution\n"
            + "  5 1st moment of the distribution <t_dst> / frames\n"
            + "  6 2nd moment of the distribution <t_dst^2> / frames^2\n"
            + "  7 1st moment of the drawn lifetimes <t_drw> / frames\n"
            + "  8 2nd moment of the drawn lifetimes <t_drw^2> / frames^2\n"
            + "  9 1st moment of the uncensored lifetimes <t_unc> / frames\n"
            + " 10 2nd moment of the uncensored lifetimes <t_unc^2> /"
            + " frames^2\n"
            + " 11 1st moment of the censored lifetimes <t_cen> / frames\n"
            + " 12 2nd moment of the censored lifetimes <t_cen^2> / frames^2\n"
            + "\n"
            + "{:>14d}".format(1)
        )
        for col in range(2, data.shape[-1] + 1):
            header += " {:>16d}".format(col)
        mdt.fh.savetxt(args.PARAM_OUT, data, header=header)
        print("Created {}".format(args.PARAM_OUT))

    if args.HIST_PLOT is not None:
        # Estimate common bin edges for the lifetime distributions of
        # all states.
        bin_width = max(1, np.min(lt_dists_mom1) // 2)
        lt_max = [np.max(lts) if len(lts) > 0 else 0 for lts in lts_drw]
        lt_max = max(1, np.max(lt_max))
        bins = np.arange(0, lt_max + bin_width, bin_width, dtype=np.uint32)
        bin_mids = bins[1:] - np.diff(bins) / 2

        xlabel = "State Lifetime / Frames"
        ylabel = "Probability"
        xlim = (0, None)
        ylim = (0, None)
        legend_loc = "upper right"
        legend_ncol = 2 + n_states // 7

        alpha_hist = 0.5
        alpha_lines = 0.75
        cmap = plt.get_cmap()
        c_vals = np.arange(n_states)
        c_norm = n_states - 1
        c_vals_normed = c_vals / c_norm
        colors = cmap(c_vals_normed)

        mdt.fh.backup(args.HIST_PLOT)
        with PdfPages(args.HIST_PLOT) as pdf:
            # Histogram of drawn lifetimes.
            fig, ax = plt.subplots(clear=True)
            for six, lts in enumerate(lts_drw):
                hist, bin_edges, patches = ax.hist(
                    lts,
                    bins=bins,
                    density=True,
                    label=r"State $%d$" % six,
                    color=colors[six],
                    alpha=alpha_hist,
                    rasterized=True,
                )
                lines = ax.plot(
                    bin_mids,
                    lt_dists[six].pdf(bin_mids),
                    linestyle="solid",
                    color=colors[six],
                    alpha=alpha_lines,
                )
                ax.axvline(
                    lt_dists_mom1[six],
                    label=(
                        r"$\langle t_{dist} \rangle$"
                        if six == n_states - 1
                        else None
                    ),
                    linestyle="dashed",
                    color=colors[six],
                    alpha=alpha_lines,
                )
                ax.axvline(
                    lts_drw_mom1[six],
                    label=(
                        r"$\langle t_{drawn} \rangle$"
                        if six == n_states - 1
                        else None
                    ),
                    linestyle="dotted",
                    color=colors[six],
                    alpha=alpha_lines,
                )
            ax.set(xlabel=xlabel, ylabel=ylabel, xlim=xlim, ylim=ylim)
            ax.xaxis.set_major_locator(MaxNLocator(integer=True))
            legend = ax.legend(
                title="Drawn Lifetimes",
                loc=legend_loc,
                ncol=legend_ncol,
                **mdtplt.LEGEND_KWARGS_XSMALL,
            )
            legend.get_title().set_multialignment("center")
            pdf.savefig()
            plt.close()

            # Histogram of uncensored lifetimes.
            fig, ax = plt.subplots(clear=True)
            for six, lts in enumerate(lts_unc):
                hist, bin_edges, patches = ax.hist(
                    lts,
                    bins=bins,
                    density=True,
                    label=r"State $%d$" % six,
                    color=colors[six],
                    alpha=alpha_hist,
                    rasterized=True,
                )
                lines = ax.plot(
                    bin_mids,
                    lt_dists[six].pdf(bin_mids),
                    linestyle="solid",
                    color=colors[six],
                    alpha=alpha_lines,
                )
                ax.axvline(
                    lt_dists_mom1[six],
                    label=(
                        r"$\langle t_{dist} \rangle$"
                        if six == n_states - 1
                        else None
                    ),
                    linestyle="dashed",
                    color=colors[six],
                    alpha=alpha_lines,
                )
                ax.axvline(
                    lts_unc_mom1[six],
                    label=(
                        r"$\langle t_{uncens} \rangle$"
                        if six == n_states - 1
                        else None
                    ),
                    linestyle="dotted",
                    color=colors[six],
                    alpha=0.8,
                )
            ax.set(xlabel=xlabel, ylabel=ylabel, xlim=xlim, ylim=ylim)
            ax.xaxis.set_major_locator(MaxNLocator(integer=True))
            legend = ax.legend(
                title="Uncensored Lifetimes",
                loc=legend_loc,
                ncol=legend_ncol,
                **mdtplt.LEGEND_KWARGS_XSMALL,
            )
            legend.get_title().set_multialignment("center")
            pdf.savefig()
            plt.close()

            # Histogram of uncensored lifetimes.
            fig, ax = plt.subplots(clear=True)
            for six, lts in enumerate(lts_cen):
                hist, bin_edges, patches = ax.hist(
                    lts,
                    bins=bins,
                    density=True,
                    label=r"State $%d$" % six,
                    color=colors[six],
                    alpha=alpha_hist,
                    rasterized=True,
                )
                lines = ax.plot(
                    bin_mids,
                    lt_dists[six].pdf(bin_mids),
                    linestyle="solid",
                    color=colors[six],
                    alpha=alpha_lines,
                )
                ax.axvline(
                    lt_dists_mom1[six],
                    label=(
                        r"$\langle t_{dist} \rangle$"
                        if six == n_states - 1
                        else None
                    ),
                    linestyle="dashed",
                    color=colors[six],
                    alpha=alpha_lines,
                )
                ax.axvline(
                    lts_cen_mom1[six],
                    label=(
                        r"$\langle t_{cens} \rangle$"
                        if six == n_states - 1
                        else None
                    ),
                    linestyle=":",
                    color=colors[six],
                    alpha=0.9,
                )
            ax.set(xlabel=xlabel, ylabel=ylabel, xlim=xlim, ylim=ylim)
            ax.xaxis.set_major_locator(MaxNLocator(integer=True))
            legend = ax.legend(
                title="Censored Lifetimes",
                loc=legend_loc,
                ncol=legend_ncol,
                **mdtplt.LEGEND_KWARGS_XSMALL,
            )
            legend.get_title().set_multialignment("center")
            pdf.savefig()
            plt.close()
        print("Created {}".format(args.HIST_PLOT))

    print("Elapsed time:         {}".format(datetime.now() - timer))
    print("Current memory usage: {:.2f} MiB".format(mdt.rti.mem_usage(proc)))

    print("\n")
    print("{} done".format(os.path.basename(sys.argv[0])))
    print("Totally elapsed time: {}".format(datetime.now() - timer_tot))
    _cpu_time = timedelta(seconds=sum(proc.cpu_times()[:4]))
    print("CPU time:             {}".format(_cpu_time))
    print("CPU usage:            {:.2f} %".format(proc.cpu_percent()))
    print("Current memory usage: {:.2f} MiB".format(mdt.rti.mem_usage(proc)))
