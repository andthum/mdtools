#!/usr/bin/env python3

# This file is part of MDTools.
# Copyright (C) 2021-2023  The MDTools Development Team and all
# contributors listed in the file AUTHORS.rst
#
# MDTools is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or (at your
# option) any later version.
#
# MDTools is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License
# along with MDTools.  If not, see <http://www.gnu.org/licenses/>.


r"""
Generate an artificial discrete trajectory with a given number of states
with a given lifetime distribution.

The lifetime distribution follows the gamma distribution

.. math::

    p(x) = x^{k-1} \frac{e^{-x / \theta}}{\theta^k \Gamma(k)}

with :math:`\Gamma(z)` being the gamma function.  If :math:`k` is unity,
the gamma distribution becomes the exponential distribution

.. math::

    f(x) = \frac{1}{\theta} \exp{\left( -\frac{x}{\theta} \right)}

Options
-------
--dtrj-out
    Output filename for the generated discrete trajectory.   The
    discrete trajectory is written as binary :file:`dtrj.npy` file in a
    compressed |npz_archive| of the given filename.  The discrete
    trajectory is stored as :class:`numpy.ndarray` of dtype
    :attr:`numpy.uint8` and shape ``(n, f)``, where ``n`` is the number
    of compounds and ``f`` is the number of frames.  The elements of the
    discrete trajectory are the states in which a given compound resides
    at a given frame.
--param-out
    Output filename containing the parameters used to create the
    discrete trajectory (optional).
--hist-plot
    Output filename for a histogram plot of the drawn state lifetimes
    (optional).  The histogram shows the lifetimes that were drawn from
    the exponential distribution for each state.
-k
    :math:`k` values to use for the lifetime distribution of each state.
    The number of :math:`k` determines the number of different states in
    the generated discrete trajectory.  States are sequentially numbered
    starting from zero.  At least two values must be given.  Default:
    ``[1, 1]``
--theta
    :math:`\theta` values to use for the lifetime distribution of each
    state.  The number of given :math:`\theta` values must match the
    number of given :math:`k` values.  Default: ``[10, 100]``.
--shape
    The shape ``(n, f)`` of the generated discrete trajectory.  Default:
    ``(1, 1000)``.
--seed
    Seed to use for the random number generator.  If not ``None``, a
    random seed will be generated by calling ``secrets.randbits(128)``.
    Default: ``None``.

See Also
--------
:mod:`misc.compare_dtrj_lifetime_methods.py` :
    Compare state lifetimes calculated from a discrete trajectory using
    different methods

Notes
-----
The discrete trajectory is generated in the following way:

    1. Select a random state.  Thereby, ensure that the selected state
       is different from the previously selected state.
    2. Draw a random number from the gamma distribution of lifetimes
       assigned to the selected state.  The drawn number is rounded to
       the next integer.  If the drawn number is zero, the selected
       state is discarded and another state is selected.
    3. Extend the discrete trajectory with the selected state by as many
       frames as determined by the drawn lifetime.
    4. Clip the generated trajectory at the desired length.

Examples
--------
Generate discrete trajectories with different number of frames.

.. code-block:: bash

    k=1
    theta=100
    n_cmps=1
    for n_frames in 10 100 1000 10000 100000; do
        fname="dtrj_k_1_${k}_theta_10_${theta}_shape_${n_cmps}_${n_frames}_seed_5462_4894_3496_8436"
        python3 generate_dtrj.py \
            --dtrj-out "${fname}.npz" \
            --param-out "${fname}_param.txt.gz" \
            --hist-plot "${fname}_drawn_lifetimes_hist.pdf" \
            -k 1 "${k}" \
            --theta 10 "${theta}" \
            --shape "${n_cmps}" "${n_frames}" \
            --seed 5462489434968436
    done

Generate discrete trajectories with different number of compounds.

.. code-block:: bash

    k=1
    theta=100
    n_frames=10
    for n_cmps in 1 10 100 1000 10000 100000; do
        fname="dtrj_k_1_${k}_theta_10_${theta}_shape_${n_cmps}_${n_frames}_seed_5462_4894_3496_8436"
        python3 generate_dtrj.py \
            --dtrj-out "${fname}.npz" \
            --param-out "${fname}_param.txt.gz" \
            --hist-plot "${fname}_drawn_lifetimes_hist.pdf" \
            -k 1 "${k}" \
            --theta 10 "${theta}" \
            --shape "${n_cmps}" "${n_frames}" \
            --seed 5462489434968436
    done

Generate discrete trajectories with different :math:`k` values.

.. code-block:: bash

    theta=100
    n_cmps=100
    n_frames=100000
    for k in 0.01 0.1 1 10 100 1000 10000; do
        fname="dtrj_k_1_${k}_theta_${theta}_${theta}_shape_${n_cmps}_${n_frames}_seed_5462_4894_3496_8436"
        python3 generate_dtrj.py \
            --dtrj-out "${fname}.npz" \
            --param-out "${fname}_param.txt.gz" \
            --hist-plot "${fname}_drawn_lifetimes_hist.pdf" \
            -k 1 "${k}" \
            --theta "${theta}" "${theta}" \
            --shape "${n_cmps}" "${n_frames}" \
            --seed 5462489434968436
    done

"""


__author__ = "Andreas Thum"


# Standard libraries
import argparse
import os
import secrets
import sys
from datetime import datetime, timedelta

# Third-party libraries
import matplotlib.pyplot as plt
import numpy as np
import psutil
from matplotlib.backends.backend_pdf import PdfPages
from matplotlib.ticker import MaxNLocator
from scipy import stats

# First-party libraries
import mdtools as mdt
import mdtools.plot as mdtplt  # Load MDTools plot style  # noqa: F401


if __name__ == "__main__":  # noqa: C901
    timer_tot = datetime.now()
    proc = psutil.Process()
    proc.cpu_percent()  # Initiate monitoring of CPU usage.
    parser = argparse.ArgumentParser(
        description=(
            "Generate artificial discrete trajectories for testing purposes."
        )
    )
    parser.add_argument(
        "--dtrj-out",
        dest="DTRJ_OUT",
        type=str,
        required=True,
        help="Output filename for the generated discrete trajectory.",
    )
    parser.add_argument(
        "--param-out",
        dest="PARAM_OUT",
        type=str,
        required=False,
        default=None,
        help=(
            "Output filename containing the parameters used to create the"
            " discrete trajectory (optional)."
        ),
    )
    parser.add_argument(
        "--hist-plot",
        dest="HIST_PLOT",
        type=str,
        required=False,
        default=None,
        help=(
            "Output filename for a histogram plot of the drawn state lifetimes"
            " (optional)."
        ),
    )
    parser.add_argument(
        "-k",
        dest="K",
        type=float,
        nargs="+",
        required=False,
        default=[1, 1],
        help=(
            "k values to use for the lifetime distribution of each state."
            "  Default: %(default)s."
        ),
    )
    parser.add_argument(
        "--theta",
        dest="THETA",
        type=float,
        nargs="+",
        required=False,
        default=[10, 100],
        help=(
            "Theta values to use for the lifetime distribution of each state."
            "  Default: %(default)s."
        ),
    )
    parser.add_argument(
        "--shape",
        dest="SHAPE",
        type=int,
        nargs=2,
        required=False,
        default=[1, 1000],
        help=(
            "The shape of the generated discrete trajectory.  Default:"
            " %(default)s."
        ),
    )
    parser.add_argument(
        "--seed",
        dest="SEED",
        type=int,
        required=False,
        default=None,
        help=(
            "Seed to use for the random number generator.  Default:"
            " %(default)s"
        ),
    )
    args = parser.parse_args()
    print(mdt.rti.run_time_info_str())
    k = np.asarray(args.K)
    if np.any(k < 0):
        raise ValueError("-k ({}) must be positive".format(args.K))
    if len(k) < 2:
        raise ValueError("-k ({}) must get at least two values".format(args.K))
    theta = np.asarray(args.THETA)
    if np.any(theta < 0):
        raise ValueError("--theta ({}) must be positive".format(args.THETA))
    if theta.shape != k.shape:
        raise ValueError(
            "--theta ({}) must get as many values as -k"
            " ({})".format(args.THETA, args.K)
        )
    shape = tuple(args.SHAPE)
    if np.any(np.asarray(shape) < 1):
        raise ValueError(
            "--shape ({}) must be greater than one".format(args.SHAPE)
        )
    if args.SEED is not None and args.SEED < 0:
        raise ValueError("--seed ({}) must not be negative".format(args.SEED))

    n_cmps, n_frames = shape
    n_states = len(theta)
    state_ix = np.arange(n_states, dtype=np.uint8)
    if args.SEED is None:
        args.SEED = secrets.randbits(128)
    rng = np.random.default_rng(args.SEED)
    if args.HIST_PLOT is not None:
        lifetimes = [[] for six in state_ix]

    print("\n")
    print("Generating discrete trajectory...")
    timer = datetime.now()
    dtrj = [[] for cmp_ix in range(n_cmps)]
    for cmp_ix in range(n_cmps):
        n_frames_cmp = np.uint32(0)
        six_prev = rng.choice(state_ix)
        while n_frames_cmp < n_frames:
            # Select a random state.  Thereby, ensure that the selected
            # state is different from the previously selected state.
            mask = state_ix != six_prev
            six = rng.choice(state_ix[mask])
            # Draw a random number assuming a gamma distribution of
            # lifetimes for the selected state.
            lifetime = rng.gamma(shape=k[six], scale=theta[six])
            lifetime = np.uint32(round(lifetime))
            if args.HIST_PLOT is not None:
                # Histogram of the *drawn* lifetimes (`lifetime`), not
                # the actually appended lifetimes (`n_frames_append`).
                lifetimes[six].append(lifetime)
            if lifetime == 0:
                # Discard the selected state and select another state.
                continue
            # Extend the trajectory by the drawn lifetime with the
            # selected state.  If the trajectory would exceed the
            # pre-defined length, clip it.
            n_frames_append = min(lifetime, n_frames - n_frames_cmp)
            if n_frames_append <= 0:
                raise ValueError(
                    "`n_frames_append` ({}) <= 0.  This should not have"
                    " happened".format(n_frames_append)
                )
            dtrj[cmp_ix].append(np.full(n_frames_append, six, dtype=np.uint8))
            # Increase frame counter.
            n_frames_cmp += n_frames_append
            # Store the selected state as previous state.
            six_prev = six
        dtrj[cmp_ix] = np.concatenate(dtrj[cmp_ix])
        if len(dtrj[cmp_ix]) != n_frames:
            raise ValueError(
                "len(dtrj[{}]) ({}) != n_frames ({}).  This should not have"
                " happened".format(cmp_ix, len(dtrj[cmp_ix]), n_frames)
            )
    dtrj = np.asarray(dtrj)
    if dtrj.shape != shape:
        raise ValueError(
            "dtrj.shape ({}) != shape ({}).  This should not have"
            " happened".format(dtrj.shape, shape)
        )
    print("Elapsed time:         {}".format(datetime.now() - timer))
    print("Current memory usage: {:.2f} MiB".format(mdt.rti.mem_usage(proc)))

    print("\n")
    print("Creating output...")
    timer = datetime.now()

    mdt.fh.save_dtrj(args.DTRJ_OUT, dtrj)
    del dtrj
    print("Created {}".format(args.DTRJ_OUT))

    if args.PARAM_OUT is not None:
        data = np.column_stack([state_ix, k, theta])
        header = (
            "Parameters used to generate an artificial discrete trajectory.\n"
            + "\n"
            + "State lifetimes were sampled from a gamma distribution:\n"
            + "  p(x) = x^{k-1} e^{-x/theta} / (theta^k Gamma(k))\n"
            + "where Gamma(z) is the gamma function.\n"
            + "\n"
            + "RNG Seed:            {:d}\n".format(args.SEED)
            + "Number of compounds: {:d}\n".format(n_cmps)
            + "Number of frames:    {:d}\n".format(n_frames)
            + "Number of states:    {:d}\n".format(n_states)
            + "\n"
            + "\n"
            + "The columns contain:\n"
            + "  1 The state index (zero-based)\n"
            + "  2 k values of each state\n"
            + "  3 theta values of each state\n"
            + "\n"
            + "{:>14d}".format(1)
        )
        for col in range(2, len(data) + 2):
            header += " {:>16d}".format(col)
        mdt.fh.savetxt(args.PARAM_OUT, data, header=header)

    if args.HIST_PLOT is not None:
        # Estimate common bin edges for the lifetime distributions of
        # all states.
        mean = k * theta  # Mean of the gamma distribution.
        bin_width = max(1, np.min(mean) // 2)
        lifetime_max = [np.max(lt) if len(lt) > 0 else 0 for lt in lifetimes]
        lifetime_max = max(1, np.max(lifetime_max))
        bins = np.arange(
            0, lifetime_max + bin_width, bin_width, dtype=np.uint32
        )
        bin_mids = bins[1:] - np.diff(bins) / 2

        alpha = 0.75
        cmap = plt.get_cmap()
        c_vals = np.arange(n_states)
        c_norm = n_states - 1
        c_vals_normed = c_vals / c_norm
        colors = cmap(c_vals_normed)

        mdt.fh.backup(args.HIST_PLOT)
        with PdfPages(args.HIST_PLOT) as pdf:
            for density in (False, True):
                fig, ax = plt.subplots(clear=True)
                for six, lt in enumerate(lifetimes):
                    hist, bin_edges, patches = ax.hist(
                        lt,
                        bins=bins,
                        density=density,
                        label="$%d$" % six,
                        color=colors[six],
                        alpha=0.5,
                        rasterized=True,
                    )
                    if density:
                        lines = ax.plot(
                            bin_mids,
                            stats.gamma.pdf(
                                bin_mids, a=k[six], scale=theta[six]
                            ),
                            linestyle="dashed",
                            color=colors[six],
                            alpha=alpha,
                        )
                for six in state_ix:
                    # New loop to put the labels of `ax.axvline` at last
                    # in the legend.
                    ax.axvline(
                        mean[six],
                        linestyle="dotted",
                        color=colors[six],
                        alpha=alpha,
                    )
                ax.set(
                    xlabel="State Lifetime / Frames",
                    ylabel="Probability" if density else "Count",
                    xlim=(0, None),
                    ylim=(0, None),
                )
                ax.xaxis.set_major_locator(MaxNLocator(integer=True))
                ax.legend(
                    title="State",
                    loc="upper right",
                    ncol=1 + n_states // 6,
                    **mdtplt.LEGEND_KWARGS_XSMALL,
                )
                pdf.savefig()
                plt.close()
        print("Created {}".format(args.HIST_PLOT))

    print("Elapsed time:         {}".format(datetime.now() - timer))
    print("Current memory usage: {:.2f} MiB".format(mdt.rti.mem_usage(proc)))

    print("\n")
    print("{} done".format(os.path.basename(sys.argv[0])))
    print("Totally elapsed time: {}".format(datetime.now() - timer_tot))
    _cpu_time = timedelta(seconds=sum(proc.cpu_times()[:4]))
    print("CPU time:             {}".format(_cpu_time))
    print("CPU usage:            {:.2f} %".format(proc.cpu_percent()))
    print("Current memory usage: {:.2f} MiB".format(mdt.rti.mem_usage(proc)))
