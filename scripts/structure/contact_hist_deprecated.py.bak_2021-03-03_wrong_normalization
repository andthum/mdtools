#!/usr/bin/env python3


# This file is part of MDTools.
# Copyright (C) 2019  Andreas Thum
#
# MDTools is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# MDTools is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along
# with mdtools.  If not, see <http://www.gnu.org/licenses/>.




import sys
import os
import warnings
from datetime import datetime
import psutil
import argparse
import numpy as np
import mdtools as mdt




def contact_histogram(ref, sel, cutoff, expected_max_contacts=15,
        debug=False):
    """Calculate the number of contacts between two MDAnalysis
    :class:`AtomGroups<MDAnalysis.core.groups.AtomGroup>` (`ref` and `sel`).
    Contacts are counted by looping over all atoms of the reference group
    (`ref`) and searching for atoms of the selection group (`sel`) that are
    within the given cutoff.
    
    Contacts are binned according to how many different selection atoms/
    residues have contact to a given reference atom/residue and according to
    how many contacts exist between a given selection-atom/residue-
    reference-atom/residue pair. The results are stored in histograms. The
    sum over all elements of a histogram times their index gives the total
    number of contacts.
    
    Parameters
    ----------
    ref : MDAnalysis.core.groups.AtomGroup
        MDAnalysis :class:`AtomGroup<MDAnalysis.core.groups.AtomGroup>`
        serving as reference.
    sel : MDAnalysis.core.groups.AtomGroup
        MDAnalysis :class:`AtomGroup<MDAnalysis.core.groups.AtomGroup>`
        serving as selection.
    cutoff : scalar
        Cutoff that a reference and selection atom must not exceed to be
        considered as connected.
    expected_max_contacts : int, optional
        Expected maximum number of contacts a single reference atom can
        establish to selection atoms. This determines the initial length of
        the histogram array. If it is too small, it is likely that it has to
        be extended, which is computaionally inefficient. If it is
        unnecessarily large, you waste memory and also invoke unnecessary
        computations on zeros.
    debug : bool, optional
        If ``True``, run in debug mode.
    
    Returns
    -------
    refatm_selatm : numpy.ndarray
        Histogram of contacts between reference and selection atoms. First
        element is the number of reference atoms not in contact with any
        selection atom, second element is the number of reference atoms
        in contact with one selection atom, third element is the number of
        reference atoms in contact with two different selection atoms, ... .
        Note that the number of reference atoms in contact with `N`
        different selection atoms is the same as the number of reference
        atoms having `N` contacts to selection atoms (`refatm_selatm_tot`),
        since there cannot be multiple contacts between two atoms if
        contacts are only defined based on a distance criterium. The number
        of reference atoms in contact with `N` selection atoms is also equal
        to the number of reference atoms having `N` contacts to selection
        residues with multiple contacts to the same selection residue
        counted (`refatm_selres_tot`). Put together, this means:
        ``refatm_selatm == refatm_diff_selatm == refatm_selatm_tot ==
        refatm_selres_tot``. Note that the number of reference atoms having
        `N` contacts to the same selection atom (`refatm_same_selatm`) is
        simply ``[x, Nrefatm-x]`` with ``x`` being the number of reference
        atoms not in contact with any selection atom and ``Nrefatm`` being
        the total number of reference atoms. This holds true, since a
        reference atom can either have one or no contact to a selection atom.
    refatm_diff_selatm
        Not returned, only included for completeness. See `refatm_selatm`
    refatm_same_selatm
        Not returned, only included for completeness. See `refatm_selatm`
    refatm_selatm_tot
        Not returned, only included for completeness. See `refatm_selatm`
    refatm_diff_selres : numpy.ndarray
        Histogram of contacts between reference atoms and different
        selection residues with multiple contacts to the same selection
        residue discounted. First element is the number of reference atoms
        not in contact with any selection residue, second element is the
        number of reference atoms in contact with one selection residue,
        third element is the number of reference atoms in contact with two
        different selection residues, ... .
    refatm_same_selres : numpy.ndarray
        Histogram of contacts between reference atoms and the same selection
        residue. Multiple connections with the same number of contacts
        ("bonds") to different selection residues are discounted. First
        element is the number of reference atoms not in contact with any
        selection residue, second element is the number of reference atoms
        having at least one connection via one "bond" to a given selection
        residue, third element is the number of reference atoms having at
        least one connection via two "bonds" to a given selection residue,
        ... . Note that the sum of all histogram elements might exceed the
        number of reference atoms, since a single reference atom can be
        connected to multiple different selection residues with different
        numbers of "bonds". However, each histogram element on its own
        cannot exceed the number of reference atoms.
    refatm_selres_tot
        Not returned, only included for completeness. See `refatm_selatm`
    
    refres_diff_selatm : numpy.ndarray
        Histogram of contacts between reference residues and different
        selection atoms with multiple contacts to the same selection atom
        discounted. First element is the number of reference residues not
        in contact with any selection atom, second element is the number of
        reference residues in contact with one selection atom, third element
        is the number of reference residues in contact with two different
        selection atoms, ... .
    refres_same_selatm : numpy.ndarray
        Histogram of contacts between reference residues and the same
        selection atom. Multiple connections with the same number of
        contacts ("bonds") to different selection atoms are discounted.
        First element is the number of reference residues not in contact
        with any selection atom, second element is the number of reference
        residues having at least one connection via one "bond" to a given
        selection atom, third element is the number of reference residues
        having at least one connection via two "bonds" to a given selection
        atom, ... . Note that the sum of all histogram elements might exceed
        the number of reference residues, since a single reference residue
        can be connected to multiple different selection atoms with
        different numbers of "bonds". However, each histogram element on its
        own cannot exceed the number of reference residues.
    refres_selatm_tot : numpy.ndarray
        Histogram of contacts between reference residues and selection atoms
        with multiple contacts to the same selection atom counted. First
        element is the number of reference residues not in contact with any
        selection atom, second element is the number of reference residues
        having one contact to selection atoms, third element is the number
        of reference residues having two contacts to selection atoms, ... .
        Note that the number of reference residues having `N` contacts to
        selection atoms is the same as the number of reference residues
        having `N` contacts to selection residues with multiple contacts to
        the same selection residue counted (`refres_selres_tot`).
    refres_diff_selres : numpy.ndarray
        Histogram of contacts between reference residues and different
        selection residues with multiple contacts to the same selection
        residue discounted. First element is the number of reference
        residues not in contact with any selection residue, second element
        is the number of reference residues in contact with one selection
        residue, third element is the number of reference residues in
        contact with two different selection residues, ... .
    refres_same_selres : numpy.ndarray
        Histogram of contacts between reference residues and the same
        selection residue. Multiple connections with the same number of
        contacts ("bonds") to different selection residues are discounted.
        First element is the number of reference residues not in contact
        with any selection residue, second element is the number of
        reference residues having at least one connection via one "bond" to
        a given selection residue, third element is the number of reference
        residues having at least one connection via two "bonds" to a given
        selection residue, ... . Note that the sum of all histogram elements
        might exceed the number of reference residues, since a single
        reference residues can be connected to multiple different selection
        residues with different numbers of "bonds". However, each histogram
        element on its own cannot exceed the number of reference residues.
    refres_selres_tot
        Not returned, only included for completeness. See `refres_selatm_tot`
    
    refatm_selatm_pair
        Not returned, only included for completeness. Histogram of
        ref-atom-sel-atom pairs connected via `N` "bonds".
        `refatm_selatm_pair` is simply ``[0, y]`` with ``y`` being the
        number of ref-atom-sel-atom pairs.
    refatm_selres_pair : numpy.ndarray
        Histogram of ref-atom-sel-residue pairs connected via `N` "bonds".
        First element is meaningless and set to zero. Second element is the
        number of ref-atom-sel-residue pairs connected via one "bond", third
        element is the number of ref-atom-sel-residue pairs connected via
        two "bonds", ... . Note that the sum of all histogram elements might
        exceed the number of reference atoms, since a single reference atom
        can be connected to multiple different selection residues with
        different numbers of bonds. Even each histogram element on its own
        might exceed the number of reference atoms, since a single reference
        atom can be connected to multiple different selection residues with
        the same number of "bonds".
    refres_selatm_pair : numpy.ndarray
        Histogram of ref-residue-sel-atom pairs connected via `N` "bonds".
        First element is meaningless and set to zero. Second element is the
        number of ref-residue-sel-atom pairs connected via one "bond", third
        element is the number of ref-residue-sel-atom pairs connected via
        two "bonds", ... . Note that the sum of all histogram elements might
        exceed the number of reference residues, since a single reference
        residue can be connected to multiple different selection atoms with
        different numbers of bonds. Even each histogram element on its own
        might exceed the number of reference residues, since a single
        reference residue can be connected to multiple different selection
        atoms with the same number of "bonds".
    refres_selres_pair : numpy.ndarray
        Histogram of ref-residue-sel-residue pairs connected via `N` "bonds".
        First element is meaningless and set to zero. Second element is the
        number of ref-residue-sel-residue pairs connected via one "bond",
        third element is the number of ref-residue-sel-residue pairs
        connected via two "bonds", ... . Note that the sum of all histogram
        elements might exceed the number of reference residues, since a
        single reference residue can be connected to multiple different
        selection residues with different numbers of bonds. Even each
        histogram element on its own might exceed the number of reference
        residues, since a single reference residue can be connected to
        multiple different selection residues with the same number of
        "bonds".
    """
    
    if debug:
        if cutoff <= 0:
            warnings.warn("'cutoff' ({}) is equal to or less than zero"
                          .format(cutoff), RuntimeWarning)
        if expected_max_contacts == 0:
            warnings.warn("'expected_max_contacts' ({}) is zero"
                          .format(expected_max_contacts), RuntimeWarning)
        elif expected_max_contacts < 0:
            raise ValueError("'expected_max_contacts' ({}) is less than zero"
                             .format(expected_max_contacts))
    
    
    if ref.n_atoms == 0:
        return tuple([np.array([0]) for i in range(11)])
    if sel.n_atoms == 0:
        return tuple([np.array([ref.n_atoms]) for i in range(3)] +
                     [np.array([ref.n_residues]) for i in range(5)] +
                     [np.array([0]) for i in range(3)])
    
    
    refatm_selatm = np.zeros(expected_max_contacts+1, dtype=np.uint32)
    refatm_diff_selres = np.zeros(expected_max_contacts+1, dtype=np.uint32)
    refatm_same_selres = np.zeros(expected_max_contacts+1, dtype=np.uint32)
    
    refres_diff_selatm = np.zeros(ref.n_residues, dtype=np.uint32)
    refres_selatm_tot = np.zeros(ref.n_residues, dtype=np.uint32)
    refres_diff_selres = np.zeros(ref.n_residues, dtype=np.uint32)
    
    refatm_selres_pair = np.zeros(expected_max_contacts+1, dtype=np.uint32)
    refres_selatm_pair = np.zeros((ref.n_residues, sel.n_atoms),
                                  dtype=np.uint32)
    refres_selres_pair = np.zeros((ref.n_residues, sel.n_residues),
                                  dtype=np.uint32)
    
    selatm_used = np.ones((ref.n_residues, sel.n_atoms), dtype=np.uint8)
    selres_used = np.ones((ref.n_residues, sel.n_residues), dtype=np.uint8)
    
    unique_refresids = np.unique(ref.resids)
    unique_selresids = np.unique(sel.resids)
    
    
    for refatm in ref.atoms:
        sel_near_ref = mdt.select.atoms_around_point(ag=sel,
                                                     point=refatm.position,
                                                     cutoff=cutoff,
                                                     debug=debug)
        
        refatm_selatm = mdt.nph.extend(refatm_selatm,
                                       sel_near_ref.n_atoms+1)
        refatm_selatm[sel_near_ref.n_atoms] += 1
        
        refatm_diff_selres = mdt.nph.extend(refatm_diff_selres,
                                            sel_near_ref.n_residues+1)
        refatm_diff_selres[sel_near_ref.n_residues] += 1
        
        selresids, selresids_counts = np.unique(sel_near_ref.resids,
                                                return_counts=True)
        selresids_counts_unique = np.unique(selresids_counts)
        try:
            selresids_counts_max = selresids_counts_unique.max()
        except ValueError:
            # If selresids_counts is an empty array, the use of .max()
            # raises a "ValueError: zero-size array to reduction operation
            # maximum which has no identity". If selresids_counts is empty,
            # refatm_same_selres and refatm_selres_pair do not need to be
            # extended.
            refatm_same_selres[0] += 1
        else:
            refatm_same_selres = mdt.nph.extend(refatm_same_selres,
                                                selresids_counts_max+1)
            np.add.at(refatm_same_selres, selresids_counts_unique, 1)
            
            refatm_selres_pair = mdt.nph.extend(refatm_selres_pair,
                                                selresids_counts_max+1)
            np.add.at(refatm_selres_pair, selresids_counts, 1)
        
        refresid = np.searchsorted(unique_refresids, refatm.resid)
        refres_selatm_tot[refresid] += sel_near_ref.n_atoms
        
        selatmids = np.intersect1d(sel.atoms.ids,
                                   sel_near_ref.atoms.ids,
                                   assume_unique=True,
                                   return_indices=True)[1]
        n_atoms = np.sum(selatm_used[refresid][selatmids])
        selatm_used[refresid][selatmids] = 0
        refres_diff_selatm[refresid] += n_atoms
        refres_selatm_pair[refresid][selatmids] += 1
        
        selresids = np.intersect1d(unique_selresids,
                                   selresids,
                                   assume_unique=True,
                                   return_indices=True)[1]
        n_residues = np.sum(selres_used[refresid][selresids])
        selres_used[refresid][selresids] = 0
        refres_diff_selres[refresid] += n_residues
        np.add.at(refres_selres_pair[refresid], selresids, selresids_counts)
    
    
    del selatm_used, selres_used
    del unique_refresids, unique_selresids
    
    
    refres_same_selatm = np.zeros(refres_selatm_pair.max()+1,
                                  dtype=np.uint32)
    for i in range(1, refres_selatm_pair.max()+1):
        refres_same_selatm[i] += len(np.unique(
                                         np.nonzero(
                                             refres_selatm_pair == i)[0]))
    refres_same_selatm[0] = np.count_nonzero(
                                np.sum(refres_selatm_pair, axis=1) == 0)
    
    refres_same_selres = np.zeros(refres_selres_pair.max()+1,
                                  dtype=np.uint32)
    for i in range(1, refres_selres_pair.max()+1):
        refres_same_selres[i] += len(np.unique(
                                         np.nonzero(
                                             refres_selres_pair == i)[0]))
    refres_same_selres[0] = np.count_nonzero(
                            np.sum(refres_selres_pair, axis=1) == 0)
    
    
    refres_diff_selatm, _ = np.histogram(
                                refres_diff_selatm,
                                bins=np.arange(refres_diff_selatm.max()+2))
    refres_selatm_tot, _ = np.histogram(
                               refres_selatm_tot,
                               bins=np.arange(refres_selatm_tot.max()+2))
    refres_diff_selres, _ = np.histogram(
                                refres_diff_selres,
                                bins=np.arange(refres_diff_selres.max()+2))
    
    refres_selatm_pair, _ = np.histogram(
                                refres_selatm_pair,
                                bins=np.arange(refres_selatm_pair.max()+2))
    refres_selatm_pair[0] = 0
    refres_selres_pair, _ = np.histogram(
                                refres_selres_pair,
                                bins=np.arange(refres_selres_pair.max()+2))
    refres_selres_pair[0] = 0
    
    del _
    
    
    length = max(len(refatm_selatm),
                 len(refatm_diff_selres),
                 len(refatm_same_selres),
                 len(refres_diff_selatm),
                 len(refres_same_selatm),
                 len(refres_selatm_tot),
                 len(refres_diff_selres),
                 len(refres_same_selres),
                 len(refatm_selres_pair),
                 len(refres_selatm_pair),
                 len(refres_selres_pair))
    
    refatm_selatm = mdt.nph.extend(refatm_selatm, length)
    refatm_diff_selres = mdt.nph.extend(refatm_diff_selres, length)
    refatm_same_selres = mdt.nph.extend(refatm_same_selres, length)
    
    refres_diff_selatm = mdt.nph.extend(refres_diff_selatm, length)
    refres_same_selatm = mdt.nph.extend(refres_same_selatm, length)
    refres_selatm_tot = mdt.nph.extend(refres_selatm_tot, length)
    refres_diff_selres = mdt.nph.extend(refres_diff_selres, length)
    refres_same_selres = mdt.nph.extend(refres_same_selres, length)
    
    refatm_selres_pair = mdt.nph.extend(refatm_selres_pair, length)
    refres_selatm_pair = mdt.nph.extend(refres_selatm_pair, length)
    refres_selres_pair = mdt.nph.extend(refres_selres_pair, length)
    
    
    if debug:
        if np.sum(refatm_selatm) != ref.n_atoms:
            raise ValueError("The sum over 'refatm_selatm' ({}) does not"
                             " fit to the number of reference atoms ({})"
                             .format(np.sum(refatm_selatm), ref.n_atoms))
        if np.sum(refatm_diff_selres) != ref.n_atoms:
            raise ValueError("The sum over 'refatm_diff_selres' ({}) does"
                             " not fit to the number of reference atoms ({})"
                             .format(np.sum(refatm_diff_selres),
                                     ref.n_atoms))
        if np.sum(refatm_same_selres) < ref.n_atoms:
            raise ValueError("The sum over 'refatm_same_selres' ({}) is"
                             " less than the number of reference atoms ({})"
                             .format(np.sum(refatm_same_selres),
                                     ref.n_atoms))
        if np.any(refatm_same_selres > ref.n_atoms):
            raise ValueError("At least one element of 'refatm_same_selres'"
                             " is greater than the number of reference atoms"
                             " ({})".format(ref.n_atoms))
        
        if np.sum(refres_diff_selatm) != ref.n_residues:
            raise ValueError("The sum over 'refres_diff_selatm' ({}) does"
                             " not fit to the number of reference residues"
                             " ({})".format(np.sum(refres_diff_selatm),
                                            ref.n_residues))
        if np.sum(refres_same_selatm) < ref.n_residues:
            raise ValueError("The sum over 'refres_same_selatm' ({}) is less"
                             " than the number of reference residues ({})"
                             .format(np.sum(refres_same_selatm),
                                     ref.n_residues))
        if np.any(refres_same_selatm > ref.n_residues):
            raise ValueError("At least one element of 'refres_same_selatm'"
                             " is greater than the number of reference"
                             " residues ({})".format(ref.n_residues))
        if np.sum(refres_selatm_tot) != ref.n_residues:
            raise ValueError("The sum over 'refres_selatm_tot' ({}) does not"
                             " fit to the number of reference residues ({})"
                             .format(np.sum(refres_selatm_tot),
                                     ref.n_residues))
        if np.sum(refres_diff_selres) != ref.n_residues:
            raise ValueError("The sum over 'refres_diff_selres' ({}) does"
                             " not fit to the number of reference residues"
                             " ({})".format(np.sum(refres_diff_selres),
                                            ref.n_residues))
        if np.sum(refres_same_selres) < ref.n_residues:
            raise ValueError("The sum over 'refres_same_selres' ({}) is less"
                             " than the number of reference residues ({})"
                             .format(np.sum(refres_same_selres),
                                     ref.n_residues))
        if np.any(refres_same_selres > ref.n_residues):
            raise ValueError("At least one element of 'refres_same_selres'"
                             " is greater than the number of reference"
                             " residues ({})".format(ref.n_residues))
        
        
        if refatm_selatm[0] != refatm_diff_selres[0]:
            raise ValueError("The number of ref atoms not connected to any"
                             " sel atom is not the same in 'refatm_selatm'"
                             " ({}) and 'refatm_diff_selres' ({})"
                             .format(refatm_selatm[0],
                                     refatm_diff_selres[0]))
        if refatm_selatm[0] != refatm_same_selres[0]:
            raise ValueError("The number of ref atoms not connected to any"
                             " sel atom is not the same in 'refatm_selatm'"
                             " ({}) and 'refatm_same_selres' ({})"
                             .format(refatm_selatm[0],
                                     refatm_same_selres[0]))
        
        if refres_diff_selatm[0] != refres_same_selatm[0]:
            raise ValueError("The number of ref residues not connected to"
                             " any sel atom is not the same in"
                             " 'refres_diff_selatm' ({}) and"
                             " 'refres_same_selatm' ({})"
                             .format(refres_diff_selatm[0],
                                     refres_same_selatm[0]))
        if refres_diff_selatm[0] != refres_selatm_tot[0]:
            raise ValueError("The number of ref residues not connected to"
                             " any sel atom is not the same in"
                             " 'refres_diff_selatm' ({}) and"
                             " 'refres_selatm_tot' ({})"
                             .format(refres_diff_selatm[0],
                                     refres_selatm_tot[0]))
        if refres_diff_selatm[0] != refres_diff_selres[0]:
            raise ValueError("The number of ref residues not connected to"
                             " any sel atom is not the same in"
                             " 'refres_diff_selatm' ({}) and"
                             " 'refres_diff_selres' ({})"
                             .format(refres_diff_selatm[0],
                                     refres_diff_selres[0]))
        if refres_diff_selatm[0] != refres_same_selres[0]:
            raise ValueError("The number of ref residues not connected to"
                             " any sel atom is not the same in"
                             " 'refres_diff_selatm' ({}) and"
                             " 'refres_same_selres' ({})"
                             .format(refres_diff_selatm[0],
                                     refres_same_selres[0]))
        
        if refatm_selres_pair[0] != 0:
            raise ValueError("The first element of 'refatm_selres_pair' ({})"
                             " is not zero".format(refatm_selres_pair[0]))
        if refres_selatm_pair[0] != 0:
            raise ValueError("The first element of 'refres_selatm_pair' ({})"
                             " is not zero".format(refres_selatm_pair[0]))
        if refres_selres_pair[0] != 0:
            raise ValueError("The first element of 'refres_selres_pair' ({})"
                             " is not zero".format(refres_selres_pair[0]))
        
        
        occurence = np.array(
                        [len(np.intersect1d(ref.atoms.ids, refres.atoms.ids))
                         for refres in ref.residues],
                        dtype=np.uint32
                    )
        if np.all(occurence == 1):
            # refatm == refres
            # * refatm_selatm == refatm_diff_selatm == refatm_selatm_tot == refatm_selres_tot
            #                    refres_diff_selatm    refres_selatm_tot == refres_selres_tot
            # * refatm_diff_selres
            #   refres_diff_selres
            # * refatm_same_selres
            #   refres_same_selres
            # * refres_same_selatm
            #   [x, Nrefatm-x]
            # * refatm_selres_pair
            #   refres_selres_pair
            # * refres_selatm_pair
            #   [0, y]
            if np.any(refatm_selatm != refres_diff_selatm):
                raise ValueError("The residues of the reference group"
                                 " contain only one atom of the reference"
                                 " group each, but 'refatm_selatm'"
                                 " != 'refres_diff_selatm'")
            if np.any(refatm_selatm != refres_selatm_tot):
                raise ValueError("The residues of the reference group"
                                 " contain only one atom of the reference"
                                 " group each, but 'refatm_selatm'"
                                 " != 'refres_selatm_tot'")
            if np.any(refatm_diff_selres != refres_diff_selres):
                raise ValueError("The residues of the reference group"
                                 " contain only one atom of the reference"
                                 " group each, but 'refatm_diff_selres' !="
                                 " 'refres_diff_selres'")
            if np.any(refatm_same_selres != refres_same_selres):
                raise ValueError("The residues of the reference group"
                                 " contain only one atom of the reference"
                                 " group each, but 'refatm_same_selres' !="
                                 " 'refres_same_selres'")
            if np.any(refres_same_selatm[:2] !=
                      np.array([refatm_selatm[0],
                                ref.n_atoms-refatm_selatm[0]])):
                raise ValueError("The residues of the reference group"
                                 " contain only one atom of the reference"
                                 " group each, but 'refres_same_selatm' !="
                                 " '[x, Nrefatm-x]'")
            if np.sum(refres_same_selatm) != ref.n_atoms:
                raise ValueError("The residues of the reference group"
                                 " contain only one atom of the reference"
                                 " group each, but the sum over"
                                 " 'refres_same_selatm' ({}) does not fit"
                                 " to the number of reference atoms ({})"
                                 .format(np.sum(refres_same_selatm),
                                         ref.n_atoms))
            if np.any(refatm_selres_pair != refres_selres_pair):
                raise ValueError("The residues of the reference group"
                                 " contain only one atom of the reference"
                                 " group each, but 'refatm_selres_pair'"
                                 " != 'refres_selres_pair'")
            mask = np.ones(len(refres_selatm_pair), dtype=bool)
            mask[1] = 0
            if np.any(refres_selatm_pair[mask] != 0):
                raise ValueError("The residues of the reference group"
                                 " contain only one atom of the reference"
                                 " group each, but 'refres_selatm_pair' !="
                                 " '[0, y]'")
        
        if np.all(occurence == occurence[0]):
            if not np.isclose(
                       np.sum(refatm_selatm*
                              np.arange(len(refatm_selatm))),
                       np.sum(refres_selatm_tot*
                              np.arange(len(refres_selatm_tot)))/occurence[0],
                       rtol=1e04):
                raise ValueError("The total number of contacts between ref"
                                 " atoms and sel atoms ({}) is not the same"
                                 " as the total number of contacts between"
                                 " ref residues and sel atoms divided by the"
                                 " number of ref atoms per ref residue ({})"
                                 .format(
                                     np.sum(refatm_selatm*
                                            np.arange(len(refatm_selatm))),
                                     np.sum(refres_selatm_tot*
                                            np.arange(len(refres_selatm_tot)))/occurence[0]
                                  )
                                )
        
        
        occurence = np.array(
                        [len(np.intersect1d(sel.atoms.ids, selres.atoms.ids))
                         for selres in sel.residues],
                        dtype=np.uint32
                    )
        if np.all(occurence == 1):
            # selatm == selres
            # * refatm_selatm == refatm_diff_selatm == refatm_selatm_tot == refatm_selres_tot
            #                    refatm_diff_selres
            # * refatm_same_selres
            #   [x, Nrefatm-x]
            # * refres_diff_selatm
            #   refres_diff_selres
            # * refres_same_selatm
            #   refres_same_selres
            # * refres_selatm_tot == refres_selres_tot
            # * refatm_selres_pair
            #   [0, y]
            # * refres_selatm_pair
            #   refres_selres_pair
            if np.any(refatm_selatm != refatm_diff_selres):
                raise ValueError("The residues of the selection group"
                                 " contain only one atom of the selection"
                                 " group each, but 'refatm_selatm' !="
                                 " 'refatm_diff_selres'")
            if np.any(refatm_same_selres[:2] !=
                      np.array([refatm_selatm[0],
                                ref.n_atoms-refatm_selatm[0]])):
                raise ValueError("The residues of the selection group"
                                 " contain only one atom of the selection"
                                 " group each, but 'refatm_same_selres' !="
                                 " '[x, Nrefatm-x]'")
            if np.sum(refatm_same_selres) != ref.n_atoms:
                raise ValueError("The residues of the selection group"
                                 " contain only one atom of the selection"
                                 " group each, but the sum over"
                                 " 'refatm_same_selres' ({}) does not fit"
                                 " to the number of reference atoms ({})"
                                 .format(np.sum(refatm_same_selres),
                                         ref.n_atoms))
            if np.any(refres_diff_selatm != refres_diff_selres):
                raise ValueError("The residues of the selection group"
                                 " contain only one atom of the selection"
                                 " group each, but'refres_diff_selatm' !="
                                 " 'refres_diff_selres'")
            if np.any(refres_same_selatm != refres_same_selres):
                raise ValueError("The residues of the selection group"
                                 " contain only one atom of the selection"
                                 " group each, but'refres_same_selatm' !="
                                 " 'refres_same_selres'")
            mask = np.ones(len(refres_selatm_pair), dtype=bool)
            mask[1] = 0
            if np.any(refatm_selres_pair[mask] != 0):
                raise ValueError("The residues of the selection group"
                                 " contain only one atom of the selection"
                                 " group each, but 'refatm_selres_pair' !="
                                 " '[0, Nrefatm-x]'")
            if np.any(refres_selatm_pair != refres_selres_pair):
                raise ValueError("The residues of the selection group"
                                 " contain only one atom of the selection"
                                 " group each, but'refres_selatm_pair' !="
                                 " 'refres_selres_pair'")
        
        
        if (refatm_selatm.shape != refatm_diff_selres.shape or
            refatm_selatm.shape != refatm_same_selres.shape or
            refatm_selatm.shape != refres_diff_selatm.shape or
            refatm_selatm.shape != refres_same_selatm.shape or
            refatm_selatm.shape != refres_selatm_tot.shape or
            refatm_selatm.shape != refres_diff_selres.shape or
            refatm_selatm.shape != refres_same_selres.shape or
            refatm_selatm.shape != refatm_selres_pair.shape or
            refatm_selatm.shape != refres_selatm_pair.shape or
            refatm_selatm.shape != refres_selres_pair.shape):
            raise ValueError("The histograms have not the same shape:\n"
                             "  refatm_selatm.shape = {}\n"
                             "  refatm_diff_selres.shape = {}\n"
                             "  refatm_same_selres.shape = {}\n"
                             "  refres_diff_selatm.shape = {}\n"
                             "  refres_same_selatm.shape = {}\n"
                             "  refres_selatm_tot.shape = {}\n"
                             "  refres_diff_selres.shape = {}\n"
                             "  refres_same_selres.shape = {}\n"
                             "  refatm_selres_pair.shape = {}\n"
                             "  refres_selatm_pair.shape = {}\n"
                             "  refres_selres_pair.shape = {}\n"
                             .format(refatm_selatm.shape,
                                     refatm_diff_selres.shape,
                                     refatm_same_selres.shape,
                                     refres_diff_selatm.shape,
                                     refres_same_selatm.shape,
                                     refres_selatm_tot.shape,
                                     refres_diff_selres.shape,
                                     refres_same_selres.shape,
                                     refatm_selres_pair.shape,
                                     refres_selatm_pair.shape,
                                     refres_selres_pair.shape))
    
    
    return (refatm_selatm,
            refatm_diff_selres,
            refatm_same_selres,
            refres_diff_selatm,
            refres_same_selatm,
            refres_selatm_tot,
            refres_diff_selres,
            refres_same_selres,
            refatm_selres_pair,
            refres_selatm_pair,
            refres_selres_pair)








if __name__ == '__main__':
    
    timer_tot = datetime.now()
    proc = psutil.Process(os.getpid())
    
    
    parser = argparse.ArgumentParser(
                 description="Calculate the number of contacts between two"
                             " atom groups. Contacts are counted by looping"
                             " over all atoms of the reference group and"
                             " searching for atoms of the selection group"
                             " that are within the given cutoff. Contacts"
                             " are binned according to how many different"
                             " selection atoms/residues have contact to a"
                             " given reference atom/residue and according"
                             " to how many contacts exist between a given"
                             " selection-residue/atom-reference-atom/residue"
                             " pair. The results are stored in histograms.")
    parser.add_argument(
        '-f',
        dest='TRJFILE',
        type=str,
        required=True,
        help="Trajectory file [<.trr/.xtc/.gro/.pdb/.xyz/.mol2/...>]. See"
             " supported coordinate formats of MDAnalysis."
    )
    parser.add_argument(
        '-s',
        dest='TOPFILE',
        type=str,
        required=True,
        help="Topology file [<.top/.tpr/.gro/.pdb/.xyz/.mol2/...>]. See"
             " supported topology formats of MDAnalysis."
    )
    parser.add_argument(
        '-o',
        dest='OUTFILE',
        type=str,
        required=True,
        help="Output filename."
    )
    
    parser.add_argument(
        '--ref',
        dest='REF',
        type=str,
        nargs='+',
        required=True,
        help="Reference group. See MDAnalysis selection commands for"
             " possible choices. E.g. 'name Li'"
    )
    parser.add_argument(
        "--sel",
        dest="SEL",
        type=str,
        nargs="+",
        required=True,
        help="Selection group. See MDAnalysis selection commands for"
             " possible choices. E.g. 'type OE'"
    )
    parser.add_argument(
        '-c',
        dest='CUTOFF',
        type=float,
        required=True,
        help="Cutoff distance in Angstrom. A contact between a reference"
             " and selection atom is counted, if their distance is less than"
             " or equal to this cutoff."
    )
    parser.add_argument(
        '--updating-ref',
        dest='UPDATING_REF',
        required=False,
        default=False,
        action='store_true',
        help="Use an updating atom group for the reference group. Selection"
             " expressions of updating atom groups are re-evaluated every"
             " time step. E.g. useful for position based selections like"
             " 'type Li and prop z <= 2.0'."
    )
    parser.add_argument(
        '--updating-sel',
        dest='UPDATING_SEL',
        required=False,
        default=False,
        action='store_true',
        help="Use an updating atom group for the selection group."
    )
    parser.add_argument(
        '--expected-max-contacts',
        dest='EXPECTED_MAX_CONTACTS',
        type=int,
        required=False,
        default=15,
        help="Expected maximum number of contacts a single reference atom"
             " can establish to selection atoms. This determines the initial"
             " length of the histogram array. If it is too small, it is"
             " likely that it has to be extended, which is computaionally"
             " inefficient. If it is unnecessarily large, you waste memory"
             " and also invoke unnecessary computations with only adding"
             " zeros. Default: 15"
    )
    
    parser.add_argument(
        '-b',
        dest='BEGIN',
        type=int,
        required=False,
        default=0,
        help="First frame to read. Frame numbering starts at zero."
             " Default: 0"
    )
    parser.add_argument(
        "-e",
        dest="END",
        type=int,
        required=False,
        default=-1,
        help="Last frame to read (exclusive, i.e. the last frame read is"
             " actually END-1). Default: -1 (means read the very last frame"
             " of the trajectory)"
    )
    parser.add_argument(
        '--every',
        dest='EVERY',
        type=int,
        required=False,
        default=1,
        help="Read every n-th frame. Default: 1"
    )
    
    parser.add_argument(
        '--debug',
        dest='DEBUG',
        required=False,
        default=False,
        action='store_true',
        help="Run in debug mode."
    )
    
    args = parser.parse_args()
    print(mdt.rti.run_time_info_str())
    
    
    
    
    hist_atm = np.zeros((3, args.EXPECTED_MAX_CONTACTS+1), dtype=np.float64)
    hist_res = np.zeros((5, args.EXPECTED_MAX_CONTACTS+1), dtype=np.float64)
    hist_par = np.zeros((3, args.EXPECTED_MAX_CONTACTS+1), dtype=np.float64)
    
    void_hists = 0
    void_par_hists = np.zeros(3, dtype=np.uint32)
    norm_par = np.zeros(3, dtype=np.uint32)
    norm_par_mask = np.zeros(3, dtype=bool)
    
    
    print("\n\n\n", flush=True)
    u = mdt.select.universe(top=args.TOPFILE,
                            trj=args.TRJFILE,
                            verbose=True)
    
    print("\n\n\nCreating selections", flush=True)
    timer = datetime.now()
    ref = u.select_atoms(' '.join(args.REF), updating=args.UPDATING_REF)
    sel = u.select_atoms(' '.join(args.SEL), updating=args.UPDATING_SEL)
    print("  Reference group: '{}'".format(' '.join(args.REF)), flush=True)
    print(mdt.rti.ag_info_str(ag=ref, indent=4))
    print("    Updating atom group:    {}"
          .format(args.UPDATING_REF),
          flush=True)
    print("\n  Selection group: '{}'".format(' '.join(args.SEL)), flush=True)
    print(mdt.rti.ag_info_str(ag=sel, indent=4))
    print("    Updating atom group:    {}"
          .format(args.UPDATING_SEL),
          flush=True)
    print("Elapsed time:         {}"
          .format(datetime.now()-timer),
          flush=True)
    print("Current memory usage: {:.2f} MiB"
          .format(proc.memory_info().rss/2**20),
          flush=True)
    
    
    
    
    BEGIN, END, EVERY, n_frames = mdt.check.frame_slicing(
                                      start=args.BEGIN,
                                      stop=args.END,
                                      step=args.EVERY,
                                      n_frames_tot=u.trajectory.n_frames)
    last_frame = u.trajectory[END-1].frame
    
    
    print("\n\n\nReading trajectory", flush=True)
    print("  Total number of frames in trajectory: {:>9d}"
          .format(u.trajectory.n_frames),
          flush=True)
    print("  Time step per frame:                  {:>9} (ps)\n"
          .format(u.trajectory[0].dt),
          flush=True)
    timer = datetime.now()
    timer_frame = datetime.now()
    
    if args.UPDATING_REF:
        n_refatm = 0
        n_refres = 0
        refatm_types = []
        refres_names = []
    
    if args.UPDATING_SEL:
        n_selatm = 0
        n_selres = 0
        selatm_types = []
        selres_names = []
    
    
    for ts in u.trajectory[BEGIN:END:EVERY]:
        
        if args.UPDATING_REF:
            n_refatm += ref.n_atoms
            n_refres += ref.n_residues
            refatm_types += [i for i in np.unique(ref.atoms.types)]
            refatm_types = list(set(refatm_types))
            refres_names += [i for i in np.unique(ref.residues.resnames)]
            refres_names = list(set(refres_names))
        
        if args.UPDATING_SEL:
            n_selatm += sel.n_atoms
            n_selres += sel.n_residues
            selatm_types += [i for i in np.unique(sel.atoms.types)]
            selatm_types = list(set(selatm_types))
            selres_names += [i for i in np.unique(sel.residues.resnames)]
            selres_names = list(set(selres_names))
        
        if (ts.frame % 10**(len(str(ts.frame))-1) == 0 or
            ts.frame == END-1):
            print("  Frame   {:12d}".format(ts.frame), flush=True)
            print("    Step: {:>12}    Time: {:>12} (ps)"
                  .format(ts.data['step'], ts.data['time']),
                  flush=True)
            print("    Elapsed time:             {}"
                  .format(datetime.now()-timer_frame),
                  flush=True)
            print("    Current memory usage: {:18.2f} MiB"
                  .format(proc.memory_info().rss/2**20),
                  flush=True)
            timer_frame = datetime.now()
        
        if ref.n_atoms == 0:
            void_hists += 1
            continue
        
        hist_tmp = np.array(
                       contact_histogram(
                           ref=ref,
                           sel=sel,
                           cutoff=args.CUTOFF,
                           expected_max_contacts=len(hist_atm[0])-1,
                           debug=args.DEBUG
                       )
                   )
        
        hist_atm, hist_atm_tmp = mdt.nph.match_shape(
                                     hist_atm,
                                     hist_tmp[:3]/ref.n_atoms)
        hist_atm += hist_atm_tmp
        
        hist_res, hist_res_tmp = mdt.nph.match_shape(
                                     hist_res,
                                     hist_tmp[3:8]/ref.n_residues)
        hist_res += hist_res_tmp
        
        np.sum(hist_tmp[8:], axis=1, out=norm_par)
        np.equal(norm_par, 0, out=norm_par_mask)
        norm_par[norm_par_mask] = 1
        void_par_hists[norm_par_mask] += 1
        hist_par, hist_par_tmp = mdt.nph.match_shape(
                                     hist_par,
                                     hist_tmp[8:]/norm_par[:,None])
        hist_par += hist_par_tmp
    
    
    print("\nTotal number of frames in trajectory: {:>9d}"
          .format(u.trajectory.n_frames),
          flush=True)
    print("Time step per frame:                  {:>9} (ps)"
          .format(u.trajectory[0].dt),
          flush=True)
    print("Frames read: {}".format(n_frames), flush=True)
    print("First frame: {:>12d}   Last frame: {:>12d}   "
          "Every Nth frame: {:>12d}"
          .format(u.trajectory[BEGIN].frame, last_frame, EVERY),
          flush=True)
    print("Start time:  {:>12}   End time:   {:>12}   "
          "Every Nth time:  {:>12} (ps)"
          .format(u.trajectory[BEGIN].time,
                  u.trajectory[END-1].time,
                  u.trajectory[0].dt * EVERY),
          flush=True)
    print("Void histograms: {:8d}   Void ref-sel pair histograms: {}"
          .format(void_hists, void_hists+void_par_hists),
          flush=True)
    print("Elapsed time:         {}"
          .format(datetime.now()-timer),
          flush=True)
    print("Current memory usage: {:.2f} MiB"
          .format(proc.memory_info().rss/2**20),
          flush=True)
    
    
    
    
    del norm_par, norm_par_mask
    
    if void_hists < n_frames:
        del hist_tmp, hist_atm_tmp, hist_res_tmp, hist_par_tmp
    
    
    if not args.UPDATING_REF:
        n_refatm = ref.n_atoms * n_frames
        n_refres = ref.n_residues * n_frames
        refatm_types = [i for i in np.unique(ref.atoms.types)]
        refres_names = [i for i in np.unique(ref.residues.resnames)]
    
    if not args.UPDATING_SEL:
        n_selatm = sel.n_atoms * n_frames
        n_selres = sel.n_residues * n_frames
        selatm_types = [i for i in np.unique(sel.atoms.types)]
        selres_names = [i for i in np.unique(sel.residues.resnames)]
    
    if n_refatm == 0:
        warnings.warn("The total number of reference atoms is zero. The"
                      " output will be meaningless", RuntimeWarning)
    if n_selatm == 0:
        warnings.warn("The total number of selection atoms is zero. The"
                      " output will be meaningless", RuntimeWarning)
    
    if void_hists >= n_frames:
        warnings.warn("All histograms are void. The output will be"
                      " meaningless", RuntimeWarning)
    if np.any(void_hists+void_par_hists >= n_frames):
        warnings.warn("At least one of the ref-sel pair histograms is void."
                      " This histogram will be meaningless", RuntimeWarning)
    
    
    
    
    hist_atm /= (n_frames - void_hists)
    hist_res /= (n_frames - void_hists)
    hist_par /= ((n_frames - void_hists) - void_par_hists[:,None])
    
    del void_par_hists
    
    
    av_atm = np.zeros(2, dtype=np.float64)
    av_atm_bound = np.zeros(2, dtype=np.float64)
    for i in [0, 1]:
        av_atm[i] = np.sum(hist_atm[i] * np.arange(len(hist_atm[i])))
        av_atm_bound[i] = av_atm[i] / (1 - hist_atm[i][0])
    
    av_res = np.zeros(4, dtype=np.float64)
    av_res_bound = np.zeros(4, dtype=np.float64)
    for i in [0, 2, 3]:
        av_res[i] = np.sum(hist_res[i] * np.arange(len(hist_res[i])))
        av_res_bound[i] = av_res[i] / (1 - hist_res[i][0])
    
    av_par = np.zeros(3, dtype=np.float64)
    av_par_bound = np.zeros(3, dtype=np.float64)
    for i in [0]:
        av_par_bound[i] = np.sum(hist_par[i] * np.arange(len(hist_par[i])))
        av_par[i] = av_par_bound[i] * (1 - hist_atm[0][0])
    for i in [1, 2]:
        av_par_bound[i] = np.sum(hist_par[i] * np.arange(len(hist_par[i])))
        av_par[i] = av_par_bound[i] * (1 - hist_res[0][0])
    
    
    last_nonzero = 0
    
    if np.all(hist_atm == 0):
        pass
    else:
        for i in range(len(hist_atm)):
            last_nonzero = max(last_nonzero, np.nonzero(hist_atm[i])[0][-1])
    
    if np.all(hist_res == 0):
        pass
    else:
        for i in range(len(hist_res)):
            last_nonzero = max(last_nonzero, np.nonzero(hist_res[i])[0][-1])
    
    if np.all(hist_par == 0):
        pass
    else:
        for i in range(len(hist_par)):
            last_nonzero = max(last_nonzero, np.nonzero(hist_par[i])[0][-1])
    
    
    
    
    print("\n\n\nWriting output", flush=True)
    
    mdt.fh.write_header(args.OUTFILE)
    with open(args.OUTFILE, 'a') as outfile:
        outfile.write("# Contact histograms\n")
        outfile.write("# Cutoff (Angstrom): {}\n".format(args.CUTOFF))
        outfile.write("# Average over {} frame(s)\n".format(n_frames))
        outfile.write("# and the following number of reference atoms/residues\n")
        outfile.write("#\n")
        outfile.write("#\n")
        outfile.write("# Reference: '{}'\n".format(' '.join(args.REF)))
        outfile.write("#   Total number of atoms (per frame):    {:9d}   ({:8.2f})\n".format(n_refatm, n_refatm/n_frames))
        outfile.write("#   Total number of residues (per frame): {:9d}   ({:8.2f})\n".format(n_refres, n_refres/n_frames))
        outfile.write("#   Number of different atom types:       {:9d}\n".format(len(refatm_types)))
        outfile.write("#     Name(s): '{}'\n".format('\' \''.join(i for i in refatm_types)))
        outfile.write("#   Number of different residues:         {:9d}\n".format(len(refres_names)))
        outfile.write("#     Name(s): '{}'\n".format('\' \''.join(i for i in refres_names)))
        outfile.write("#   Updating atom group:                  {:>9s}\n".format(str(args.UPDATING_REF)))
        outfile.write("#\n")
        outfile.write("# Selection: '{}'\n".format(' '.join(args.SEL)))
        outfile.write("#   Total number of atoms (per frame):    {:9d}   ({:8.2f})\n".format(n_selatm, n_selatm/n_frames))
        outfile.write("#   Total number of residues (per frame): {:9d}   ({:8.2f})\n".format(n_selres, n_selres/n_frames))
        outfile.write("#   Number of different atom types:       {:9d}\n".format(len(selatm_types)))
        outfile.write("#     Name(s): '{}'\n".format('\' \''.join(i for i in selatm_types)))
        outfile.write("#   Number of different residues:         {:9d}\n".format(len(selres_names)))
        outfile.write("#     Name(s): '{}'\n".format('\' \''.join(i for i in selres_names)))
        outfile.write("#   Updating atom group:                  {:>9s}\n".format(str(args.UPDATING_SEL)))
        outfile.write("#\n")
        outfile.write("#\n")
        outfile.write("# Percentage of ref atoms    connected to at least one sel atom:                    {:10.4e}\n".format(1-hist_atm[0][0]))
        outfile.write("# Percentage of ref residues connected to at least one sel atom:                    {:10.4e}\n".format(1-hist_res[0][0]))
        outfile.write("#    (2)  Average       sel atom    coordination number of all   ref atoms:         {:10.4e}  (Every ref atom                              has on average           contact  to this many           sel atoms)\n".format(av_atm[0]))
        outfile.write("#    (2)* Average       sel atom    coordination number of bound ref atoms:         {:10.4e}  (Every ref atom    connected to sel atoms    has on average           contact  to this many           sel atoms)\n".format(av_atm_bound[0]))
        outfile.write("#    (3)  Average       sel residue coordination number of all   ref atoms:         {:10.4e}  (Every ref atom                              has on average           contact  to this many different sel residues)\n".format(av_atm[1]))
        outfile.write("#    (3)* Average       sel residue coordination number of bound ref atoms:         {:10.4e}  (Every ref atom    connected to sel residues has on average           contact  to this many different sel residues)\n".format(av_atm_bound[1]))
        outfile.write("#    (5)  Average       sel atom    coordination number of all   ref residues:      {:10.4e}  (Every ref residue                           has on average           contact  to this many different sel atoms)\n".format(av_res[0]))
        outfile.write("#    (5)* Average       sel atom    coordination number of bound ref residues:      {:10.4e}  (Every ref residue connected to sel atoms    has on average           contact  to this many different sel atoms)\n".format(av_res_bound[0]))
        outfile.write("#    (7)  Average total sel atom    coordination number of all   ref residues:      {:10.4e}  (Every ref residue                           has on average this many contacts to                     sel atoms)\n".format(av_res[2]))
        outfile.write("#    (7)* Average total sel atom    coordination number of bound ref residues:      {:10.4e}  (Every ref residue connected to sel atoms    has on average this many contacts to                     sel atoms)\n".format(av_res_bound[2]))
        outfile.write("#    (8)  Average       sel residue coordination number of all   ref residues:      {:10.4e}  (Every ref residue                           has on average           contact  to this many different sel residues)\n".format(av_res[3]))
        outfile.write("#    (8)* Average       sel residue coordination number of bound ref residues:      {:10.4e}  (Every ref residue connected to sel residues has on average           contact  to this many different sel residues)\n".format(av_res_bound[3]))
        outfile.write("#   (10)' Average number of 'bonds' ref atoms    establish to the same sel residue: {:10.4e}  (Every ref atom                              has on average this many contacts to           the same  sel residue)\n".format(av_par[0]))
        outfile.write("#   (10)  Average number of 'bonds' between ref-atom-   sel-residue pairs:          {:10.4e}  (Every ref atom    connected to sel residues has on average this many contacts to           the same  sel residue)\n".format(av_par_bound[0]))
        outfile.write("#   (11)' Average number of 'bonds' ref residues establish to the same sel atom:    {:10.4e}  (Every ref residue                           has on average this many contacts to           the same  sel atom)\n".format(av_par[1]))
        outfile.write("#   (11)  Average number of 'bonds' between ref-residue-sel-atom   pairs:           {:10.4e}  (Every ref residue connected to sel atoms    has on average this many contacts to           the same  sel atom)\n".format(av_par_bound[1]))
        outfile.write("#   (12)' Average number of 'bonds' ref residues establish to the same sel residue: {:10.4e}  (Every ref residue                           has on average this many contacts to           the same  sel residue)\n".format(av_par[2]))
        outfile.write("#   (12)  Average number of 'bonds' between ref-residue-sel-residue pairs:          {:10.4e}  (Every ref residue connected to sel residues has on average this many contacts to           the same  sel residue)\n".format(av_par_bound[2]))
        outfile.write("# The average coordination numbers given here are the sum over all histogram elements of column number (i) times their respective N\n")
        outfile.write("# *) Additionally divided    by the percentage of bound ref atoms/residues (-> Probabilities are renormalized to the number of bound ref atoms/residues)\n")
        outfile.write("# ') Additionally multiplied by the percentage of bound ref atoms/residues (-> Probabilities are renormalized to the number of all   ref atoms/residues)\n")
        outfile.write("#\n")
        outfile.write("#\n")
        outfile.write("# The columns contain:\n")
        outfile.write("#    1 N:                  Number of contacts between the reference and selection\n")
        outfile.write("#    2 refatm_selatm:      % of ref atoms    that have   contact  to N different sel atoms    (multiple contacts to the same sel atom    discounted) [refatm_diff_selatm]\n")
        outfile.write("#                       [= % of ref atoms    that have N contacts to             sel atoms    (multiple contacts to the same sel atom       counted)  refatm_selatm_tot]\n")
        outfile.write("#                       [= % of ref atoms    that have N contacts to             sel residues (multiple contacts to the same sel residue    counted)  refatm_selres_tot]\n")
        outfile.write("#    3 refatm_diff_selres: % of ref atoms    that have   contact  to N different sel residues (multiple contacts to the same sel residue discounted)\n")
        outfile.write("#    4 refatm_same_selres: % of ref atoms    that have N contacts to   the same  sel residue  (multiple contacts to the same sel residue    counted, multiple connections with the same number of contacts to different sel residues discounted)\n")
        outfile.write("#    5 refres_diff_selatm: % of ref residues that have   contact  to N different sel atoms    (multiple contacts to the same sel atom    discounted)\n")
        outfile.write("#    6 refres_same_selatm: % of ref residues that have N contacts to   the same  sel atom     (multiple contacts to the same sel atom       counted, multiple connections with the same number of contacts to different sel atoms    discounted)\n")
        outfile.write("#    7 refres_selatm_tot:  % of ref residues that have N contacts to             sel atoms    (multiple contacts to the same sel atom       counted)\n")
        outfile.write("#                       [= % of ref residues that have N contacts to             sel residues (multiple contacts to the same sel residue    counted)  refres_selres_tot]\n")
        outfile.write("#    8 refres_diff_selres: % of ref residues that have   contact  to N different sel residues (multiple contacts to the same sel residue discounted, multiple connections with the same number of contacts to different sel residues discounted)\n")
        outfile.write("#    9 refres_same_selres: % of ref residues that have N contacts to   the same  sel residue  (multiple contacts to the same sel residue    counted)\n")
        outfile.write("#   10 refatm_selres_pair: % of ref-atom-   sel-residue pairs connected via N 'bonds'         (first element is meaningless)\n")
        outfile.write("#   11 refres_selatm_pair: % of ref-residue-sel-atom    pairs connected via N 'bonds'         (first element is meaningless)\n")
        outfile.write("#   12 refres_selres_pair: % of ref-residue-sel-residue pairs connected via N 'bonds'         (first element is meaningless)\n")
        outfile.write("#\n")
        outfile.write('# Column number:\n')
        outfile.write("# {:3d}   {:16d} {:16d} {:16d}   {:16d} {:16d} {:16d} {:16d} {:16d}   {:16d} {:16d} {:16d}\n"
                      .format(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))
        outfile.write("# {:>3s}   {:>16s} {:>16s} {:>16s}   {:>16s} {:>16s} {:>16s} {:>16s} {:>16s}   {:>16s} {:>16s} {:>16s}\n"
                      .format("N",                 #  1
                              "refatm_selatm",     #  2
                              "refatm_d_selres",   #  3
                              "refatm_s_selres",   #  4
                              "refres_d_selatm",   #  5
                              "refres_s_selatm",   #  6
                              "refres_selatm_t",   #  7
                              "refres_d_selres",   #  8
                              "refres_s_selres",   #  9
                              "refatm_selres_p",   # 10
                              "refres_selatm_p",   # 11
                              "refres_selres_p"))  # 12
        for i in range(last_nonzero+1):
            outfile.write("  {:3d}   {:16.9e} {:16.9e} {:16.9e}   {:16.9e} {:16.9e} {:16.9e} {:16.9e} {:16.9e}   {:16.9e} {:16.9e} {:16.9e}\n"
                          .format(i,                #  1
                                  hist_atm[0][i],   #  2
                                  hist_atm[1][i],   #  3
                                  hist_atm[2][i],   #  4
                                  hist_res[0][i],   #  5
                                  hist_res[1][i],   #  6
                                  hist_res[2][i],   #  7
                                  hist_res[3][i],   #  8
                                  hist_res[4][i],   #  9
                                  hist_par[0][i],   # 10
                                  hist_par[1][i],   # 11
                                  hist_par[2][i]))  # 12
        outfile.write("\n")
        outfile.write("\n")
        outfile.write("# Sums\n")
        outfile.write("  {:3d}   {:16.9e} {:16.9e} {:16.9e}   {:16.9e} {:16.9e} {:16.9e} {:16.9e} {:16.9e}   {:16.9e} {:16.9e} {:16.9e}\n"
                      .format(np.sum(np.arange(last_nonzero+1)),  #  1
                              np.sum(hist_atm[0]),                #  2
                              np.sum(hist_atm[1]),                #  3
                              np.sum(hist_atm[2]),                #  4
                              np.sum(hist_res[0]),                #  5
                              np.sum(hist_res[1]),                #  6
                              np.sum(hist_res[2]),                #  7
                              np.sum(hist_res[3]),                #  8
                              np.sum(hist_res[4]),                #  9
                              np.sum(hist_par[0]),                # 10
                              np.sum(hist_par[1]),                # 11
                              np.sum(hist_par[2])))               # 12
        outfile.flush()
    
    print("Written output to {}".format(args.OUTFILE))
    
    
    
    
    print("\n\n\nChecking output for consistency", flush=True)
    
    
    tol = 1e-2
    if not np.isclose(av_atm[1]*av_par_bound[0], av_atm[0], rtol=tol):
        raise ValueError("The average sel residue coordination number of"
                         " all ref atoms ({}) times the average number of"
                         " 'bonds' between ref-atom-sel-residue pairs ({})"
                         " differs from the average sel atom coordination"
                         " number of all ref atoms ({})"
                         .format(av_atm[1], av_par_bound[0], av_atm[0]))
    if not np.isclose(av_atm_bound[1]*av_par_bound[0],
                      av_atm_bound[0],
                      rtol=tol):
        raise ValueError("The average sel residue coordination number of"
                         " bound ref atoms ({}) times the average number of"
                         " 'bonds' between ref-atom-sel-residue pairs ({})"
                         " differs from the average sel atom coordination"
                         " number of bound ref atoms ({})"
                         .format(av_atm_bound[1],
                                 av_par_bound[0],
                                 av_atm_bound[0]))
    
    if not np.isclose(av_res[0]*av_par_bound[1], av_res[2], rtol=tol):
        raise ValueError("The average sel atom coordination number of all"
                         " ref atoms ({}) times the average number of"
                         " 'bonds' between ref-residue-sel-atom pairs ({})"
                         " differs from the average total sel atom"
                         " coordination number of all ref atoms ({})"
                         .format(av_res[0], av_par_bound[1], av_res[2]))
    if not np.isclose(av_res_bound[0]*av_par_bound[1],
                      av_res_bound[2],
                      rtol=tol):
        raise ValueError("The average sel atom coordination number of bound"
                         " ref atoms ({}) times the average number of"
                         " 'bonds' between ref-residue-sel-atom pairs ({})"
                         " differs from the average total sel atom"
                         " coordination number of bound ref atoms ({})"
                         .format(av_res_bound[0],
                                 av_par_bound[1],
                                 av_res_bound[2]))
    
    if not np.isclose(av_res[3]*av_par_bound[2], av_res[2], rtol=tol):
        raise ValueError("The average sel residue coordination number of"
                         " all ref atoms ({}) times the average number of"
                         " 'bonds' between ref-residue-sel-residue pairs"
                         " ({}) differs from the average total sel atom"
                         " coordination number of all ref atoms ({})"
                         .format(av_res[3], av_par_bound[2], av_res[2]))
    if not np.isclose(av_res_bound[3]*av_par_bound[2],
                      av_res_bound[2],
                      rtol=tol):
        raise ValueError("The average sel residue coordination number of"
                         " bound ref atoms ({}) times the average number of"
                         " 'bonds' between ref-residue-sel-residue pairs"
                         " ({}) differs from the average total sel atom"
                         " coordination number of bound ref atoms ({})"
                         .format(av_res_bound[3],
                                 av_par_bound[2],
                                 av_res_bound[2]))
    
    
    tol = 1e-4
    decs = 4
    for i in [0, 1]:
        if not np.isclose(np.sum(hist_atm[i]), 1, rtol=tol):
            raise ValueError("The sum over 'hist_atm[{}]' ({}) is not one"
                             .format(i, np.sum(hist_atm[i])))
    for i in [2]:
        if np.round(np.sum(hist_atm[i]), decimals=decs) < 1:
            raise ValueError("The sum over 'hist_atm[{}]' ({}) is less than"
                             " one".format(i, np.sum(hist_atm[i])))
        if np.any(np.round(hist_atm[i], decimals=decs) > 1):
            raise ValueError("At least one element of 'hist_atm[{}]' is"
                             " greater than one".format(i))
    
    for i in [0, 2, 3]:
        if not np.isclose(np.sum(hist_res[i]), 1, rtol=tol):
            raise ValueError("The sum over 'hist_res[{}]' ({}) is not one"
                             .format(i, np.sum(hist_res[i])))
    for i in [1, 4]:
        if np.round(np.sum(hist_res[i]), decimals=decs) < 1:
            raise ValueError("The sum over 'hist_res[{}]' ({}) is less than"
                             " one".format(i, np.sum(hist_res[i])))
        if np.any(np.round(hist_res[i], decimals=decs) > 1):
            raise ValueError("At least one element of 'hist_res[{}]' is"
                             " greater than one".format(i))
    
    
    for i in range(1, len(hist_atm)):
        if hist_atm[0][0] != hist_atm[i][0]:
            raise ValueError("The number of ref atoms not connected to any"
                             " sel atom is not the same in 'hist_atm[0][0]'"
                             " ({}) and 'hist_atm[{}][0]' ({})"
                             .format(hist_atm[0][0], i, hist_atm[i][0]))
    
    for i in range(1, len(hist_res)):
        if hist_res[0][0] != hist_res[i][0]:
            raise ValueError("The number of ref atoms not connected to any"
                             " sel atom is not the same in 'hist_res[0][0]'"
                             " ({}) and 'hist_res[{}][0]' ({})"
                             .format(hist_res[0][0], i, hist_res[i][0]))
    
    for i in range(1, len(hist_par)):
        if hist_par[i][0] != 0:
            raise ValueError("The first element of 'hist_par[{}][0]' ({})"
                             " is not zero".format(i, hist_par[i][0]))
    
    
    if ref.n_residues > 0 and not args.UPDATING_REF:
        occurence = np.array(
                        [len(np.intersect1d(ref.atoms.ids, refres.atoms.ids))
                         for refres in ref.residues],
                        dtype=np.uint32
                    )
        if np.all(occurence == 1):
            if np.any(hist_atm[0] != hist_res[0]):
                raise ValueError("The residues of the reference group"
                                 " contain only one atom of the reference"
                                 " group each, but 'hist_atm[0]' !="
                                 " 'hist_res[0]'")
            if np.any(hist_atm[0] != hist_res[2]):
                raise ValueError("The residues of the reference group"
                                 " contain only one atom of the reference"
                                 " group each, but 'hist_atm[0]' !="
                                 " 'hist_res[2]'")
            if np.any(hist_atm[1] != hist_res[3]):
                raise ValueError("The residues of the reference group"
                                 " contain only one atom of the reference"
                                 " group each, but 'hist_atm[1]' !="
                                 " 'hist_res[3]'")
            if np.any(hist_atm[2] != hist_res[4]):
                raise ValueError("The residues of the reference group"
                                 " contain only one atom of the reference"
                                 " group each, but 'hist_atm[2]' !="
                                 " 'hist_res[4]'")
            if not np.allclose(hist_res[1][:2],
                               np.array([hist_atm[0][0],
                                         1-hist_atm[0][0]]),
                               rtol=tol):
                raise ValueError("The residues of the reference group"
                                 " contain only one atom of the reference"
                                 " group each, but 'hist_res[1]' !="
                                 " '[x, 1-x]'")
            if not np.isclose(np.sum(hist_res[1]), 1, rtol=tol):
                raise ValueError("The residues of the reference group"
                                 " contain only one atom of the reference"
                                 " group each, but the sum over 'hist_res[1]'"
                                 " ({}) is not one"
                                 .format(np.sum(hist_res[1])))
            if np.any(hist_par[0] != hist_par[2]):
                raise ValueError("The residues of the reference group"
                                 " contain only one atom of the reference"
                                 " group each, but 'hist_par[0]' !="
                                 " 'hist_par[2]'")
            if not np.isclose(hist_par[1][1], 1, rtol=tol):
                raise ValueError("The residues of the reference group"
                                 " contain only one atom of the reference"
                                 " group each, but 'hist_par[1][1]' !="
                                 " '[0, 1]'")
            if not np.isclose(np.sum(hist_par[1]), 1, rtol=tol):
                raise ValueError("The residues of the reference group"
                                 " contain only one atom of the reference"
                                 " group each, but the sum over"
                                 " 'hist_par[1][1]' ({}) is not one"
                                 .format(np.sum(hist_par[1])))
        if np.all(occurence == occurence[0]):
            if not np.isclose(
                       np.sum(hist_atm[0]*np.arange(len(hist_atm[0]))),
                       np.sum(hist_res[2]*
                              np.arange(len(hist_res[2])))/occurence[0],
                       rtol=tol):
                raise ValueError("The total number of contacts between ref"
                                 " atoms and sel atoms per ref atom ({}) is"
                                 " not the same as the total number of"
                                 " contacts between ref residues and sel"
                                 " atoms per ref residue and of ref atoms"
                                 " per ref residue ({})"
                                 .format(
                                     np.sum(hist_atm[0]*
                                            np.arange(len(hist_atm[0]))),
                                     np.sum(hist_res[2]*
                                            np.arange(len(hist_res[2])))/occurence[0]
                                  )
                                )
    
    if sel.n_residues > 0 and not args.UPDATING_SEL:
        occurence = np.array(
                        [len(np.intersect1d(sel.atoms.ids, selres.atoms.ids))
                         for selres in sel.residues],
                        dtype=np.uint32
                    )
        if np.all(occurence == 1):
            if np.any(hist_atm[0] != hist_atm[1]):
                raise ValueError("The residues of the selection group"
                                 " contain only one atom of the selection"
                                 " group each, but 'hist_atm[0]' !="
                                 " 'hist_atm[1]'")
            if not np.allclose(hist_atm[2][:2],
                               np.array([hist_atm[0][0],
                                         1-hist_atm[0][0]]),
                               rtol=tol):
                raise ValueError("The residues of the selection group"
                                 " contain only one atom of the selection"
                                 " group each, but 'hist_atm[2]' !="
                                 " '[x, 1-x]'")
            if not np.isclose(np.sum(hist_atm[2]), 1, rtol=tol):
                raise ValueError("The residues of the selection group"
                                 " contain only one atom of the selection"
                                 " group each, but the sum over"
                                 " 'hist_atm[2]' ({}) is not one"
                                 .format(np.sum(hist_atm[2])))
            if np.any(hist_res[0] != hist_res[3]):
                raise ValueError("The residues of the selection group"
                                 " contain only one atom of the selection"
                                 " group each, but'hist_res[0]' !="
                                 " 'hist_res[3]'")
            if np.any(hist_res[1] != hist_res[4]):
                raise ValueError("The residues of the selection group"
                                 " contain only one atom of the selection"
                                 " group each, but'hist_res[1]' !="
                                 " 'hist_res[4]'")
            if not np.isclose(hist_par[0][1], 1, rtol=tol):
                raise ValueError("The residues of the selection group"
                                 " contain only one atom of the selection"
                                 " group each, but 'hist_par[0][1]' !="
                                 " '[0, 1]'")
            if not np.isclose(np.sum(hist_par[0]), 1, rtol=tol):
                raise ValueError("The residues of the selection group"
                                 " contain only one atom of the selection"
                                 " group each, but the sum over"
                                 " 'hist_par[0][1]' ({}) is not one"
                                 .format(np.sum(hist_par[0])))
            if np.any(hist_par[1] != hist_par[2]):
                raise ValueError("The residues of the selection group"
                                 " contain only one atom of the selection"
                                 " group each, but'hist_par[1]' !="
                                 " 'hist_par[2]'")
    
    
    
    
    print("\n\n\n", flush=True)
    print("{} done".format(os.path.basename(sys.argv[0])), flush=True)
    print("Elapsed time:         {}"
          .format(datetime.now()-timer_tot),
          flush=True)
    print("Current memory usage: {:.2f} MiB"
          .format(proc.memory_info().rss/2**20),
          flush=True)
