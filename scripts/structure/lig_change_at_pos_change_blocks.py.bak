#!/usr/bin/env python3

# This file is part of MDTools.
# Copyright (C) 2021  The MDTools Development Team and all contributors
# listed in the file AUTHORS.rst
#
# MDTools is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or (at your
# option) any later version.
#
# MDTools is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License
# along with MDTools.  If not, see <http://www.gnu.org/licenses/>.


r"""
Calculate how many selection :class:`Atoms <MDAnalysis.core.groups.Atom>`
and compounds stay attached to a reference compound that changed its
position.

See Also
--------
:mod:`lig_change_at_pos_change`
:mod:`contact_hist`
:mod:`contact_hist_at_pos_change`
:mod:`discrete_pos`
:mod:`state_probs_around_trans`

Notes
-----
The simulation box must be orthogonal, otherwise the discretization of
the center of mass positions of the reference compounds does not work.

Compounds are asigned to bins according to their center of mass position.
Compounds are made whole before calculating their centers of mass.  The
centers of mass are wrapped back into the primary unit cell before
discretizing their positions.

The discretization of the compounds' positions is done in relative box
coordinates.  The final output is scaled by the average box length in
the given spatial direction.  Doing so accounts for possible
fluctuations of the simulation box (e.g. due to pressure scaling).  Note
that :mod:`MDAnalysis` always sets the origin of the simulation box to
the origin of the cartesian coordinate system.

All bin intervals are left-closed and right-open, i.e. [a, b) ->
a <= x < b.  The first bin edge is always zero.  The last bin edge is
always the (average) box length in the chosen spatial direction (i.e. 1
in relative box coordinates) plus a small tolerance to account for the
right-open bin interval.

To chose an appropriate lag time :math:`\Delta t`, you can first apply
:mod:`state_probs_around_trans` on the output of :mod:`discrete_pos`.

.. todo::
    
    * Allow choice between center of mass and center of geometry.
    * Finish docstring.

"""


__author__ = "Andreas Thum"


# Standard libraries
import sys
import os
import warnings
import argparse
from datetime import datetime, timedelta
# Third party libraries
import psutil
import numpy as np
# Local application/library specific imports
import mdtools as mdt


if __name__ == '__main__':
    timer_tot = datetime.now()
    proc = psutil.Process(os.getpid())
    proc.cpu_percent()  # Initiate monitoring of CPU usage
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description=(
"""
Calculate how many selection atoms and compounds stay attached to a
reference compound that changed its position.

TODO: Description
"""))
    parser.add_argument(
        '-f',
        dest='TRJFILE',
        type=str,
        required=True,
        help="Trajectory file.  See supported coordinate formats of"
             " MDAnalysis."
    )
    parser.add_argument(
        '-s',
        dest='TOPFILE',
        type=str,
        required=True,
        help="Topology file.  See supported topology formats of"
             " MDAnalysis."
    )
    parser.add_argument(
        '-o',
        dest='OUTFILE',
        type=str,
        required=True,
        help="Output filename pattern.  There will be created two files:"
             "  <OUTFILE_contacts.txt> contains ... TODO;"
             "  <OUTFILE_bins.txt> contains the bin edges used for"
             " defining the position bins."
    )
    parser.add_argument(
        '-b',
        dest='BEGIN',
        type=int,
        required=False,
        default=0,
        help="First frame to read from the trajectory.  Frame numbering"
             " starts at zero.  Default: %(default)s."
    )
    parser.add_argument(
        '-e',
        dest='END',
        type=int,
        required=False,
        default=-1,
        help="Last frame to read from the trajectory.  This is"
             " exclusive, i.e. the last frame read is actually END-1."
             "  A value of -1 means to read the very last frame."
             "  Default: %(default)s."
    )
    parser.add_argument(
        '--every',
        dest='EVERY',
        type=int,
        required=False,
        default=1,
        help="Read every n-th frame from the trajectory.  Default:"
             " %(default)s."
    )
    parser.add_argument(
        '--ref',
        dest='REF',
        type=str,
        nargs='+',
        required=True,
        help="Selection string for the reference group.  See MDAnalysis'"
             " selection syntax for possible choices.  Example:"
             " 'type Li'."
    )
    parser.add_argument(
        '--sel',
        dest='SEL',
        type=str,
        nargs='+',
        required=True,
        help="Selection string for the selection group.  See MDAnalysis'"
             " selection syntax for possible choices.  Example:"
             " 'type OE'."
    )
    parser.add_argument(
        '-c',
        dest='CUTOFF',
        type=float,
        required=True,
        help="Cutoff distance in Angstrom.  A contact between a"
             " reference and selection atom is counted, if their"
             " distance is less than or equal to this cutoff."
    )
    parser.add_argument(
        '--refcmp',
        dest='REFCMP',
        type=str,
        required=False,
        choices=('group', 'segments', 'residues', 'fragments', 'atoms'),
        default='atoms',
        help="Choose the compounds of the reference group whose center"
             " of mass positions should be discretized and whose"
             " contacts to selection atoms and compounds should be"
             " compared before and after a position change.  Reference"
             " compounds can be 'group' (the entire reference group),"
             " 'segments', 'residues', 'fragments' or 'atoms'.  Refer to"
             " the MDAanalysis user guide for an explanation of these"
             " terms.  Compounds are made whole before calculating their"
             " centers of mass.  The centers of mass are wrapped back"
             " into the primary unit cell before discretizing their"
             " positions.  Note that in any case, even if REFCMP is e.g."
             " 'residues', only the atoms belonging to the reference"
             " group are taken into account for contact calculation,"
             " even if the compound might comprise additional atoms that"
             " are not contained in the reference group.  However, the"
             " center of mass calculation is done considering all atoms"
             " of a compound, including those that are not part of the"
             " reference group.  Default: %(default)s"
    )
    parser.add_argument(
        '--selcmp',
        dest='SELCMP',
        type=str,
        required=False,
        choices=('group', 'segments', 'residues', 'fragments'),
        default='residues',
        help="Contacts between reference compounds and selection atoms"
             " are always counted, but also contacts between reference"
             " and selection compounds.  Specify here, which compounds"
             " to use for the selection group.  Note that in any case,"
             " even if SELCMP is e.g. 'residues', only the atoms"
             " belonging to the selection group are taken into account,"
             " even if the compound might comprise additional atoms that"
             " are not contained in the selection group.  Default:"
             " %(default)s"
    )
    parser.add_argument(
        '--lag',
        dest='LAG',
        type=int,
        required=False,
        default=0,
        help="The lag time dt (in trajectory frames).  The coordination"
             " environment of the reference compounds is compared dt"
             " frames before they leave their block and dt frames after"
             " they entered the new block.  Must be equal to or greater"
             " than zero, but not greater than half of the total number"
             " of frames in the trajectory.  Must be an integer multiple"
             " of EVERY.  Default: %(default)s"
    )
    parser.add_argument(
        '--min-block-size',
        dest='MIN_BLOCK_SIZE',
        type=int,
        required=False,
        default=None,
        help="Blocks of same states must comprise at least this many"
             " frames.  Must be greater than LAG.  Must be an integer"
             " multiple of EVERY.  Default: 2*LAG if LAG is not zero,"
             " otherwise 2*EVERY"
    )
    parser.add_argument(
        '--max-gap-size',
        dest='MAX_GAP_SIZE',
        type=int,
        required=False,
        default=None,
        help="The gap between two following valid blocks must not be"
             " greater than this many frames in order to count the"
             " transition.  Must be equal to or greater than zero, but"
             " should be less than MIN_BLOCK_SIZE.  Must be an integer"
             " multiple of EVERY.  Default: LAG//(2*EVERY)"
    )
    parser.add_argument(
        '-d',
        dest='DIRECTION',
        type=str,
        required=False,
        choices=('x', 'y', 'z'),
        default='z',
        help="The spatial direction in which to bin the positions of"
             " the reference compounds.  Default: %(default)s"
    )
    parser.add_argument(
        '--bin-start',
        dest='START',
        type=float,
        required=False,
        default=0,
        help="Point (in Angstrom) on the chosen spatial direction to"
             " start binning.  Note that binning naturally starts at 0"
             " (origin of the simulation box).  If parsing a start value"
             " greater than zero, the first bin interval will be"
             " [0, START).  In this way you can determine the width of"
             " the first bin independently from the other bins.  Note"
             " that START must lie within the simulation box obtained"
             " from the first frame read and it must be smaller than"
             " STOP.  Default: %(default)s"
    )
    parser.add_argument(
        '--bin-end',
        dest='STOP',
        type=float,
        required=False,
        default=None,
        help="Point (in Angstrom) on the chosen spatial direction to"
             " stop binning.  Note that binning naturally ends at"
             " lbox+tol (length of the simulation box in the given"
             " spatial direction plus a small tolerance to account for"
             " the right-open bin interval).  If parsing a value less"
             " than lbox, the last bin interval will be"
             " [STOP, lbox+tol).  In this way you can determine the"
             " width of the last bin independently from the other bins."
             "  Note that STOP must lie within the simulation box"
             " obtained from the first frame read and it must be greater"
             " than START.  Default: lbox+tol"
    )
    parser.add_argument(
        '--bin-num',
        dest='NUM',
        type=int,
        required=False,
        default=10,
        help="Number of equidistant bins (not bin edges!) to use for"
             " discretizing the given spatial direction between START"
             " and STOP.  Note that two additional bins, [0, START) and"
             " [STOP, lbox+tol), are created if START is not zero and"
             " STOP is not lbox.  Default: %(default)s"
    )
    parser.add_argument(
        '--bins',
        dest='BINFILE',
        type=str,
        required=False,
        default=None,
        help="Text file containing custom bin edges (in Angstrom).  Bin"
             " edges are read from the first column, characters"
             " following a '#' are ignored.  Bins do not need to be"
             " equidistant.  All bin edges must lie within the"
             " simulation box as obtained from the first frame read."
             "  If --bins is given, it takes precedence over all other"
             " --bin* flags."
    )
    parser.add_argument(
        '--debug',
        dest='DEBUG',
        required=False,
        default=False,
        action='store_true',
        help="Run in debug mode."
    )
    args = parser.parse_args()
    print(mdt.rti.run_time_info_str())
    if args.CUTOFF <= 0:
        raise ValueError("-c ({}) must be positive".format(args.CUTOFF))
    if args.LAG < 0:
        raise ValueError("--lag ({}) must not be negative"
                         .format(args.LAG))
    if (args.MIN_BLOCK_SIZE is not None and
        args.MIN_BLOCK_SIZE <= args.LAG):
        raise ValueError("--min-block-size ({}) must be greater than"
                         " --lag ({})"
                         .format(args.MIN_BLOCK_SIZE, args.LAG))
    if args.MAX_GAP_SIZE is not None and args.MAX_GAP_SIZE < 0:
        raise ValueError("--max-gap-size ({}) must not be negative"
                         .format(args.MAX_GAP_SIZE))
    dim = {'x': 0, 'y': 1, 'z': 2}
    ixd = dim[args.DIRECTION]
    if mdt.rti.get_num_CPUs() > 1:
        mdabackend = 'OpenMP'
    else:
        mdabackend = 'serial'
    
    print("\n")
    u = mdt.select.universe(top=args.TOPFILE, trj=args.TRJFILE)
    print("\n")
    print("Creating selections...")
    timer = datetime.now()
    ref = u.select_atoms(' '.join(args.REF))
    sel = u.select_atoms(' '.join(args.SEL))
    if ref.n_atoms == 0:
        raise ValueError("The reference group contains no atoms")
    if sel.n_atoms == 0:
        raise ValueError("The selection group contains no atoms")
    print("Reference group: '{}'".format(' '.join(args.REF)))
    print(mdt.rti.ag_info_str(ag=ref, indent=2))
    print("Selection group: '{}'".format(' '.join(args.SEL)))
    print(mdt.rti.ag_info_str(ag=sel, indent=2))
    print("Elapsed time:         {}".format(datetime.now()-timer))
    print("Current memory usage: {:.2f} MiB"
          .format(proc.memory_info().rss/2**20))
    print("\n")
    print("Checking frame slice...")
    BEGIN, END, EVERY, N_FRAMES = mdt.check.frame_slicing(
        start=args.BEGIN,
        stop=args.END,
        step=args.EVERY,
        n_frames_tot=u.trajectory.n_frames
    )
    md_trj = u.trajectory[BEGIN:END:EVERY]
    print("\n")
    print("Checking 'LAG'...")
    LAG, LAG_EFF = mdt.check.frame_lag(
        lag=args.LAG,
        every=EVERY,
        n_frames_tot=u.trajectory.n_frames,
        allow_zero=True
    )
    if LAG_EFF > N_FRAMES // 2:
        LAG_EFF = N_FRAMES // 2
        LAG = LAG_EFF * EVERY
        print("Set 'LAG' to {}".format(LAG))
    print("\n")
    print("Checking 'MIN_BLOCK_SIZE'...")
    if args.MIN_BLOCK_SIZE is None:
        if LAG != 0:
            args.MIN_BLOCK_SIZE = 2 * LAG
        else:
            args.MIN_BLOCK_SIZE = 2 * EVERY
    MIN_BLOCK_SIZE, MIN_BLOCK_SIZE_EFF = mdt.check.frame_lag(
        lag=args.MIN_BLOCK_SIZE,
        every=EVERY,
        n_frames_tot=u.trajectory.n_frames,
    )
    if MIN_BLOCK_SIZE <= LAG:
        MIN_BLOCK_SIZE = LAG + 1
        MIN_BLOCK_SIZE_EFF = LAG_EFF + EVERY
        print("Set 'MIN_BLOCK_SIZE' to {}".format(MIN_BLOCK_SIZE))
    print("\n")
    print("Checking 'MAX_GAP_SIZE'...")
    if args.MAX_GAP_SIZE is None:
        args.MAX_GAP_SIZE = LAG // (2 * EVERY)
    MAX_GAP_SIZE, MAX_GAP_SIZE_EFF = mdt.check.frame_lag(
        lag=args.MAX_GAP_SIZE,
        every=EVERY,
        n_frames_tot=u.trajectory.n_frames,
        allow_zero=True
    )
    if MAX_GAP_SIZE >= MIN_BLOCK_SIZE:
        warnings.warn("'MAX_GAP_SIZE' ({}) should be less than"
                      " 'MIN_BLOCK_SIZE' ({})"
                      .format(MAX_GAP_SIZE, MIN_BLOCK_SIZE),
                      RuntimeWarning)
    
    # Reference group containing *all* atoms of the given compound (for
    # creating the discrete center of mass trajectory)
    if args.REFCMP == 'group':
        refcmp = ref
        N_REFCMPS = 1
    elif args.REFCMP == 'segments':
        refcmp = ref.segments.atoms
        N_REFCMPS = ref.n_segments
    elif args.REFCMP == 'residues':
        refcmp = ref.residues.atoms
        N_REFCMPS = ref.n_residues
    elif args.REFCMP == 'fragments':
        refcmp = ref.fragments.atoms
        N_REFCMPS = ref.n_fragments
    elif args.REFCMP == 'atoms':
        refcmp = ref
        N_REFCMPS = ref.n_atoms
    else:
        raise ValueError("--refcmp must be either 'group', 'segments',"
                         " 'residues', 'fragments', or 'atoms', but you"
                         " gave {}".format(args.REFCMP))
    # Number of atoms per compound (needed later in step 2 for the
    # calculation of contact matrices):
    natms_per_refcmp = mdt.strc.natms_per_cmp(ag=ref,
                                              compound=args.REFCMP,
                                              return_array=True,
                                              check_contiguos=True)
    if len(natms_per_refcmp) != N_REFCMPS:
        raise ValueError("'len(natms_per_refcmp)' ({}) != 'N_REFCMPS'"
                         " ({}). This should not have happened"
                         .format(len(natms_per_refcmp), N_REFCMPS))
    refcmp_slices = np.cumsum(natms_per_refcmp, dtype=np.uint32)
    refcmp_slices = np.insert(refcmp_slices, 0, 0)
    del natms_per_refcmp
    natms_per_selcmp = mdt.strc.natms_per_cmp(ag=sel,
                                              compound=args.SELCMP,
                                              check_contiguos=True)
    if np.ndim(natms_per_selcmp) == 0:
        N_SELCMPS = sel.n_atoms // natms_per_selcmp
    else:
        N_SELCMPS = len(natms_per_selcmp)
    
    print("\n")
    print("Step 1/2:")
    # Creating discrete position trajectory...
    if args.BINFILE is None:
        bins = None
    else:
        bins = np.loadtxt(args.BINFILE, usecols=0)
    dtrj, bins, lbox_av, time_step = mdt.strc.discrete_pos_trj(
        sel=refcmp,
        trj=md_trj,
        compound=args.REFCMP,
        direction=args.DIRECTION,
        bin_start=args.START,
        bin_stop=args.STOP,
        bin_num=args.NUM,
        bins=bins,
        return_bins=True,
        return_lbox=True,
        return_dt=True,
        dtype=np.uint32,
        verbose=True,
        debug=args.DEBUG
    )
    
    print("\n")
    print("Step 2/2:")
    print("Comparing coordination environments...")
    print("Number of compounds:    {:>8d}".format(N_REFCMPS))
    print("Total number of frames: {:>8d}".format(u.trajectory.n_frames))
    print("Frames to read:         {:>8d}".format(N_FRAMES))
    print("First frame to read:    {:>8d}".format(BEGIN))
    print("Last frame to read:     {:>8d}".format(END-1))
    print("Read every n-th frame:  {:>8d}".format(EVERY))
    print("Time first frame:       {:>12.3f} (ps)"
          .format(u.trajectory[BEGIN].time))
    print("Time last frame:        {:>12.3f} (ps)"
          .format(u.trajectory[END-1].time))
    print("Time step first frame:  {:>12.3f} (ps)"
          .format(u.trajectory[BEGIN].dt))
    print("Time step last frame:   {:>12.3f} (ps)"
          .format(u.trajectory[END-1].dt))
    timer = datetime.now()
    # Total number of state transitions
    n_state_trans = 0
    # Total number of valid blocks (block_size >= MIN_BLOCK_SIZE)
    n_valid_blocks = 0
    # Total number of block transitions (any gap_size) between
    #   0. two valid blocks with identical states ("backjumps")
    #   1. two valid blocks with different states
    n_block_trans = np.zeros(2, dtype=np.uint32)
    # Total number of valid block transitions (gap_size <= MAX_GAP_SIZE)
    n_valid_block_trans = np.zeros_like(n_block_trans)
    # Average of all gap sizes between valid blocks
    gap_size_av = np.zeros_like(n_block_trans)
    # Average of valid gap sizes between valid blocks
    valid_gap_size_av = np.zeros_like(n_valid_block_trans)
    # Number of refcmps bound to selatms before a valid block transition
    # (only needed to normalize selix_stats_b)
    n_refcmps_bound_b = np.zeros_like(n_valid_block_trans)
    # Number of refcmps bound to selatms after a valid block transition
    # (only needed to normalize selix_stats_a)
    n_refcmps_bound_a = np.zeros_like(n_refcmps_bound_b)
    # Number of refcmps bound to selatms before and after a valid block
    # transition (only needed to normalize selix_stats_diff)
    n_refcmps_bound_ba = np.zeros_like(n_refcmps_bound_b)
    # For contancts between refcmps and
    #  0. selatms,
    #  1. selcmps,
    # [^ -> Indices for 1st dimension]
    # compute the...
    # ...number of contacts between refcmps and selatms/selcmps
    #  0. before a valid block transition
    #  1. after a valid block transition
    #  2. common/remaining contacts
    # [^ -> Indices for 3rd dimension]
    n_contacts = np.zeros((2, len(n_valid_block_trans), 3),
                          dtype=np.uint32)
    # ...average
    #  0. average
    #  1. variance
    #  2. minimum
    #  3. maximum
    # [^ -> Indices for 3rd dimension]
    # of the indices of selatms/selcmps that are bound to refcmps
    selix_stats_b = np.zeros((2, len(n_refcmps_bound_b), 4),
                             dtype=np.float64)
    selix_stats_a = np.zeros((2, len(n_refcmps_bound_a), 4),
                             dtype=np.float64)
    # ...difference (before and after a valid block transition) of the
    #  0. average
    #  1. variance
    #  2. minimum
    #  3. maximum
    # [^ -> Indices for 3rd dimension]
    # of the indices of selatms/selcmps that are bound to refcmps
    selix_stats_diff = np.zeros((2, len(n_refcmps_bound_ba), 4),
                                dtype=np.float64)
    # Loop over single compound trajectories:
    dtrj = mdt.rti.ProgressBar(dtrj, unit="compounds")
    for c, cmp_trj in enumerate(dtrj):
        # Frames idices after state transitions
        trans = np.flatnonzero(np.diff(cmp_trj))
        trans += 1
        n_state_trans += len(trans)
        # Sizes (number of frames) of blocks of same states
        block_sizes = np.diff(trans, prepend=0, append=len(cmp_trj))
        del trans
        valid_blocks = (block_sizes >= MIN_BLOCK_SIZE_EFF)
        n_valid_blocks_tmp = np.count_nonzero(valid_blocks)
        if n_valid_blocks_tmp == 0:
            continue
        n_valid_blocks += n_valid_blocks_tmp
        # MDAnalysis AtomGroup containing a single reference compound:
        refcmp = ref[refcmp_slices[c]:refcmp_slices[c+1]]
        # Frame index where the current block ends:
        frame = -1
        # Loop over all blocks:
        for b, b_size in enumerate(block_sizes[:-1]):
            frame += b_size
            if not valid_blocks[b]:
                # Current block is too short
                continue
            # Index of next valid block:
            next_valid = b + 1 + np.argmax(valid_blocks[b+1:])
            if not valid_blocks[next_valid]:
                # All following blocks are too short
                break
            # Number of frames until the next valid block:
            gap_size = np.sum(block_sizes[b+1:next_valid])
            if cmp_trj[frame] == cmp_trj[frame+gap_size+1]:
                # Transition between blocks with identical states
                trans_type = 0
            else:
                # Transition between blocks with different states
                trans_type = 1
            n_block_trans[trans_type] += 1
            gap_size_av[trans_type] += gap_size
            if gap_size > MAX_GAP_SIZE_EFF:
                # Gap between two consecutive valid blocks is too large
                continue
            valid_gap_size_av[trans_type] += gap_size
            n_valid_block_trans[trans_type] += 1
            # refcmp-selatm contact matrix at t0_b-dt (b = "before"):
            ts = md_trj[frame-LAG_EFF]
            cm_b = mdt.strc.contact_matrix(
                ref=refcmp,
                sel=sel,
                cutoff=args.CUTOFF,
                compound=(args.REFCMP, 'atoms'),
                box=ts.dimensions,
                mdabackend=mdabackend
            )
            # refcmp-selatm contact matrix at t0_a+dt (a = "after"):
            ts = md_trj[frame+gap_size+1+LAG_EFF]
            cm_a = mdt.strc.contact_matrix(
                ref=refcmp,
                sel=sel,
                cutoff=args.CUTOFF,
                compound=(args.REFCMP, 'atoms'),
                box=ts.dimensions,
                mdabackend=mdabackend
            )
            for s in range(2):  # s=0 -> selatm,  s=1 -> selcmp
                if s == 1:
                    # refcmp-selcmp contact matrices
                    cm_b = mdt.strc.cmp_contact_matrix(
                        cm=cm_b,
                        natms_per_selcmp=natms_per_selcmp
                    )
                    cm_a = mdt.strc.cmp_contact_matrix(
                        cm=cm_a,
                        natms_per_selcmp=natms_per_selcmp
                    )
                n_contacts[s][trans_type] += mdt.strc.cms_n_contacts(
                    (cm_b, cm_a),
                    dtype=n_contacts.dtype
                )
                # Contact statistics before block transition
                selix_stats_b_tmp = np.squeeze(mdt.strc.cm_selix_stats(cm_b))
                if selix_stats_b_tmp[0] > 0:  # [0]=n_sel
                    if s == 0:
                        n_refcmps_bound_b[trans_type] += 1
                    # selix_stats_b_tmp[1:] = mean, var, min, max
                    selix_stats_b[s][trans_type] += selix_stats_b_tmp[1:]
                # Contact statistics after block transition
                selix_stats_a_tmp = np.squeeze(mdt.strc.cm_selix_stats(cm_a))
                if selix_stats_a_tmp[0] > 0:
                    if s == 0:
                        n_refcmps_bound_a[trans_type] += 1
                    selix_stats_a[s][trans_type] += selix_stats_a_tmp[1:]
                # Contact statistics difference
                if selix_stats_b_tmp[0] > 0 and selix_stats_a_tmp[0] > 0:
                    if s == 0:
                        n_refcmps_bound_ba[trans_type] += 1
                    selix_stats_diff[s][trans_type] += np.abs(
                        selix_stats_b_tmp[1:] - selix_stats_a_tmp[1:]
                    )
        # ProgressBar update:
        progress_bar_mem = proc.memory_info().rss / 2**20
        dtrj.set_postfix_str("{:>7.2f}MiB".format(progress_bar_mem),
                             refresh=False)
    dtrj.close()
    del dtrj, cmp_trj, block_sizes, valid_blocks, natms_per_selcmp
    print("Elapsed time:         {}".format(datetime.now()-timer))
    print("Current memory usage: {:.2f} MiB"
          .format(proc.memory_info().rss/2**20))
    
    if n_state_trans == 0:
        warnings.warn("The reference compounds did not change their"
                      " position bins. The output will be meaningless."
                      " Try another discretization", RuntimeWarning)
    if n_valid_blocks == 0:
        warnings.warn("The number of valid blocks is zero. The output"
                      " will be meaningless. Try to decrease the minimum"
                      " block size", RuntimeWarning)
    if n_valid_block_trans[0] == 0:
        warnings.warn("There are no valid block transitions between"
                      " blocks with identical states. The output for"
                      " 'backjumps' will be meaningless. Try to increase"
                      " the maximum gap size", RuntimeWarning)
    if n_valid_block_trans[1] == 0:
        warnings.warn("There are no valid block transitions between"
                      " blocks with different states. The output for"
                      " 'true_change' will be meaningless. Try to"
                      " increase the maximum gap size", RuntimeWarning)
    
    # Compute averages:
    gap_size_av = gap_size_av / n_block_trans
    valid_gap_size_av = valid_gap_size_av / n_valid_block_trans
    n_contacts = n_contacts / n_valid_block_trans[:,None]
    selix_stats_b /= n_refcmps_bound_b[:,None]
    selix_stats_a /= n_refcmps_bound_a[:,None]
    selix_stats_diff /= n_refcmps_bound_ba[:,None]
    
    # n_detached = n_contacts_before - n_remain
    # n_attached = n_contacts_after - n_remain
    for s in range(2):
        for trans_type in (0, 1):
            n_contacts[s][trans_type][:-1] -= n_contacts[s][trans_type][-1]
    
    print("\n")
    print("Creating output...")
    timer = datetime.now()
    # Contact information:
    fname = args.OUTFILE + "_contacts.txt"
    mdt.fh.write_header(fname)
    with open(fname, 'a') as outfile:
        outfile.write("# \n")
        outfile.write("# \n")
        outfile.write("# Reference: '{}'\n".format(' '.join(args.REF)))
        outfile.write(mdt.fh.indent(text=mdt.rti.ag_info_str(ag=ref),
                                    amount=1,
                                    char="#   ")
                      + "\n")
        outfile.write("# \n")
        outfile.write("# Selection: '{}'\n".format(' '.join(args.SEL)))
        outfile.write(mdt.fh.indent(text=mdt.rti.ag_info_str(ag=sel),
                                    amount=1,
                                    char="#   ")
                      + "\n")
        outfile.write("# \n")
        outfile.write("# \n")
        outfile.write("# Contacts before and after position change\n")
        outfile.write("# Cutoff (Angstrom):     {}\n".format(args.CUTOFF))
        outfile.write("# Reference compound:   '{}'\n".format(args.REFCMP))
        outfile.write("# Selection compound:   '{}'\n".format(args.SELCMP))
        outfile.write("# Lag time:              {:.3f} ps\n".format(LAG*time_step))
        outfile.write("# Minimum block size     {:.3f} ps\n".format(MIN_BLOCK_SIZE*time_step))
        outfile.write("# Maximum gap size       {:.3f} ps\n".format(MAX_GAP_SIZE*time_step))
        outfile.write("# Discretized dimension: {}\n".format(args.DIRECTION))
        outfile.write("# No. of analyzed frames:               {:>12d}\n".format(N_FRAMES))
        outfile.write("# No. of reference compounds (refcmps): {:>12d}\n".format(N_REFCMPS))
        outfile.write("# No. of selection atoms     (selatms): {:>12d}\n".format(sel.n_atoms))
        outfile.write("# No. of selection compounds (selcmps): {:>12d}\n".format(N_SELCMPS))
        outfile.write("# \n")
        outfile.write("# \n")
        outfile.write("# Tot. No. of transitions between position bins: {}\n".format(n_state_trans))
        outfile.write("# Tot. No. of valid blocks (>= min block size):  {}\n".format(n_valid_blocks))
        outfile.write("# \n")
        outfile.write("# \n")
        outfile.write("# The COLUMNS contain:\n")
        outfile.write("#   1 The row numbers\n")
        outfile.write("#   2 The row names\n")
        outfile.write("#   The following columns contain contact statistics for\n")
        outfile.write("#     refcmp-selatm contacts of refcmps that transition between\n")
        outfile.write("#       3 blocks with identical states ('backjumps')\n")
        outfile.write("#       4 blocks with different states ('true_change')\n")
        outfile.write("#     refcmp-selcmp contacts of refcmps that transition between\n")
        outfile.write("#       5 blocks with identical states ('backjumps')\n")
        outfile.write("#       6 blocks with different states ('true_change')\n")
        col_names = ("row_num", "row_name",
                     "backjumps", "true_change",
                     "backjumps", "true_change")
        outfile.write("# \n")
        outfile.write("# The ROWS contain:\n")
        outfile.write("#    1 Tot. No. of       block transitions\n")
        outfile.write("#    2 Tot. No. of valid block transitions (gap size <= max gap size)\n")
        outfile.write("#    3 Av. total gap size (in ps)\n")
        outfile.write("#    4 Av. size of valid gaps (in ps)\n")
        outfile.write("#    5 Av. No. of selatms/selcmps      detached     from a refcmp  during a valid block transition\n")
        outfile.write("#    6 Av. No. of selatms/selcmps      attached     to   a refcmp  during a valid block transition\n")
        outfile.write("#    7 Av. No. of selatms/selcmps that remain bound to   a refcmp  during a valid block transition\n")
        outfile.write("#    8 Av. average  of indices of selatms/selcmps that are bound to refcmps before a valid block transition\n")
        outfile.write("#    9 Av. average  of indices of selatms/selcmps that are bound to refcmps after  a valid block transition\n")
        outfile.write("#   10 Av. variance of indices of selatms/selcmps that are bound to refcmps before a valid block transition\n")
        outfile.write("#   11 Av. variance of indices of selatms/selcmps that are bound to refcmps after  a valid block transition\n")
        outfile.write("#   12 Av. minimum index       of selatms/selcmps that are bound to refcmps before a valid block transition\n")
        outfile.write("#   13 Av. minimum index       of selatms/selcmps that are bound to refcmps after  a valid block transition\n")
        outfile.write("#   14 Av. maximum index       of selatms/selcmps that are bound to refcmps before a valid block transition\n")
        outfile.write("#   15 Av. maximum index       of selatms/selcmps that are bound to refcmps after  a valid block transition\n")
        outfile.write("#   16 Av. absolute change of the average  of indices of selatms/selcmps that are bound to refcmps\n")
        outfile.write("#   17 Av. absolute change of the variance of indices of selatms/selcmps that are bound to refcmps\n")
        outfile.write("#   18 Av. absolute change of the minimum     index   of selatms/selcmps that are bound to refcmps\n")
        outfile.write("#   19 Av. absolute change of the maximum     index   of selatms/selcmps that are bound to refcmps\n")
        outfile.write("# \n")
        row_names = ("n_block_trans", "n_valid_block_trans",
                     "gap_size", "gap_size_valid",
                     "n_detached", "n_attached", "n_remain",
                     "ix_av_before", "ix_av_after",
                     "ix_var_before", "ix_var_after",
                     "ix_min_before", "ix_min_after",
                     "ix_max_before", "ix_max_after",
                     "ix_av_diff", "ix_var_diff",
                     "ix_min_diff", "ix_max_diff")
        # Column numbers:
        outfile.write("# {:>7d}".format(1))
        outfile.write(" {:<19d}".format(2))
        for c in range(3, len(col_names)+1):
            if c == 3 or c == 5:
                outfile.write("  ")
            outfile.write(" {:>16d}".format(c))
        outfile.write("\n")
        # Column "header headers":
        outfile.write("# {:<28s}".format(" "))
        outfile.write("   {:<33s}".format("refcmp_selatm"))
        outfile.write("   {:<s}\n".format("refcmp_selcmp"))
        # Column headers:
        outfile.write("# {:>7s}".format(col_names[0]))
        outfile.write(" {:<19s}".format(col_names[1]))
        for c, col_name in enumerate(col_names[2:], start=3):
            if c == 3 or c == 5:
                outfile.write("  ")
            outfile.write(" {:>16s}".format(col_name))
        outfile.write("\n")
        # Data:
        # n_block_trans
        row = 0
        outfile.write("{:>9d}".format(row+1))
        outfile.write(" {:<19s}".format(row_names[row]))
        for s in range(2):
            outfile.write("  ")
            for trans_type in (0, 1):
                outfile.write(" {:>16d}".format(n_block_trans[trans_type]))
        outfile.write("\n")
        # n_valid_block_trans
        row += 1
        outfile.write("{:>9d}".format(row+1))
        outfile.write(" {:<19s}".format(row_names[row]))
        for s in range(2):
            outfile.write("  ")
            for trans_type in (0, 1):
                outfile.write(" {:>16d}".format(n_valid_block_trans[trans_type]))
        outfile.write("\n")
        # gap_size_av
        row += 1
        outfile.write("{:>9d}".format(row+1))
        outfile.write(" {:<19s}".format(row_names[row]))
        for s in range(2):
            outfile.write("  ")
            for trans_type in (0, 1):
                outfile.write(" {:>16.9e}".format(gap_size_av[trans_type]*time_step))
        outfile.write("\n")
        # valid_gap_size_av
        row += 1
        outfile.write("{:>9d}".format(row+1))
        outfile.write(" {:<19s}".format(row_names[row]))
        for s in range(2):
            outfile.write("  ")
            for trans_type in (0, 1):
                outfile.write(" {:>16.9e}".format(valid_gap_size_av[trans_type]*time_step))
        outfile.write("\n")
        # n_contacts (detached, attached, remain)
        for i in range(n_contacts.shape[-1]):
            row += 1
            outfile.write("{:>9d}".format(row+1))
            outfile.write(" {:<19s}".format(row_names[row]))
            for s in range(2):
                outfile.write("  ")
                for trans_type in (0, 1):
                    outfile.write(" {:>16.9e}".format(n_contacts[s][trans_type][i]))
            outfile.write("\n")
        # selix_stats_b and selix_stats_a
        for i in range(selix_stats_b.shape[-1]):
            # selix_stats_b
            row += 1
            outfile.write("{:>9d}".format(row+1))
            outfile.write(" {:<19s}".format(row_names[row]))
            for s in range(2):
                outfile.write("  ")
                for trans_type in (0, 1):
                    outfile.write(" {:>16.9e}".format(selix_stats_b[s][trans_type][i]))
            outfile.write("\n")
            # selix_stats_a
            row += 1
            outfile.write("{:>9d}".format(row+1))
            outfile.write(" {:<19s}".format(row_names[row]))
            for s in range(2):
                outfile.write("  ")
                for trans_type in (0, 1):
                    outfile.write(" {:>16.9e}".format(selix_stats_a[s][trans_type][i]))
            outfile.write("\n")
        # selix_stats_diff
        for i in range(selix_stats_diff.shape[-1]):
            row += 1
            outfile.write("{:>9d}".format(row+1))
            outfile.write(" {:<19s}".format(row_names[row]))
            for s in range(2):
                outfile.write("  ")
                for trans_type in (0, 1):
                    outfile.write(" {:>16.9e}".format(selix_stats_diff[s][trans_type][i]))
            outfile.write("\n")
    print("Created {}".format(fname))
    # Bin edges:
    fname = args.OUTFILE + "_bins.txt"
    header = ("Bin edges in Angstrom\n"
              "Number of bin edges:                  {:<d}\n"
              "Number of bins:                       {:<d}\n"
              "Discretized spatial dimension:        {:<s}\n"
              "Average box length in this direction: {:<.9e} A\n"
              "Trajectory time step (first frame):   {:<.3f} ps\n"
              .format(len(bins),
                      len(bins)-1,
                      args.DIRECTION,
                      lbox_av,
                      time_step))
    mdt.fh.savetxt(fname=fname, data=bins, header=header)
    print("Created {}".format(fname))
    print("Elapsed time:         {}".format(datetime.now()-timer))
    print("Current memory usage: {:.2f} MiB"
          .format(proc.memory_info().rss/2**20))
    
    print("\n")
    print("Checking output for consistency...")
    timer = datetime.now()
    if n_state_trans > N_FRAMES * N_REFCMPS:
        raise ValueError("'n_state_trans' ({}) > 'N_FRAMES' ({}) *"
                         " 'N_REFCMPS' ({})"
                         .format(n_state_trans, N_FRAMES, N_REFCMPS))
    if n_valid_blocks > N_REFCMPS * N_FRAMES // MIN_BLOCK_SIZE_EFF:
        raise ValueError("'n_valid_blocks' ({}) > {} ('N_REFCMPS' {} *"
                         " 'N_FRAMES' {} // 'MIN_BLOCK_SIZE_EFF' {})"
                         .format(n_valid_blocks,
                                 N_REFCMPS*N_FRAMES//MIN_BLOCK_SIZE_EFF,
                                 N_REFCMPS,
                                 N_FRAMES,
                                 MIN_BLOCK_SIZE_EFF))
    if np.any(n_block_trans > n_state_trans):
        raise ValueError("'np.any(n_block_trans > n_state_trans)'"
                         "'n_block_trans' = {}\n"
                         "'n_state_trans' = {}\n"
                         .format(n_block_trans, n_state_trans))
    if np.sum(n_block_trans) > n_valid_blocks - 1:
        raise ValueError("'np.sum(n_block_trans) > n_valid_blocks - 1'\n"
                         "'n_block_trans' = {}\n"
                         "'n_valid_blocks' = {}"
                         .format(n_block_trans, n_valid_blocks))
    if np.any(n_valid_block_trans > n_block_trans):
        raise ValueError("'np.any(n_valid_block_trans > n_block_trans)'"
                         "'n_valid_block_trans' = {}\n"
                         "'n_block_trans' = {}\n"
                         .format(n_valid_block_trans, n_block_trans))
    if np.any(valid_gap_size_av > gap_size_av):
        raise ValueError("'np.any(valid_gap_size_av > gap_size_av)'\n"
                         "'valid_gap_size_av' = {}\n"
                         "'gap_size_av' = {}\n"
                         .format(valid_gap_size_av, gap_size_av))
    if np.any(n_refcmps_bound_b > N_FRAMES * N_REFCMPS):
        raise ValueError("'np.any(n_refcmps_bound_b > N_FRAMES * N_REFCMPS)'\n"
                         "'n_refcmps_bound_b' = {}\n"
                         "'N_FRAMES' = {}\n"
                         "'N_REFCMPS' = {}\n"
                         .format(n_refcmps_bound_b, N_FRAMES, N_REFCMPS))
    if np.any(n_refcmps_bound_a > N_FRAMES * N_REFCMPS):
        raise ValueError("'np.any(n_refcmps_bound_a > N_FRAMES * N_REFCMPS)'\n"
                         "'n_refcmps_bound_a' = {}\n"
                         "'N_FRAMES' = {}\n"
                         "'N_REFCMPS' = {}\n"
                         .format(n_refcmps_bound_a, N_FRAMES, N_REFCMPS))
    if np.any(n_refcmps_bound_ba > n_refcmps_bound_b):
        raise ValueError("'np.any(n_refcmps_bound_ba > n_refcmps_bound_b)'\n"
                         "'n_refcmps_bound_ba' = {}\n"
                         "'n_refcmps_bound_b' = {}\n"
                         .format(n_refcmps_bound_ba, n_refcmps_bound_b))
    if np.any(n_refcmps_bound_ba > n_refcmps_bound_a):
        raise ValueError("'np.any(n_refcmps_bound_ba > n_refcmps_bound_a)'\n"
                         "'n_refcmps_bound_ba' = {}\n"
                         "'n_refcmps_bound_a' = {}\n"
                         .format(n_refcmps_bound_ba, n_refcmps_bound_a))
    for s in range(2):
        for trans_type in (0, 1):
            if (selix_stats_b[s][trans_type][2] >
                selix_stats_b[s][trans_type][3]):
                raise ValueError(
                    "Minimum index ({}) is greater than maximum index"
                    " ({})"
                    .format(selix_stats_b[s][trans_type][2],
                            selix_stats_b[s][trans_type][3])
                )
    for s in range(2):
        for trans_type in (0, 1):
            if (selix_stats_a[s][trans_type][2] >
                selix_stats_a[s][trans_type][3]):
                raise ValueError(
                    "Minimum index ({}) is greater than maximum index"
                    " ({})"
                    .format(selix_stats_a[s][trans_type][2],
                            selix_stats_a[s][trans_type][3])
                )
    print("Elapsed time:         {}".format(datetime.now()-timer))
    print("Current memory usage: {:.2f} MiB"
          .format(proc.memory_info().rss/2**20))
    
    print("\n")
    print("{} done".format(os.path.basename(sys.argv[0])))
    print("Totally elapsed time: {}".format(datetime.now()-timer_tot))
    print("CPU time:             {}"
          .format(timedelta(seconds=sum(proc.cpu_times()[:4]))))
    print("CPU usage:            {:.2f} %".format(proc.cpu_percent()))
    print("Current memory usage: {:.2f} MiB"
          .format(proc.memory_info().rss/2**20))
